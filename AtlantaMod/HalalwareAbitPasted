wait(3)
loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))() -- ac bypass dont touch
-- Делаем основные сервисы глобальными для оптимизации количества локальных переменных
getgenv().S = {
    PS = game:GetService('Players'), RS = game:GetService('RunService'), WS = game:GetService('Workspace'),
    UIS = game:GetService('UserInputService'), TS = game:GetService('TweenService'), LS = game:GetService('Lighting'),
    CG = game:GetService('CoreGui'), SG = game:GetService('StarterGui'), SP = game:GetService('StarterPack'),
    SR = game:GetService('StarterPlayer'), RP = game:GetService('ReplicatedStorage'), RF = game:GetService('ReplicatedFirst'),
    SS = game:GetService('SoundService'), TV = game:GetService('TeleportService'), BS = game:GetService('BadgeService'),
    PL = game:GetService('PolicyService'), PF = game:GetService('PathfindingService'), DS = game:GetService('DataStoreService'),
    CH = game:GetService('Chat'), MSG = game:GetService('MessagingService'), FS = game:GetService('FriendService'),
    INS = game:GetService('InsertService'), TM = game:GetService('Teams'), SGv = game:GetService('StarterGear'),
    VR = game:GetService('VRService'), GU = game:GetService('GuiService'), TScr = game:GetService('TextService'),
    DB = game:GetService('Debris'), PH = game:GetService('PhysicsService'), LOC = game:GetService('LocalizationService'),
    TST = game:GetService('TestService'), VS = game:GetService('VoiceChatService'), NS = game:GetService('NotificationService'),
    HS = game:GetService('HttpService'), CS = game:GetService('CollectionService'), CP = game:GetService('ContentProvider'),
    PPS = game:GetService('ProximityPromptService'), TCS = game:GetService('TextChatService'), ES = game:GetService('ExperienceService'),
    PSS = game:GetService('PointsService'), GS = game:GetService('GroupService'), MS = game:GetService('MarketplaceService'),
}
local S = getgenv().S

-- Добавляем настройки SpreadMod
getgenv().SpreadMod = {
    BulletSpread = {
        Enabled = false,
        Amount = 0 
    }
}

-- Это основная логика модификатора разброса пуль (spread modificator)
getgenv().old_math_random = hookfunction(math.random, function(...)
    local args = { ... }

    if checkcaller() then
        return getgenv().old_math_random(...)
    end

    -- Проверка аргументов, характерных для расчета разброса пуль в игре
    if (#args == 0) or 
       (args[1] == -0.05 and args[2] == 0.05) or 
       (args[1] == -0.1) or
       (args[1] == -0.05) then

        if getgenv().SpreadMod.BulletSpread.Enabled then
            local spread = getgenv().SpreadMod.BulletSpread.Amount
            return getgenv().old_math_random(...) * (spread / 100)
        else
            return getgenv().old_math_random(...)
        end
    end

    return getgenv().old_math_random(...)
end)

-- Делаем вспомогательные функции глобальными
getgenv().M = {
    abs = math.abs, floor = math.floor, ceil = math.ceil, sqrt = math.sqrt, clamp = math.clamp,
    min = math.min, max = math.max, atan2 = math.atan2, acos = math.acos, asin = math.asin,
    cos = math.cos, sin = math.sin, tan = math.tan, rad = math.rad, deg = math.deg, random = math.random
}

getgenv().T = {
    insert = table.insert, remove = table.remove, sort = table.sort, find = table.find, concat = table.concat,
    clear = table.clear
}

getgenv().STR = {
    sub = string.sub, gsub = string.gsub, lower = string.lower, upper = string.upper,
    rep = string.rep, split = string.split, fmt = string.format
}

-- Локальные ссылки для быстрого доступа
local M = getgenv().M
local T = getgenv().T
local STR = getgenv().STR

getgenv().Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/libtest'))()
getgenv().ThemeManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/themes'))()
getgenv().SaveManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/savemanager'))()
local repo = getgenv().repo
local Library = getgenv().Library
local ThemeManager = getgenv().ThemeManager
local SaveManager = getgenv().SaveManager

-- Функция-обертка для тоглов с уведомлениями
getgenv().addToggleWithNotify = function(group, id, options)
    local originalCallback = options.Callback
    options.Callback = function(v)
        originalCallback(v)
        Library:Notify(">_< " .. (v and "on" or "off"), 3)
    end
    return group:AddToggle(id, options)
end
local addToggleWithNotify = getgenv().addToggleWithNotify

-- Делаем глобальными основные настройки и переменные
getgenv().G = {
    -- Трейсеры
    lastTracerUpdate = 0,
    tracerUpdateInterval = 1/60,
    ActiveTracers = {},
    TracerCount = 0,
    
    -- AutoAir
    autoAirDebounce = false,
    autoAirDebounceTime = 0.02, -- 100 мс между выстрелами
    
    -- Общие переменные дебаунса
    hitEffectDebounce = false,
    lastDamageTick = 0,
    
    -- Crosshair
    crosshairLines = {},
    crosshairOutlines = {},
    crosshairAngle = 0,
    crosshairConn = nil,
    
    -- Camera
    originalPlayerMaxZoom = 0,
    
    -- Target Strafe variables have been removed
    
    -- RapidFireM1
    rapidFireM1Firing = false,
    rapidFireM1Debounce = false,
    rapidFireM1MinDelay = 0,
    rapidFireM1ConnBegan = nil,
    rapidFireM1ConnEnded = nil,
    rapidFireM1CharConn = nil,
    
    -- YawLocker
    yawLockerConnection = nil,
    yawJitterState = 1,
    yawJitterTimer = 0,
    
    -- Grip
    GripSettings = {
        Enabled = false,
        Position = Vector3.new(0, 0, 0),
        Rotation = Vector3.new(0, 0, 0)
    },
    
    -- BulletTP
    bulletTpConns = {},
    bulletTpCFOffset = function(origin, target)
        local actualOrigin = origin * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
        return actualOrigin:ToObjectSpace(target):inverse()
    end
}

-- Локальная ссылка для быстрого доступа
local G = getgenv().G

local V3, V2, CF, C3, U2, RP = Vector3, Vector2, CFrame, Color3, UDim2, RaycastParams
local RND, SND, HRT = S.RS.RenderStepped, S.RS.Stepped, S.RS.Heartbeat
local LP = S.PS.LocalPlayer
local Char = LP.Character or LP.CharacterAdded:Wait()
local Body = {
    Hum = Char:FindFirstChildOfClass('Humanoid'),
    HRP = Char:FindFirstChild('HumanoidRootPart'),
    Head = Char:FindFirstChild('Head'),
    Tor = Char:FindFirstChild('Torso') or Char:FindFirstChild('UpperTorso'),
    LA = Char:FindFirstChild('Left Arm') or Char:FindFirstChild('LeftUpperArm'),
    RA = Char:FindFirstChild('Right Arm') or Char:FindFirstChild('RightUpperArm'),
    LL = Char:FindFirstChild('Left Leg') or Char:FindFirstChild('LeftUpperLeg'),
    RL = Char:FindFirstChild('Right Leg') or Char:FindFirstChild('RightUpperLeg'),
}

local Cam, Mse, Bp, Tm, UID, PGui = S.WS.CurrentCamera, LP:GetMouse(), LP:FindFirstChildOfClass('Backpack'), LP.Team, LP.UserId, LP:FindFirstChildOfClass('PlayerGui')

getgenv().Window = Library:CreateWindow({
    Title = 'Halalware',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})
local Window = getgenv().Window

getgenv().Tabs = {
    Combat = Window:AddTab('Combat'),
    Misc = Window:AddTab('Misc'),
    Visuals = Window:AddTab('Visuals'),
    Player = Window:AddTab('Player'),
    Config = Window:AddTab('Config'),
}
local Tabs = getgenv().Tabs

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
local MenuGroup = Tabs.Config:AddLeftGroupbox('Menu')
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'None',
    NoUI = true,
    Text = 'Menu',
})
Library.ToggleKeybind = Options.MenuKeybind
ThemeManager:ApplyToTab(Tabs.Config)
-- Добавляем хук на загрузку конфигурации для перезапуска трейсеров и других функций
local originalLoadConfig = SaveManager.Load
SaveManager.Load = function(self, ...)
    originalLoadConfig(self, ...)
    
    -- Запускаем функцию для применения всех настроек после загрузки конфига
    task.spawn(function()
        task.wait(0.5) -- Небольшая задержка для уверенности, что все настройки загрузились
        
        -- Перезапускаем трейсеры пуль если они включены
        if BulletTracersConfig and BulletTracersConfig.Enabled and getgenv().setupBulletEffects then
            getgenv().setupBulletEffects()
        end
        
        -- Применяем настройки Snow Effect если они включены
        if getgenv().SnowSettings and getgenv().SnowSettings.Enabled then
            if S.PS.LocalPlayer.Character then
                getgenv().ClearAllSnow() -- Сначала очищаем старый снег
                getgenv().CreateRealSnow(S.PS.LocalPlayer)
            end
        end
        
        -- Применяем настройки Trail если они включены
        if getgenv().TrailSettings and getgenv().TrailSettings.enabled then
            getgenv().removeTrail() -- Сначала удаляем старый трейл
            getgenv().applyTrail()
        end
        
        -- Применяем настройки SphereAura если они включены
        if getgenv().SphereAuraSettings and getgenv().SphereAuraSettings.enabled then
            getgenv().removePlayerAura() -- Сначала удаляем старую ауру
            getgenv().applyPlayerAura()
        end
        
        -- Применяем настройки CircleAura если они включены
        if getgenv().CircleAuraSettings and getgenv().CircleAuraSettings.enabled then
            if removeCircleAura then removeCircleAura() end
            if applyCircleAura then applyCircleAura() end
        end
        
        -- Применяем настройки FOV если они включены
        if FOVConfig and FOVConfig.Enabled then
            local fovValue = math.clamp(FOVConfig.Value, 1, 130)
            Cam.FieldOfView = fovValue
        end
        
        Library:Notify(">_< Config applied", 3)
    end)
end

-- Добавляем функцию обновления TargetHUD при изменении темы
getgenv().updateTargetHUDTheme = function()
    -- Проверяем существование TargetHUD
    if not G.TargetHUD or not G.TargetHUD.MainContainer then
        return
    end
    
    -- Обновляем основной контейнер
    G.TargetHUD.MainContainer.BackgroundColor3 = Library.MainColor
    G.TargetHUD.MainContainer.BorderColor3 = Library.OutlineColor
    
    -- Обновляем акцентную полосу
    if G.TargetHUD.MainContainer:FindFirstChild("AccentBar") then
        G.TargetHUD.MainContainer.AccentBar.BackgroundColor3 = Library.AccentColor
    end
    
    -- Обновляем внутренний градиент
    if G.TargetHUD.MainContainer:FindFirstChild("InnerFrame") then
        local gradient = G.TargetHUD.MainContainer.InnerFrame:FindFirstChild("UIGradient")
        if gradient then
            gradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),
                ColorSequenceKeypoint.new(1, Library.MainColor),
            })
        end
    end
    
    -- Обновляем контейнер аватара
    if G.TargetHUD.MainContainer:FindFirstChild("AvatarContainer") then
        G.TargetHUD.MainContainer.AvatarContainer.BackgroundColor3 = Library.MainColor
        G.TargetHUD.MainContainer.AvatarContainer.BorderColor3 = Library.OutlineColor
    end
    
    -- Обновляем текст имени пользователя
    if G.TargetHUD.MainContainer.InfoContainer:FindFirstChild("UsernameLabel") then
        G.TargetHUD.MainContainer.InfoContainer.UsernameLabel.TextColor3 = Library.FontColor
    end
    
    -- Обновляем контейнер здоровья
    if G.TargetHUD.MainContainer.InfoContainer:FindFirstChild("HealthContainer") then
        G.TargetHUD.MainContainer.InfoContainer.HealthContainer.BackgroundColor3 = Library.BackgroundColor
        G.TargetHUD.MainContainer.InfoContainer.HealthContainer.BorderColor3 = Library.OutlineColor
        
        -- Обновляем текст здоровья
        if G.TargetHUD.MainContainer.InfoContainer.HealthContainer:FindFirstChild("HealthText") then
            G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthText.TextColor3 = Library.FontColor
        end
        
        -- Обновляем полосу здоровья (если цель активна, оставляем текущий цвет)
        if G.TargetHUD.MainContainer.InfoContainer.HealthContainer:FindFirstChild("HealthBar") then
            if not G.TargetHUD.CurrentTarget then
                pcall(function()
            G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar.BackgroundColor3 = Library.AccentColor
                end)
            end
        end
    end
end

-- Добавляем хук на обновление темы без создания локальной переменной
getgenv().originalThemeUpdate = ThemeManager.ThemeUpdate
ThemeManager.ThemeUpdate = function(self)
    getgenv().originalThemeUpdate(self)
    getgenv().updateTargetHUDTheme()
end

SaveManager:BuildConfigSection(Tabs.Config)
SaveManager:LoadAutoloadConfig()

-- === HUD Section in Config ===
local HUDGroup = Tabs.Config:AddRightGroupbox('HUD')
HUDGroup:AddToggle('ShowWatermark', {
    Text = 'WMark',
    Default = false,
    Callback = function(v)
        if v then
            local name = LP and LP.Name or 'Player'
            pcall(function()
                Library:SetWatermark('halalware.skid | ' .. (name or "Player"))
            
            -- Делаем ватермарку видимой поверх всего интерфейса
            if Library.Watermark and Library.Watermark.Parent and Library.Watermark.Parent.DisplayOrder then
                Library.Watermark.Parent.DisplayOrder = 999999
            end
            end)
        else
            pcall(function()
            Library:SetWatermark('')
            end)
        end
    end
})
HUDGroup:AddToggle('ShowKeybinds', {
    Text = 'Keys',
    Default = false,
    Callback = function(v)
        if Library.KeybindFrame then
            Library.KeybindFrame.Visible = v
        end
    end
})

getgenv().ESPConfig = {
    Enabled = false,
    MaxDistance = 200,
    Box = {
        Enable = false, -- выключено по умолчанию
        Type = 'Full',
        Font = 'ProggyClean',
        Color = Color3.fromRGB(255, 255, 255),
        Filled = {
            Enable = false,
            Gradient = {
                Enable = false,
                Color = {
                    Start = Color3.fromRGB(255, 255, 255),
                    End = Color3.fromRGB(255, 255, 255),
                },
                Rotation = {
                    Enable = false,
                    Auto = true,
                },
                Transparency = 0.3,
            }
        }
    },
    Text = {
        Enable = false,
        Name = {
            Enable = false,
            Teamcheck = true,
            Color = Color3.fromRGB(255, 255, 255),
        },
        Studs = {
            Enable = false,
            Color = Color3.fromRGB(255, 255, 255),
        },
        Tool = {
            Enable = false,
            Color = Color3.fromRGB(255, 255, 255),
        },
    },
    Bars = {
        Enable = false,
        Health = {
            ShowOutline = false,
            Enable = false,
            Lerp = true,
            Color1 = Color3.fromRGB(255, 255, 255)
        }
    }
}

local ESPGroup = Tabs.Visuals:AddLeftGroupbox('>_<')
addToggleWithNotify(ESPGroup, 'ESPEnabled', {
    Text = 'ESP',
    Default = false,
    Callback = function(v) ESPConfig.Enabled = v end
})
ESPGroup:AddSlider('ESPMaxDist', {
    Text = 'MaxDistance',
    Min = 50, Max = 10000, Default = ESPConfig.MaxDistance,
    Rounding = 0,
    Callback = function(v) ESPConfig.MaxDistance = v end
})
ESPGroup:AddToggle('ESPBox', {
    Text = 'Box',
    Default = false,
    Callback = function(v) ESPConfig.Box.Enable = v end
}):AddColorPicker('ESPBoxColor', {
    Default = ESPConfig.Box.Color,
    Callback = function(v) ESPConfig.Box.Color = v end
})
ESPGroup:AddToggle('ESPBoxFilled', {
    Text = 'Filled',
    Default = false,
    Callback = function(v) ESPConfig.Box.Filled.Enable = v end
}):AddColorPicker('ESPBoxGradStart', {
    Default = ESPConfig.Box.Filled.Gradient.Color.Start,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Color.Start = v end
}):AddColorPicker('ESPBoxGradEnd', {
    Default = ESPConfig.Box.Filled.Gradient.Color.End,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Color.End = v end
})
ESPGroup:AddToggle('ESPBoxGradient', {
    Text = 'GradAnim',
    Default = false,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Enable = v end
})
ESPGroup:AddSlider('ESPBoxGradTrans', {
    Text = 'GradTrans',
    Min = 0, Max = 1, Default = ESPConfig.Box.Filled.Gradient.Transparency, Rounding = 2,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Transparency = v end
})
ESPGroup:AddToggle('ESPText', {
    Text = 'Text',
    Default = false,
    Callback = function(v) ESPConfig.Text.Enable = v end
})
ESPGroup:AddToggle('ESPName', {
    Text = 'Name',
    Default = false,
    Callback = function(v) ESPConfig.Text.Name.Enable = v end
}):AddColorPicker('ESPNameColor', {
    Default = ESPConfig.Text.Name.Color,
    Callback = function(v) ESPConfig.Text.Name.Color = v end
})
ESPGroup:AddToggle('ESPStuds', {
    Text = 'Studs',
    Default = false,
    Callback = function(v) ESPConfig.Text.Studs.Enable = v end
}):AddColorPicker('ESPStudsColor', {
    Default = ESPConfig.Text.Studs.Color,
    Callback = function(v) ESPConfig.Text.Studs.Color = v end
})
ESPGroup:AddToggle('ESPTool', {
    Text = 'Tool',
    Default = false,
    Callback = function(v) ESPConfig.Text.Tool.Enable = v end
}):AddColorPicker('ESPToolColor', {
    Default = ESPConfig.Text.Tool.Color,
    Callback = function(v) ESPConfig.Text.Tool.Color = v end
})
ESPGroup:AddToggle('ESPHealthbar', {
    Text = 'Healthbar',
    Default = false,
    Callback = function(v) ESPConfig.Bars.Health.Enable = v end
}):AddColorPicker('ESPHealthbarColor', {
    Default = ESPConfig.Bars.Health.Color1,
    Callback = function(v) ESPConfig.Bars.Health.Color1 = v end
})

-- === Bullet Tracers UI (ENGLISH, SHORT) ===
local BulletTracersGroup = Tabs.Visuals:AddRightGroupbox('>_<')

-- Делаем конфигурацию трейсеров глобальной
getgenv().BulletTracersConfig = {
    Enabled = false,
    Color1 = C3.new(1,1,1),
    Color2 = C3.new(1,1,1),
    Thickness = 1,
    Texture = "rbxassetid://446111271"
}
local BulletTracersConfig = getgenv().BulletTracersConfig
local BulletTextures = {
    ["Starhook"] = "rbxassetid://446111271",
    ["Chain"] = "rbxassetid://3029306948",
    ["Lightning"] = "rbxassetid://7216850022",
    ["Beam"] = "rbxassetid://1263079249"
}

local BulletToggle = addToggleWithNotify(BulletTracersGroup, 'BulletTracersEnabled', {
    Text = 'Tracer',
    Default = false,
    Callback = function(v) 
        BulletTracersConfig.Enabled = v 
        if v and getgenv().setupBulletEffects then
            getgenv().setupBulletEffects()
        end
    end
})
BulletToggle:AddColorPicker('BulletTracersColor1', {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
    Title = 'C1',
    Callback = function(val) BulletTracersConfig.Color1 = val end
})
BulletToggle:AddColorPicker('BulletTracersColor2', {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
    Title = 'C2',
    Callback = function(val) BulletTracersConfig.Color2 = val end
})
BulletTracersGroup:AddSlider('BulletTracersThickness', {
    Text = 'Thick',
    Default = BulletTracersConfig.Thickness,
    Min = 0.1, Max = 10, Rounding = 1,
    Callback = function(val) BulletTracersConfig.Thickness = val end
})
BulletTracersGroup:AddDropdown('BulletTracersTexture', {
    Text = 'Tex',
    Values = {"Starhook", "Chain", "Lightning", "Beam"},
    Default = 'Starhook',
    Callback = function(val) 
        BulletTracersConfig.Texture = BulletTextures[val] 
        -- Перезапускаем трейсеры при изменении текстуры, если они включены
        if BulletTracersConfig.Enabled and getgenv().setupBulletEffects then
            getgenv().setupBulletEffects()
        end
    end
})

-- === Bullet Tracers Logic (ONLY) ===
-- Состояние оружия
local gunState = {
    current_tool = nil,
    previous_ammo = 0,
    recently_shot = false,
    connections = {}
}

-- Определение игры и путей к пулям
local function detectGame()
    local placeId = game.PlaceId
    
    local gameData = {
        -- Da Hood
        [2788229376] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [71189885129233] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [5602055394] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [17403265390] = { BN = "Part", BBN = "gb", BP = "" },
        [17403166075] = { BN = "Part", BBN = "gb", BP = "" },
        [18111448661] = { BN = "Part", BBN = "gb", BP = "" },
        [15186202290] = { BN = "Part", BBN = "gb", BP = "" },
        [11143225577] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [15763494605] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [15166543806] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [17897702920] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [16033173781] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [7213786345] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [9825515356] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [16859411452] = { BN = "bulletray", BBN = "beam", BP = "Ignored" },
        [14277620939] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [0] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" }
    }
    
    local data = gameData[placeId] or gameData[0]
    return data
end

-- Получение пути к пулям
local function getPath(root, path)
    if path == "" then return root end
    local parts = STR.split(path, ".")
    local current = root
    for _, part in ipairs(parts) do
        current = current:FindFirstChild(part)
        if not current then return nil end
    end
    return current
end

-- Создание луча (beam)
local function createBeam(from, to, color1, color2, thickness, texture)
    -- Создаем невидимую основную часть
    local mainPart = Instance.new("Part")
    mainPart.Name = "BulletTracer"
    mainPart.Parent = S.WS
    mainPart.Size = V3.new(0, 0, 0)
    mainPart.Massless = true
    mainPart.Transparency = 1
    mainPart.CanCollide = false
    mainPart.Position = from
    mainPart.Anchored = true
    
    -- Создаем две точки для луча
    local part0 = Instance.new("Part")
    part0.Parent = mainPart
    part0.Size = V3.new(0, 0, 0)
    part0.Massless = true
    part0.Transparency = 1
    part0.CanCollide = false
    part0.Position = from
    part0.Anchored = true
    
    local part1 = Instance.new("Part")
    part1.Parent = mainPart
    part1.Size = V3.new(0, 0, 0)
    part1.Massless = true
    part1.Transparency = 1
    part1.CanCollide = false
    part1.Position = to
    part1.Anchored = true
    
    -- Создаем точки крепления для луча
    local attachment0 = Instance.new("Attachment")
    attachment0.Parent = part0
    
    local attachment1 = Instance.new("Attachment")
    attachment1.Parent = part1
    
    -- Создаем сам луч с градиентом цвета
    local beam = Instance.new("Beam")
    beam.Texture = texture
    beam.TextureMode = Enum.TextureMode.Wrap
    beam.TextureLength = 10
    beam.LightEmission = 1
    beam.LightInfluence = 1
    beam.FaceCamera = true
    beam.ZOffset = -1
    beam.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 1),
    })
    beam.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, color1),
        ColorSequenceKeypoint.new(1, color2),
    })
    beam.Attachment0 = attachment0
    beam.Attachment1 = attachment1
    beam.Width0 = thickness
    beam.Width1 = thickness
    beam.Enabled = true
    beam.Parent = mainPart
    
    -- Уничтожаем луч через указанное время
    task.delay(0.4, function()
        mainPart:Destroy()
    end)
end

-- Функция для получения оружия локального игрока
local function getGun(player)
    if not player or not player.Character then return nil end
    
    local tool = player.Character:FindFirstChildWhichIsA("Tool")
    if not tool then return nil end
    
    local gunInfo = {}
    
    -- Ищем значение патронов в оружии
    local descendants = tool:GetDescendants()
    for _, obj in ipairs(descendants) do
        if (STR.lower(obj.Name):find("ammo") and not STR.lower(obj.Name):find("max") and
            (obj.ClassName == "IntValue" or obj.ClassName == "NumberValue")) then
            gunInfo.ammo = obj
            gunInfo.tool = tool
            return gunInfo
        end
    end
    
    return nil
end

-- Функция для настройки отслеживания оружия
local function setupGunTracking(player)
    -- Очищаем текущие соединения
    for _, connection in ipairs(gunState.connections) do
        if connection then connection:Disconnect() end
    end
    gunState.connections = {}
    
    -- Если персонаж игрока не существует, создаем соединение на его появление
    if not player.Character then
        table.insert(gunState.connections, player.CharacterAdded:Connect(function(character)
            setupGunTracking(player)
        end))
        return
    end
    
    -- Отслеживаем добавление/удаление оружия
    table.insert(gunState.connections, player.Character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            local gun = getGun(player)
            if gun then
                gunState.current_tool = gun.tool
                gunState.previous_ammo = gun.ammo.Value
                
                -- Отслеживаем изменение количества патронов
                table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
                    local new_ammo = gun.ammo.Value
                    if new_ammo < gunState.previous_ammo then
                        gunState.recently_shot = true
                        task.wait() -- Короткая пауза для обнаружения пули
                        gunState.recently_shot = false
                    end
                    gunState.previous_ammo = new_ammo
                end))
            end
        end
    end))
    
    table.insert(gunState.connections, player.Character.ChildRemoved:Connect(function(child)
        if child == gunState.current_tool then
            gunState.current_tool = nil
            gunState.previous_ammo = 0
        end
    end))
    
    -- Проверяем наличие оружия сразу
    local gun = getGun(player)
    if gun then
        gunState.current_tool = gun.tool
        gunState.previous_ammo = gun.ammo.Value
        
        -- Отслеживаем изменение количества патронов
        table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
            local new_ammo = gun.ammo.Value
            if new_ammo < gunState.previous_ammo then
                gunState.recently_shot = true
                task.wait() -- Короткая пауза для обнаружения пули
                gunState.recently_shot = false
            end
            gunState.previous_ammo = new_ammo
        end))
    end
end

-- Основная функция для настройки эффектов пуль
local function setupBulletEffects()
    local gameData = detectGame()
    local bulletPath = getPath(S.WS, gameData.BP) or S.WS
    
    -- Настраиваем отслеживание оружия локального игрока
    setupGunTracking(LP)
    
    -- Отслеживаем добавление персонажа, если он еще не существует
    if not LP.Character then
        LP.CharacterAdded:Connect(function(character)
            setupGunTracking(LP)
        end)
    end
    
    -- Удаляем старые соединения, если они существуют
    if getgenv().bulletTracerConnection then
        getgenv().bulletTracerConnection:Disconnect()
        getgenv().bulletTracerConnection = nil
    end
    
    -- Следим за созданием новых пуль
    getgenv().bulletTracerConnection = bulletPath.ChildAdded:Connect(function(object)
        if not BulletTracersConfig.Enabled then return end
        
        -- Проверяем, чтобы это была пуля с правильным именем
        if object.Name == gameData.BN then
            task.spawn(function()
                local gunBeam = object:WaitForChild(gameData.BBN, 0.2)
                if not gunBeam then return end
                
                local startPos = object.Position
                local endPos = gunBeam.Attachment1.WorldPosition
                
                -- Удаляем оригинальный луч
                gunBeam:Destroy()
                
                -- Создаем трейсер
                createBeam(
                    startPos, 
                    endPos, 
                    BulletTracersConfig.Color1, 
                    BulletTracersConfig.Color2, 
                    BulletTracersConfig.Thickness,
                    BulletTracersConfig.Texture
                )
            end)
        end
    end)
    
    -- Добавляем дополнительное отслеживание для случаев, когда ChildAdded не срабатывает
    if getgenv().bulletTracerBackupConnection then
        getgenv().bulletTracerBackupConnection:Disconnect()
        getgenv().bulletTracerBackupConnection = nil
    end
    
    getgenv().bulletTracerBackupConnection = HRT:Connect(function()
        if not BulletTracersConfig.Enabled then return end
        
        -- Проверяем все пули в рабочем пространстве
        for _, object in ipairs(bulletPath:GetChildren()) do
            if object.Name == gameData.BN and object:IsA("BasePart") then
                local gunBeam = object:FindFirstChild(gameData.BBN)
                if gunBeam and not gunBeam:GetAttribute("Processed") then
                    gunBeam:SetAttribute("Processed", true)
                    
                    task.spawn(function()
                        local startPos = object.Position
                        local endPos = gunBeam.Attachment1.WorldPosition
                        
                        -- Удаляем оригинальный луч
                        gunBeam:Destroy()
                        
                        -- Создаем трейсер
                        createBeam(
                            startPos, 
                            endPos, 
                            BulletTracersConfig.Color1, 
                            BulletTracersConfig.Color2, 
                            BulletTracersConfig.Thickness,
                            BulletTracersConfig.Texture
                        )
                    end)
                end
            end
        end
    end)
end

-- Запускаем скрипт и делаем функцию глобальной для возможности перезапуска
getgenv().setupBulletEffects = setupBulletEffects
setupBulletEffects()

-- Старый код bullet tracers удален для избежания конфликтов с новой реализацией

getgenv().ESPCache = {}
getgenv().ESPConnections = {}
local ESPCache = getgenv().ESPCache
local ESPConnections = getgenv().ESPConnections
local gui_inset = S.GU:GetGuiInset()

getgenv().make_text = function(parent, font)
    local d = Instance.new("TextLabel")
    d.Parent = parent
    d.Size = U2.new(0, 4, 0, 4)
    d.BackgroundTransparency = 1
    d.TextColor3 = Color3.fromRGB(255,255,255)
    d.TextStrokeTransparency = 0
    d.TextScaled = false
    d.TextSize = 10
    d.TextStrokeColor3 = Color3.fromRGB(0,0,0)
    d.Font = font or Enum.Font.SourceSans
    return d
end
local make_text = getgenv().make_text

getgenv().clear_esp = function(player)
    local cache = ESPCache[player]
    if not cache then return end
    if cache.Box and cache.Box.Full then
        cache.Box.Full.Square.Visible = false
        cache.Box.Full.Outline.Visible = false
        cache.Box.Full.Inline.Visible = false
        if cache.Box.Full.Filled then
            cache.Box.Full.Filled.Visible = false
        end
    end
    if cache.Text then
        if cache.Text.Studs then cache.Text.Studs.Visible = false end
        if cache.Text.Tool then cache.Text.Tool.Visible = false end
        if cache.Text.Name then cache.Text.Name.Visible = false end
    end
    if cache.Bars then
        if cache.Bars.Health and cache.Bars.Health.Frame then
            cache.Bars.Health.Frame.Visible = false
            cache.Bars.Health.Outline.Visible = false
        end
    end
end
local clear_esp = getgenv().clear_esp

getgenv().render_esp = function(player)
    if not player then return end
    ESPCache[player] = ESPCache[player] or {}
    local cache = ESPCache[player]
    cache.Box = cache.Box or {}
    cache.Bars = cache.Bars or {}
    cache.Text = cache.Text or {}
    cache.Box.Full = cache.Box.Full or {
        Square = Drawing.new("Square"),
        Inline = Drawing.new("Square"),
        Outline = Drawing.new("Square"),
        Filled = Instance.new('Frame', Instance.new('ScreenGui', S.CG))
    }
    local Studs = Instance.new("ScreenGui")
    Studs.Parent = S.CG
    local Name = Instance.new("ScreenGui")
    Name.Parent = S.CG
    local Tool = Instance.new("ScreenGui")
    Tool.Parent = S.CG
    cache.Text.Studs = make_text(Studs)
    cache.Text.Tool = make_text(Tool)
    cache.Text.Name = make_text(Name)
    local healthGui = Instance.new("ScreenGui")
    healthGui.Name = player.Name .. "_HealthBar"
    healthGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    healthGui.Parent = S.CG
    local healthOutline = Instance.new("Frame")
    healthOutline.BackgroundColor3 = Color3.new(0, 0, 0)
    healthOutline.BorderSizePixel = 0
    healthOutline.Name = "Outline"
    healthOutline.Parent = healthGui
    local healthFill = Instance.new("Frame")
    healthFill.BackgroundTransparency = 0
    healthFill.BorderSizePixel = 0
    healthFill.Name = "Fill"
    healthFill.Parent = healthOutline
    healthFill.BackgroundColor3 = ESPConfig.Bars.Health.Color1
    cache.Bars.Health = {
        Gui = healthGui,
        Outline = healthOutline,
        Frame = healthFill
    }
end
local render_esp = getgenv().render_esp

getgenv().update_esp = function(player)
    if not player or not ESPCache[player] then return end
    local character = player.Character
    if not character or not LP.Character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local client_root_part = LP.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if not rootPart or not humanoid or not client_root_part then 
        clear_esp(player)
        return 
    end
    if (client_root_part.Position - rootPart.Position).Magnitude > ESPConfig.MaxDistance or not ESPConfig.Enabled then
        clear_esp(player)
        return
    end
    local hrp2D, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position)
    local charSize = (S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position - V3.new(0, 1, 0)).Y - S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position + V3.new(0, 3, 0)).Y) / 2
    local size = V2.new(M.floor(charSize * 1.5), M.floor(charSize * 3.2)) 
    local position = V2.new(M.floor(hrp2D.X - charSize * 1.5 / 2), M.floor(hrp2D.Y - charSize * 3 / 2))
    local cache = ESPCache[player]
    if not onScreen then
        clear_esp(player)
        return
    end
    if ESPConfig.Box.Enable then
        if ESPConfig.Box.Type == "Full" then
            cache.Box.Full.Square.Visible = true
            cache.Box.Full.Square.Position = position
            cache.Box.Full.Square.Size = size
            cache.Box.Full.Square.Color = ESPConfig.Box.Color
            cache.Box.Full.Square.Thickness = 2
            cache.Box.Full.Square.Filled = false
            cache.Box.Full.Square.ZIndex = 9e9
            cache.Box.Full.Outline.Visible = true
            cache.Box.Full.Outline.Position = position - V2.new(1, 1)
            cache.Box.Full.Outline.Size = size + V2.new(2, 2)
            cache.Box.Full.Outline.Color = Color3.new(0, 0, 0)
            cache.Box.Full.Outline.Thickness = 1
            cache.Box.Full.Inline.Visible = true
            cache.Box.Full.Inline.Position = position + V2.new(1, 1)
            cache.Box.Full.Inline.Size = size - V2.new(2, 2)
            cache.Box.Full.Inline.Color = Color3.new(0, 0, 0)
            cache.Box.Full.Inline.Thickness = 1
            cache.Box.Full.Inline.Filled = false
            if ESPConfig.Box.Filled.Enable and cache.Box.Full.Filled then
                cache.Box.Full.Filled.Position = U2.new(0, position.X, 0, position.Y - S.GU:GetGuiInset().Y)
                cache.Box.Full.Filled.Size = U2.new(0, size.X, 0, size.Y)
                cache.Box.Full.Filled.BackgroundTransparency = ESPConfig.Box.Filled.Gradient.Transparency or 0.5
                cache.Box.Full.Filled.BackgroundColor3 = Color3.new(1, 1, 1)
                cache.Box.Full.Filled.Visible = true
                cache.Box.Full.Filled.ZIndex = -9e9
                local gradient = cache.Box.Full.Filled:FindFirstChild("Gradient") or Instance.new("UIGradient")
                gradient.Name = "Gradient"
                gradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, ESPConfig.Box.Filled.Gradient.Color.Start),
                    ColorSequenceKeypoint.new(1, ESPConfig.Box.Filled.Gradient.Color.End)
                })
                if ESPConfig.Box.Filled.Gradient.Enable then
                    gradient.Rotation = M.sin(tick() * 2) * 180
                else
                    gradient.Rotation = 0
                end
                if not gradient.Parent then gradient.Parent = cache.Box.Full.Filled end
            elseif cache.Box.Full.Filled then
                cache.Box.Full.Filled.Visible = false
            end
        else
            cache.Box.Full.Square.Visible = false
            cache.Box.Full.Outline.Visible = false
            cache.Box.Full.Inline.Visible = false
            if cache.Box.Full.Filled then cache.Box.Full.Filled.Visible = false end
        end
    else
        cache.Box.Full.Square.Visible = false
        cache.Box.Full.Outline.Visible = false
        cache.Box.Full.Inline.Visible = false
        if cache.Box.Full.Filled then cache.Box.Full.Filled.Visible = false end
    end
    if ESPConfig.Bars.Health.Enable and humanoid then
        local targetHealth = M.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local lastHealth = cache.Bars.Health.LastHealth or targetHealth
        local lerpedHealth = lastHealth + (targetHealth - lastHealth) * 0.05
        cache.Bars.Health.LastHealth = lerpedHealth
        local x = position.X - 7
        if cache.Bars.Health.Outline and cache.Bars.Health.Frame then
            cache.Bars.Health.Outline.Visible = true
            cache.Bars.Health.Outline.Position = U2.new(0, x - 1, 0, position.Y - S.GU:GetGuiInset().Y - 1)
            cache.Bars.Health.Outline.Size = U2.new(0, 5, 0, size.Y + 1.1)
            cache.Bars.Health.Outline.BackgroundTransparency = 0.2
            cache.Bars.Health.Frame.Visible = true
            cache.Bars.Health.Frame.Position = U2.new(0, 1, 0, (1 - lerpedHealth) * size.Y + 1)
            cache.Bars.Health.Frame.Size = U2.new(0, 3, 0, lerpedHealth * size.Y)
            cache.Bars.Health.Frame.BackgroundColor3 = ESPConfig.Bars.Health.Color1
        end
    else
        if cache.Bars.Health.Outline then cache.Bars.Health.Outline.Visible = false end
        if cache.Bars.Health.Frame then cache.Bars.Health.Frame.Visible = false end
    end
    if ESPConfig.Text.Enable then
        if cache.Text.Name then
            cache.Text.Name.Visible = ESPConfig.Text.Name.Enable
            if ESPConfig.Text.Name.Enable then
                cache.Text.Name.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Name.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y - 9)
                cache.Text.Name.Text = player.Name
                cache.Text.Name.TextColor3 = ESPConfig.Text.Name.Color
            end
        end
        if cache.Text.Tool then
            cache.Text.Tool.Visible = ESPConfig.Text.Tool.Enable
            if ESPConfig.Text.Tool.Enable then
                cache.Text.Tool.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Tool.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y + size.Y + 15)
                local tool = character:FindFirstChildOfClass("Tool")
                cache.Text.Tool.Text = tool and tool.Name or "none"
                cache.Text.Tool.TextColor3 = ESPConfig.Text.Tool.Color
            end
        end
        if cache.Text.Studs then
            cache.Text.Studs.Visible = ESPConfig.Text.Studs.Enable
            if ESPConfig.Text.Studs.Enable then
                cache.Text.Studs.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Studs.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y + size.Y + 5)
                local meters = (S.WS.CurrentCamera.CFrame.Position - rootPart.Position).Magnitude * 0.28
                cache.Text.Studs.Text = STR.fmt("[%.0fm]", meters)
                cache.Text.Studs.TextColor3 = ESPConfig.Text.Studs.Color
            end
        end
    else
        if cache.Text.Name then cache.Text.Name.Visible = false end
        if cache.Text.Tool then cache.Text.Tool.Visible = false end
        if cache.Text.Studs then cache.Text.Studs.Visible = false end
    end
end

for _, player in ipairs(S.PS:GetPlayers()) do
    if player ~= LP then
        render_esp(player)
    end
end
S.PS.PlayerAdded:Connect(function(player)
    if player ~= LP then
        render_esp(player)
    end
end)
S.PS.PlayerRemoving:Connect(function(player)
    if player ~= LP then
        clear_esp(player)
    end
end)

if ESPConnections.Heartbeat then ESPConnections.Heartbeat:Disconnect() end
ESPConnections.Heartbeat = HRT:Connect(function()
    for v, _ in pairs(ESPCache) do
        if v then
            update_esp(v)
        end
    end
end)

local NameESPGroup = Tabs.Visuals:AddRightGroupbox('>_<')
local ShowNameMethodConfig = {
    Mode = 'Display',
}

NameESPGroup:AddDropdown('ShowNameMethod', {
    Values = {'Display', 'Default', 'None'},
    Default = 'Display',
    Multi = false,
    Text = 'ShowNameMethod',
    Callback = function(v) ShowNameMethodConfig.Mode = v end
})

local function UpdateShowNameMethod(player)
    if player == LP then return end
    local char = player.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass('Humanoid')
    if not hum then return end
    if ShowNameMethodConfig.Mode == 'None' then
        hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        return
    end
    hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
    hum.NameOcclusion = Enum.NameOcclusion.NoOcclusion
    hum.DisplayName = (ShowNameMethodConfig.Mode == 'Display' and player.DisplayName ~= '' and player.DisplayName) or player.Name
end

local function UpdateAllShowNameMethod()
    for _, p in ipairs(S.PS:GetPlayers()) do
        UpdateShowNameMethod(p)
    end
end

S.PS.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function() UpdateShowNameMethod(p) end)
end)
for _, p in ipairs(S.PS:GetPlayers()) do
    if p.Character then UpdateShowNameMethod(p) end
    p.CharacterAdded:Connect(function() UpdateShowNameMethod(p) end)
end
HRT:Connect(UpdateAllShowNameMethod)

-- Unlock Camera Distance (Misc)


-- Сохраняем оригинальные значения при загрузке
G.originalPlayerMaxZoom = LP.CameraMaxZoomDistance
G.originalPlayerMinZoom = LP.CameraMinZoomDistance


-- SphereAura UI и логика
getgenv().SphereAuraSettings = {
    enabled = false,
    color1 = Color3.new(1, 1, 1),
    color2 = Color3.new(1, 1, 1),
    size = 10,
    lightEmission = 1
}
local SphereAuraSettings = getgenv().SphereAuraSettings
getgenv().currentAura = nil
local currentAura = getgenv().currentAura

getgenv().updateAura = function(prop)
    if not (currentAura and currentAura.Parent) then return end
    local swirl = currentAura:FindFirstChild("Attachment"):FindFirstChild("swirl")
    if not swirl then return end
    if prop == "color" or prop == nil then
        swirl.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, SphereAuraSettings.color1), ColorSequenceKeypoint.new(1, SphereAuraSettings.color2)})
    end
    if prop == "size" or prop == nil then
        swirl.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, SphereAuraSettings.size), NumberSequenceKeypoint.new(1, SphereAuraSettings.size)})
    end
    if prop == "light" or prop == nil then
        swirl.LightEmission = SphereAuraSettings.lightEmission
    end
end
local updateAura = getgenv().updateAura

getgenv().removePlayerAura = function()
    if currentAura and currentAura.Parent then currentAura:Destroy() end
    getgenv().currentAura = nil
    currentAura = nil
end
local removePlayerAura = getgenv().removePlayerAura

getgenv().createPlayerAura = function(character)
    removePlayerAura()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 3)
    if not humanoidRootPart then return end
    local auraBase = Instance.new("Part")
    auraBase.Size, auraBase.Transparency, auraBase.Anchored, auraBase.CanCollide, auraBase.Name, auraBase.Parent = Vector3.new(1, 1, 1), 1, false, false, "AuraBase", S.WS
    local weld = Instance.new("Weld")
    weld.Part0, weld.Part1, weld.C0, weld.Parent = humanoidRootPart, auraBase, CFrame.new(0, 0, 0), auraBase
    local attachment = Instance.new("Attachment")
    attachment.Parent = auraBase
    local swirlEmitter = Instance.new("ParticleEmitter")
    swirlEmitter.Name, swirlEmitter.Texture, swirlEmitter.Lifetime, swirlEmitter.Rate, swirlEmitter.RotSpeed, swirlEmitter.Speed = "swirl", "rbxassetid://10558425570", NumberRange.new(2), 150, NumberRange.new(200), NumberRange.new(0.01)
    swirlEmitter.SpreadAngle, swirlEmitter.VelocitySpread, swirlEmitter.Size, swirlEmitter.Transparency = Vector2.new(-360, 360), -360, NumberSequence.new({NumberSequenceKeypoint.new(0, SphereAuraSettings.size), NumberSequenceKeypoint.new(1, SphereAuraSettings.size)}), NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5006, 0.5), NumberSequenceKeypoint.new(1, 1)})
    swirlEmitter.Color, swirlEmitter.LightEmission, swirlEmitter.ZOffset, swirlEmitter.Orientation, swirlEmitter.LockedToPart, swirlEmitter.Parent = ColorSequence.new({ColorSequenceKeypoint.new(0, SphereAuraSettings.color1), ColorSequenceKeypoint.new(1, SphereAuraSettings.color2)}), SphereAuraSettings.lightEmission, -1, Enum.ParticleOrientation.VelocityPerpendicular, true, attachment
    getgenv().currentAura = auraBase
    currentAura = auraBase
end
local createPlayerAura = getgenv().createPlayerAura

getgenv().applyPlayerAura = function()
    local character = LP.Character
    if not character then
        getgenv().characterAddedConnection = nil
        local characterAddedConnection = getgenv().characterAddedConnection
        if characterAddedConnection then characterAddedConnection:Disconnect() end
        getgenv().characterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if SphereAuraSettings.enabled then createPlayerAura(newCharacter) end
        end)
        return
    end
    createPlayerAura(character)
    if not getgenv().characterAddedConnection then
        getgenv().characterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if SphereAuraSettings.enabled then createPlayerAura(newCharacter) end
        end)
    end
end
local applyPlayerAura = getgenv().applyPlayerAura

getgenv().GetSphereAuraSettings = function() return SphereAuraSettings end

local SphereAuraGroup = Tabs.Visuals:AddRightGroupbox('>_<')
addToggleWithNotify(SphereAuraGroup, 'SphereAura', {
    Text = 'SphereAura',
    Default = false,
    Callback = function(v)
        SphereAuraSettings.enabled = v
        if v then
            applyPlayerAura()
        else
            removePlayerAura()
        end
    end
}):AddColorPicker('SphereAuraColor1', {
    Default = SphereAuraSettings.color1,
    Title = 'Color 1',
    Callback = function(val)
        SphereAuraSettings.color1 = val
        updateAura("color")
    end
}):AddColorPicker('SphereAuraColor2', {
    Default = SphereAuraSettings.color2,
    Title = 'Color 2',
    Callback = function(val)
        SphereAuraSettings.color2 = val
        updateAura("color")
    end
})

local SphereAuraSub = SphereAuraGroup:AddDependencyBox()
SphereAuraSub:AddSlider('SphereAuraSize', {
    Text = 'Size',
    Default = SphereAuraSettings.size,
    Min = 1,
    Max = 50,
    Rounding = 1,
    Callback = function(val)
        SphereAuraSettings.size = val
        updateAura("size")
    end
})
SphereAuraSub:AddSlider('SphereAuraLightEmission', {
    Text = 'LightEmission',
    Default = SphereAuraSettings.lightEmission,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Callback = function(val)
        SphereAuraSettings.lightEmission = val
        updateAura("light")
    end
})
SphereAuraSub:SetupDependencies({{Toggles.SphereAura, true}})

-- CircleAura UI и логика
local CircleAuraSettings = {
    enabled = false,
    beamColor = Color3.new(1, 1, 1),
    circleColor = Color3.new(1, 1, 1),
    lightEmission = 0.8,
    circleTexture = "rbxassetid://8920246243"
}
local currentCircleAura

local function removeCircleAura()
    if currentCircleAura and currentCircleAura.Parent then currentCircleAura:Destroy() end
    currentCircleAura = nil
end

local function updateCircleAura(prop)
    if not (currentCircleAura and currentCircleAura.Parent) then return end
    for _, obj in pairs(currentCircleAura:GetDescendants()) do
        if (prop == nil or prop == "beamColor") and obj:IsA("Beam") then
            obj.Color = ColorSequence.new(CircleAuraSettings.beamColor)
        end
        if (prop == nil or prop == "circleColor") and obj:IsA("ParticleEmitter") and obj.Name == "Circle" then
            obj.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, CircleAuraSettings.circleColor), ColorSequenceKeypoint.new(1, CircleAuraSettings.circleColor)})
        end
        if (prop == nil or prop == "lightEmission") and (obj:IsA("Beam") or obj:IsA("ParticleEmitter")) then
            obj.LightEmission = CircleAuraSettings.lightEmission
        end
        if (prop == nil or prop == "circleTexture") and obj:IsA("ParticleEmitter") and obj.Name == "Circle" then
            obj.Texture = CircleAuraSettings.circleTexture
        end
    end
end

local function createCircleAura(character)
    removeCircleAura()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 3)
    if not humanoidRootPart then return end
    local auraBase = Instance.new("Part")
    auraBase.Size, auraBase.Transparency, auraBase.Anchored, auraBase.CanCollide, auraBase.Name, auraBase.Parent = Vector3.new(1, 1, 1), 1, true, false, "CircleAuraBase", S.WS
    auraBase.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.new(0, -0.15, 0)
    local positionUpdateConnection
    positionUpdateConnection = HRT:Connect(function()
        if humanoidRootPart and humanoidRootPart.Parent and auraBase and auraBase.Parent then
            auraBase.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.new(0, -0.15, 0)
        else
            if positionUpdateConnection then positionUpdateConnection:Disconnect() end
        end
    end)
    auraBase.AncestryChanged:Connect(function() if not auraBase.Parent and positionUpdateConnection then positionUpdateConnection:Disconnect() end end)

    local mainAttachment = Instance.new("Attachment")
    mainAttachment.Name, mainAttachment.Position, mainAttachment.Parent = "Main", Vector3.new(0, -2.75, 0), auraBase
    local circleEmitter = Instance.new("ParticleEmitter")
    circleEmitter.Name, circleEmitter.Texture, circleEmitter.Lifetime, circleEmitter.Rate, circleEmitter.RotSpeed, circleEmitter.Speed = "Circle", CircleAuraSettings.circleTexture, NumberRange.new(9), 0.333, NumberRange.new(120), NumberRange.new(0.001)
    circleEmitter.Size, circleEmitter.Transparency, circleEmitter.Color, circleEmitter.LightEmission, circleEmitter.ZOffset, circleEmitter.Orientation, circleEmitter.LockedToPart, circleEmitter.Parent = NumberSequence.new({NumberSequenceKeypoint.new(0, 3), NumberSequenceKeypoint.new(1, 3)}), NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1, 0), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(0.6256, 0.0875), NumberSequenceKeypoint.new(0.7691, 0.3875), NumberSequenceKeypoint.new(0.8677, 0.7125), NumberSequenceKeypoint.new(0.9230, 0.875), NumberSequenceKeypoint.new(0.9552, 0.9375), NumberSequenceKeypoint.new(1, 0.975)}), ColorSequence.new({ColorSequenceKeypoint.new(0, CircleAuraSettings.circleColor), ColorSequenceKeypoint.new(1, CircleAuraSettings.circleColor)}), CircleAuraSettings.lightEmission, 0.05, Enum.ParticleOrientation.VelocityPerpendicular, true, mainAttachment

    local attachOne, attachTwo = Instance.new("Attachment"), Instance.new("Attachment")
    attachOne.Name, attachOne.Position, attachOne.Parent = "One", Vector3.new(0, -2.8, 2.6), auraBase
    attachTwo.Name, attachTwo.Position, attachTwo.Parent = "Two", Vector3.new(0, -2.8, -2.6), auraBase
    local beamOne = Instance.new("Beam")
    beamOne.Name, beamOne.Texture, beamOne.TextureSpeed, beamOne.TextureLength, beamOne.Width0, beamOne.Width1, beamOne.CurveSize0, beamOne.CurveSize1, beamOne.Segments, beamOne.LightEmission, beamOne.Transparency, beamOne.Color, beamOne.Attachment0, beamOne.Attachment1, beamOne.Parent = "One", "rbxassetid://8920073892", -0.3, 0.5, 4, 4, -3.5, 3.5, 25, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0.3)}), ColorSequence.new(CircleAuraSettings.beamColor), attachOne, attachTwo, auraBase
    local beamTwo = Instance.new("Beam")
    beamTwo.Name, beamTwo.Texture, beamTwo.TextureSpeed, beamTwo.TextureLength, beamTwo.Width0, beamTwo.Width1, beamTwo.CurveSize0, beamTwo.CurveSize1, beamTwo.Segments, beamTwo.LightEmission, beamTwo.Transparency, beamTwo.Color, beamTwo.Attachment0, beamTwo.Attachment1, beamTwo.Parent = "Two", "rbxassetid://8920073892", 0.3, 0.5, 4, 4, 3.5, -3.5, 25, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0.3)}), ColorSequence.new(CircleAuraSettings.beamColor), attachOne, attachTwo, auraBase

    local attachThree, attachFour = Instance.new("Attachment"), Instance.new("Attachment")
    attachThree.Name, attachThree.Position, attachThree.Parent = "Three", Vector3.new(0, -2.7, 0), auraBase
    attachFour.Name, attachFour.Position, attachFour.Parent = "Four", Vector3.new(0, 6, 0), auraBase
    local beamThree = Instance.new("Beam")
    beamThree.Name, beamThree.Texture, beamThree.TextureSpeed, beamThree.TextureLength, beamThree.Width0, beamThree.Width1, beamThree.Segments, beamThree.LightEmission, beamThree.Transparency, beamThree.Color, beamThree.FaceCamera, beamThree.Attachment0, beamThree.Attachment1, beamThree.Parent = "Three", "rbxassetid://9020147050", 0.3, 0.1, 5, 6, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1, 1), NumberSequenceKeypoint.new(0.4, 0.4), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase
    local beamFour = Instance.new("Beam")
    beamFour.Name, beamFour.Texture, beamFour.TextureSpeed, beamFour.TextureLength, beamFour.Width0, beamFour.Width1, beamFour.Segments, beamFour.LightEmission, beamFour.Transparency, beamFour.Color, beamFour.FaceCamera, beamFour.Attachment0, beamFour.Attachment1, beamFour.Parent = "Four", "rbxassetid://8984452855", 0.06, 0.4, 5, 6, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase
    local beamFive = Instance.new("Beam")
    beamFive.Name, beamFive.Texture, beamFive.TextureSpeed, beamFive.TextureLength, beamFive.Width0, beamFive.Width1, beamFive.Segments, beamFive.LightEmission, beamFive.Transparency, beamFive.Color, beamFive.FaceCamera, beamFive.Attachment0, beamFive.Attachment1, beamFive.Parent = "Five", "http://www.roblox.com/asset/?id=4390493166", 0.2, 0.15, 4, 4, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase

    currentCircleAura = auraBase
end

local function applyCircleAura()
    local character = LP.Character
    if not character then
        local circleAuraConnection
        if circleAuraConnection then circleAuraConnection:Disconnect() end
        circleAuraConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if CircleAuraSettings.enabled then createCircleAura(newCharacter) end
        end)
        return
    end
    createCircleAura(character)
    if not circleAuraConnection then
        local circleAuraConnection
        circleAuraConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if CircleAuraSettings.enabled then createCircleAura(newCharacter) end
        end)
    end
end

getgenv().GetCircleAuraSettings = function() return CircleAuraSettings end

-- UI
addToggleWithNotify(SphereAuraGroup, 'CircleAura', {
    Text = 'Aura',
    Default = false,
    Callback = function(v)
        CircleAuraSettings.enabled = v
        if v then
            applyCircleAura()
        else
            removeCircleAura()
        end
    end
}):AddColorPicker('CircleAuraBeamColor', {
    Default = CircleAuraSettings.beamColor,
    Title = 'Color',
    Transparency = 0,
    Callback = function(val)
        CircleAuraSettings.beamColor = val
        updateCircleAura('beamColor')
    end
})

local CircleAuraSub = SphereAuraGroup:AddDependencyBox()
CircleAuraSub:AddSlider('CircleAuraLightEmission', {
    Text = 'Emission',
    Default = CircleAuraSettings.lightEmission,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Callback = function(val)
        CircleAuraSettings.lightEmission = val
        updateCircleAura('lightEmission')
    end
})
CircleAuraSub:AddDropdown('CircleAuraCircleTexture', {
    Text = 'CircleTexture',
    Values = {
        '8920246243',
        '10365549270',
        '5726444189',
        '1266170131',
        '12363692255',
        '12363692920',
    },
    Default = '8920246243',
    Callback = function(val)
        CircleAuraSettings.circleTexture = 'rbxassetid://' .. val
        updateCircleAura('circleTexture')
    end
})
CircleAuraSub:SetupDependencies({{Toggles.CircleAura, true}})

-- ChinaHat UI и логика
local ChinaHatSettings = {
    enabled = false,
    minCameraDistance = 1,
    hatTransparency = 0.35,
    circleTransparency = 1,
    height = 0.75,
    radius = 5,
    sides = 25,
    rainbow = false,
    color = Color3.fromRGB(255, 255, 255),
    offset = Vector3.new(0, 0.75, 0)
}

local ChinaHatGroup = Tabs.Visuals:AddLeftGroupbox('>_<')
addToggleWithNotify(ChinaHatGroup, 'ChinaHatEnabled', {
    Text = 'ChinaHat',
    Default = ChinaHatSettings.enabled,
    Callback = function(v)
        ChinaHatSettings.enabled = v
    end
})
ChinaHatGroup:AddSlider('ChinaHatHeight', {
    Text = 'Height',
    Default = ChinaHatSettings.height,
    Min = 0.1,
    Max = 3,
    Rounding = 2,
    Callback = function(val)
        ChinaHatSettings.height = val
    end
})
ChinaHatGroup:AddSlider('ChinaHatRadius', {
    Text = 'Radius',
    Default = ChinaHatSettings.radius,
    Min = 1,
    Max = 10,
    Rounding = 2,
    Callback = function(val)
        ChinaHatSettings.radius = val
    end
})
ChinaHatGroup:AddToggle('ChinaHatRainbow', {
    Text = 'Rainbow',
    Default = ChinaHatSettings.rainbow,
    Callback = function(v)
        ChinaHatSettings.rainbow = v
    end
}):AddColorPicker('ChinaHatColor', {
    Default = ChinaHatSettings.color,
    Title = 'Color',
    Transparency = 0,
    Callback = function(val)
        ChinaHatSettings.color = val
    end
})

-- ChinaHat rendering logic
local ChinaHatDrawings = {}
local tau = M.rad(360) -- или просто 2*math.pi
for i = 1, ChinaHatSettings.sides do
    ChinaHatDrawings[i] = {Drawing.new('Line'), Drawing.new('Triangle')}
    ChinaHatDrawings[i][1].ZIndex = 2
    ChinaHatDrawings[i][1].Thickness = 2
    ChinaHatDrawings[i][2].ZIndex = 1
    ChinaHatDrawings[i][2].Filled = true
end

RND:Connect(function()
    local pass = ChinaHatSettings.enabled and LP.Character and LP.Character:FindFirstChild('Head') and (Cam.CFrame.p - Cam.Focus.p).magnitude > ChinaHatSettings.minCameraDistance and LP.Character:FindFirstChildOfClass('Humanoid') and LP.Character:FindFirstChildOfClass('Humanoid').Health > 0
    for i = 1, #ChinaHatDrawings do
        local line, triangle = ChinaHatDrawings[i][1], ChinaHatDrawings[i][2]
        if pass then
            local color = ChinaHatSettings.rainbow and Color3.fromHSV((tick() % 5 / 5 - (i / #ChinaHatDrawings)) % 1, 0.5, 1) or ChinaHatSettings.color
            local pos = LP.Character.Head.Position + ChinaHatSettings.offset
            local topWorld = pos + Vector3.new(0, ChinaHatSettings.height, 0)
            local last, next = (i / ChinaHatSettings.sides) * tau, ((i + 1) / ChinaHatSettings.sides) * tau
            local lastWorld = pos + (Vector3.new(M.cos(last), 0, M.sin(last)) * ChinaHatSettings.radius)
            local nextWorld = pos + (Vector3.new(M.cos(next), 0, M.sin(next)) * ChinaHatSettings.radius)
            local lastScreen = Cam:WorldToViewportPoint(lastWorld)
            local nextScreen = Cam:WorldToViewportPoint(nextWorld)
            local topScreen = Cam:WorldToViewportPoint(topWorld)
            line.From = Vector2.new(lastScreen.X, lastScreen.Y)
            line.To = Vector2.new(nextScreen.X, nextScreen.Y)
            line.Color = color
            line.Transparency = ChinaHatSettings.circleTransparency
            line.Visible = true
            triangle.PointA = Vector2.new(topScreen.X, topScreen.Y)
            triangle.PointB = line.From
            triangle.PointC = line.To
            triangle.Color = color
            triangle.Transparency = ChinaHatSettings.hatTransparency
            triangle.Visible = true
        else
            line.Visible = false
            triangle.Visible = false
        end
    end
end)

-- === World Controller UI (LEFT) ===
local WorldGroup = Tabs.Visuals:AddLeftGroupbox('>_<')

local Lighting = S.LS
local function ensureCC()
    local cc = Lighting:FindFirstChildOfClass('ColorCorrectionEffect')
    if not cc then
        cc = Instance.new('ColorCorrectionEffect')
        cc.Parent = Lighting
        cc.Enabled = true
    end
    return cc
end
local cc = ensureCC()

local WorldConfig = {
    FogEnabled = false,
    FogColor = Color3.new(1,1,1),
    FogStart = Lighting.FogStart or 0,
    FogEnd = Lighting.FogEnd or 100,
    Shadows = false,
    ShadowColor = Lighting.ShadowColor or Color3.new(0,0,0),
    Time = Lighting.ClockTime or 12,
    Saturation = cc.Saturation or 0,
    Brightness = cc.Brightness or 0,
    AmbientEnabled = false,
    AmbientColor = Lighting.Ambient or Color3.new(0.5, 0.5, 0.5)
}

local function applyWorld()
    if WorldConfig.FogEnabled then
        Lighting.FogStart = WorldConfig.FogStart
        Lighting.FogEnd = WorldConfig.FogEnd
        Lighting.FogColor = WorldConfig.FogColor
    else
        Lighting.FogStart = 1e6
        Lighting.FogEnd = 1e6
        -- Не трогаем Lighting.FogColor
    end
    
    -- Применяем настройки Ambient
    if WorldConfig.AmbientEnabled then
        Lighting.Ambient = WorldConfig.AmbientColor
    else
        Lighting.Ambient = Color3.new(0.5, 0.5, 0.5) -- Стандартное значение
    end
    
    Lighting.GlobalShadows = WorldConfig.Shadows
    Lighting.ShadowColor = WorldConfig.ShadowColor
    Lighting.ClockTime = WorldConfig.Time
    local cc = ensureCC()
    cc.Saturation = WorldConfig.Saturation
    cc.Brightness = WorldConfig.Brightness
end

-- Добавляем постоянное обновление настроек мира
getgenv().worldUpdateConnection = nil
local function startWorldUpdates()
    if getgenv().worldUpdateConnection then getgenv().worldUpdateConnection:Disconnect() end
    getgenv().worldUpdateConnection = HRT:Connect(function()
        -- Применяем настройки мира каждый кадр для предотвращения сброса игрой
        if WorldConfig.FogEnabled then
            Lighting.FogStart = WorldConfig.FogStart
            Lighting.FogEnd = WorldConfig.FogEnd
            Lighting.FogColor = WorldConfig.FogColor
        end
        
        -- Обновляем Ambient
        if WorldConfig.AmbientEnabled then
            Lighting.Ambient = WorldConfig.AmbientColor
        else
            Lighting.Ambient = Color3.new(0.5, 0.5, 0.5) -- Стандартное значение
        end
        
        Lighting.GlobalShadows = WorldConfig.Shadows
        Lighting.ShadowColor = WorldConfig.ShadowColor
        Lighting.ClockTime = WorldConfig.Time
        local cc = ensureCC()
        cc.Saturation = WorldConfig.Saturation
        cc.Brightness = WorldConfig.Brightness
    end)
end

-- Запускаем обновление при загрузке скрипта
startWorldUpdates()

local FogToggle = addToggleWithNotify(WorldGroup, 'FogEnabled', {
    Text = 'Fog',
    Default = false,
    Callback = function(v) 
        WorldConfig.FogEnabled = v
        applyWorld()
        -- Перезапускаем обновление мира при изменении настроек
        if getgenv().worldUpdateConnection then
            getgenv().worldUpdateConnection:Disconnect()
            getgenv().worldUpdateConnection = nil
        end
        startWorldUpdates()
    end
})
FogToggle:AddColorPicker('FogColor', {
    Default = Color3.new(1,1,1),
    Title = 'Col',
    Callback = function(val) WorldConfig.FogColor = val; applyWorld() end
})
WorldGroup:AddSlider('FogStart', {
    Text = 'FStart',
    Default = WorldConfig.FogStart,
    Min = 0, Max = 10000, Rounding = 1,
    Callback = function(val) WorldConfig.FogStart = val; applyWorld() end
})
WorldGroup:AddSlider('FogEnd', {
    Text = 'FEnd',
    Default = WorldConfig.FogEnd,
    Min = 0, Max = 10000, Rounding = 1,
    Callback = function(val) WorldConfig.FogEnd = val; applyWorld() end
})
local ShadowsToggle = WorldGroup:AddToggle('Shadows', {
    Text = 'Shadows',
    Default = false,
    Callback = function(v) 
        WorldConfig.Shadows = v
        applyWorld()
        -- Перезапускаем обновление мира при изменении теней
        if getgenv().worldUpdateConnection then
            getgenv().worldUpdateConnection:Disconnect()
            getgenv().worldUpdateConnection = nil
        end
        startWorldUpdates()
    end
})
WorldGroup:AddSlider('Time', {
    Text = 'Time',
    Default = WorldConfig.Time,
    Min = 0, Max = 24, Rounding = 1,
    Callback = function(val) 
        WorldConfig.Time = val
        applyWorld()
        -- Перезапускаем обновление мира при изменении времени
        if getgenv().worldUpdateConnection then
            getgenv().worldUpdateConnection:Disconnect()
            getgenv().worldUpdateConnection = nil
        end
        startWorldUpdates()
    end
})
WorldGroup:AddSlider('Saturation', {
    Text = 'Sat',
    Default = WorldConfig.Saturation,
    Min = -1, Max = 1, Rounding = 1,
    Callback = function(val) WorldConfig.Saturation = val; applyWorld() end
})
WorldGroup:AddSlider('Brightness', {
    Text = 'Brt',
    Default = WorldConfig.Brightness,
    Min = -1, Max = 1, Rounding = 1,
    Callback = function(val) WorldConfig.Brightness = val; applyWorld() end
})

-- Добавляем тогл для Ambient
local AmbientToggle = addToggleWithNotify(WorldGroup, 'AmbientEnabled', {
    Text = 'Ambient',
    Default = false,
    Callback = function(v) 
        WorldConfig.AmbientEnabled = v
        applyWorld()
        -- Перезапускаем обновление мира при изменении настроек
        if getgenv().worldUpdateConnection then
            getgenv().worldUpdateConnection:Disconnect()
            getgenv().worldUpdateConnection = nil
        end
        startWorldUpdates()
    end
})

-- Добавляем колорпикер для Ambient
AmbientToggle:AddColorPicker('AmbientColor', {
    Default = Color3.new(0.5, 0.5, 0.5),
    Title = 'Col',
    Callback = function(val) WorldConfig.AmbientColor = val; applyWorld() end
})

-- === LightingType Controller (RIGHT) ===
local LightingTypeGroup = Tabs.Visuals:AddRightGroupbox('>_<')
local LightingTypeList = {"Voxel", "ShadowMap", "Future"}
local LightingTypeEnum = {
    Voxel = Enum.Technology.Voxel,
    ShadowMap = Enum.Technology.ShadowMap,
    Future = Enum.Technology.Future
}
LightingTypeGroup:AddDropdown('LightingType', {
    Text = 'LightingType',
    Values = LightingTypeList,
    Default = 'Voxel',
    Callback = function(val)
        local tech = LightingTypeEnum[val]
        if tech then
            S.LS.Technology = tech
        end
    end
})
-- При запуске выставить первый режим
S.LS.Technology = LightingTypeEnum[LightingTypeList[1]]

-- === SelfChams (Visuals tab, новая секция) ===
getgenv().SelfChamsGroup = Tabs.Visuals:AddLeftGroupbox('>_<')

-- Делаем конфигурацию глобальной для уменьшения количества локальных переменных
getgenv().SelfChamsConfig = {
    Enabled = false,
    Color = Color3.fromRGB(0, 170, 255), -- голубой по умолчанию
    OriginalMaterials = {}, -- для хранения оригинальных материалов
    OriginalColors = {} -- для хранения оригинальных цветов
}

-- Функция для применения SelfChams
getgenv().applySelfChams = function()
    if not Char then return end
    
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = getgenv().SelfChamsConfig
        local forceField = Enum.Material.ForceField
        local color = config.Color
        
        -- Сохраняем и изменяем материал для всех частей тела
        for _, part in pairs(Char:GetChildren()) do
            if part and part:IsA("BasePart") then
                -- Сохраняем оригинальный материал и цвет, если еще не сохранены
                if not config.OriginalMaterials[part] then
                    config.OriginalMaterials[part] = part.Material
                    config.OriginalColors[part] = part.Color
                end
                
                -- Применяем новый материал и цвет
                part.Material = forceField
                part.Color = color
            end
            
            -- Обрабатываем аксессуары
            if part and part:IsA("Accessory") then
                local handle = part:FindFirstChild("Handle")
                if handle then
                    if not config.OriginalMaterials[handle] then
                        config.OriginalMaterials[handle] = handle.Material
                        config.OriginalColors[handle] = handle.Color
                    end
                    
                    handle.Material = forceField
                    handle.Color = color
                end
            end
        end
    end)
end

-- Функция для отключения SelfChams
getgenv().removeSelfChams = function()
    if not Char then return end
    
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = getgenv().SelfChamsConfig
        
        -- Восстанавливаем оригинальные материалы и цвета
        for part, material in pairs(config.OriginalMaterials) do
            if part and part:IsDescendantOf(game) then
                pcall(function()
                    part.Material = material
                    
                    -- Восстанавливаем оригинальный цвет, если он был сохранен
                    if config.OriginalColors[part] then
                        part.Color = config.OriginalColors[part]
                    end
                end)
            end
        end
        
        -- Очищаем сохраненные материалы и цвета
        config.OriginalMaterials = {}
        config.OriginalColors = {}
        
        -- Принудительно запускаем сборщик мусора с правильным синтаксисом
        gcinfo()
    end)
end

-- Функция для обновления при смене персонажа
getgenv().updateSelfChamsOnCharacterChange = function(char)
    -- Обновляем глобальную ссылку на персонажа
    Char = char
    
    -- Обновляем части тела
    Body = {
        Hum = Char:FindFirstChildOfClass('Humanoid'),
        HRP = Char:FindFirstChild('HumanoidRootPart'),
        Head = Char:FindFirstChild('Head'),
        Tor = Char:FindFirstChild('Torso') or Char:FindFirstChild('UpperTorso'),
        LA = Char:FindFirstChild('Left Arm') or Char:FindFirstChild('LeftUpperArm'),
        RA = Char:FindFirstChild('Right Arm') or Char:FindFirstChild('RightUpperArm'),
        LL = Char:FindFirstChild('Left Leg') or Char:FindFirstChild('LeftUpperLeg'),
        RL = Char:FindFirstChild('Right Leg') or Char:FindFirstChild('RightUpperLeg'),
    }
    
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = getgenv().SelfChamsConfig
        
        -- Очищаем старые сохраненные материалы и цвета
        config.OriginalMaterials = {}
        config.OriginalColors = {}
        
        -- Если включено, применяем к новому персонажу
        if config.Enabled then
            -- Небольшая задержка, чтобы персонаж полностью загрузился
            task.wait(0.5)
            getgenv().applySelfChams()
        end
    end)
end

-- Сохраняем соединение в глобальной переменной для возможности отключения
if getgenv().selfChamsCharacterConnection then
    getgenv().selfChamsCharacterConnection:Disconnect()
    getgenv().selfChamsCharacterConnection = nil
end
getgenv().selfChamsCharacterConnection = LP.CharacterAdded:Connect(getgenv().updateSelfChamsOnCharacterChange)

-- UI для SelfChams
getgenv().SelfChamsToggle = addToggleWithNotify(getgenv().SelfChamsGroup, 'SelfChamsEnabled', {
    Text = 'SelfChams',
    Default = getgenv().SelfChamsConfig.Enabled,
    Callback = function(v)
        getgenv().SelfChamsConfig.Enabled = v
        
        if v then
            getgenv().applySelfChams()
        else
            getgenv().removeSelfChams()
        end
    end
})

-- Добавляем колорпикер для SelfChams
getgenv().SelfChamsToggle:AddColorPicker('SelfChamsColor', {
    Default = getgenv().SelfChamsConfig.Color,
    Title = 'Color',
    Transparency = 0,
    Callback = function(val)
        getgenv().SelfChamsConfig.Color = val
        
        -- Если включено, сразу применяем новый цвет
        if getgenv().SelfChamsConfig.Enabled then
            for part, _ in pairs(getgenv().SelfChamsConfig.OriginalMaterials) do
                if part and part:IsDescendantOf(game) then
                    part.Color = val
                end
            end
        end
    end
})

-- === SelfHighlight (в той же секции) ===
-- Делаем конфигурацию глобальной для уменьшения количества локальных переменных
getgenv().SelfHighlightConfig = {
    Enabled = false,
    FillColor = Color3.fromRGB(0, 170, 255), -- голубой по умолчанию
    OutlineColor = Color3.fromRGB(255, 255, 255), -- белый по умолчанию
    FillTransparency = 0.5, -- полупрозрачный
    OutlineTransparency = 0, -- непрозрачный
    HighlightInstance = nil -- для хранения экземпляра Highlight
}

-- Функция для применения SelfHighlight
getgenv().applySelfHighlight = function()
    if not Char then return end
    
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = getgenv().SelfHighlightConfig
        local highlight = config.HighlightInstance
        
        -- Если Highlight уже существует, просто обновим его настройки вместо пересоздания
        if highlight and highlight.Parent and highlight.Parent:IsDescendantOf(game) then
            -- Обновляем настройки существующего Highlight
            highlight.FillColor = config.FillColor
            highlight.OutlineColor = config.OutlineColor
            highlight.FillTransparency = config.FillTransparency
            highlight.OutlineTransparency = config.OutlineTransparency
            
            -- Если Adornee изменился (новый персонаж), обновляем его
            if highlight.Adornee ~= Char then
                highlight.Adornee = Char
            end
        else
            -- Удаляем старый Highlight, если он существует
            if highlight then
                highlight:Destroy()
                config.HighlightInstance = nil
            end
            
            -- Создаем новый Highlight
            local newHighlight = Instance.new("Highlight")
            newHighlight.Name = "SelfHighlight"
            newHighlight.FillColor = config.FillColor
            newHighlight.OutlineColor = config.OutlineColor
            newHighlight.FillTransparency = config.FillTransparency
            newHighlight.OutlineTransparency = config.OutlineTransparency
            newHighlight.Adornee = Char
            newHighlight.Parent = Char
            
            -- Сохраняем экземпляр
            config.HighlightInstance = newHighlight
        end
    end)
end

-- Функция для отключения SelfHighlight
getgenv().removeSelfHighlight = function()
    -- Используем pcall для безопасного выполнения
    pcall(function()
        local config = getgenv().SelfHighlightConfig
        if config.HighlightInstance then
            config.HighlightInstance:Destroy()
            config.HighlightInstance = nil
        end
        
        -- Принудительно запускаем сборщик мусора с правильным синтаксисом
        gcinfo()
    end)
end

-- Функция для обновления при смене персонажа
getgenv().updateSelfHighlightOnCharacterChange = function(char)
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = getgenv().SelfHighlightConfig
        
        -- Если включено, применяем к новому персонажу
        if config.Enabled then
            -- Небольшая задержка, чтобы персонаж полностью загрузился
            task.wait(0.5)
            getgenv().applySelfHighlight()
        end
    end)
end

-- Сохраняем соединение в глобальной переменной для возможности отключения
if getgenv().selfHighlightCharacterConnection then
    getgenv().selfHighlightCharacterConnection:Disconnect()
    getgenv().selfHighlightCharacterConnection = nil
end
getgenv().selfHighlightCharacterConnection = LP.CharacterAdded:Connect(getgenv().updateSelfHighlightOnCharacterChange)

-- UI для SelfHighlight
getgenv().SelfHighlightToggle = addToggleWithNotify(getgenv().SelfChamsGroup, 'SelfHighlightEnabled', {
    Text = 'SelfHighlight',
    Default = getgenv().SelfHighlightConfig.Enabled,
    Callback = function(v)
        getgenv().SelfHighlightConfig.Enabled = v
        
        if v then
            getgenv().applySelfHighlight()
        else
            getgenv().removeSelfHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета заливки
getgenv().SelfHighlightToggle:AddColorPicker('SelfHighlightFillColor', {
    Default = getgenv().SelfHighlightConfig.FillColor,
    Title = 'Fill',
    Transparency = 0,
    Callback = function(val)
        getgenv().SelfHighlightConfig.FillColor = val
        
        -- Если включено, сразу применяем новый цвет
        if getgenv().SelfHighlightConfig.Enabled and getgenv().SelfHighlightConfig.HighlightInstance then
            getgenv().SelfHighlightConfig.HighlightInstance.FillColor = val
        end
    end
})

-- Добавляем колорпикер для цвета контура
getgenv().SelfHighlightToggle:AddColorPicker('SelfHighlightOutlineColor', {
    Default = getgenv().SelfHighlightConfig.OutlineColor,
    Title = 'Outline',
    Transparency = 0,
    Callback = function(val)
        getgenv().SelfHighlightConfig.OutlineColor = val
        
        -- Если включено, сразу применяем новый цвет
        if getgenv().SelfHighlightConfig.Enabled and getgenv().SelfHighlightConfig.HighlightInstance then
            getgenv().SelfHighlightConfig.HighlightInstance.OutlineColor = val
        end
    end
})

-- Создаем зависимые элементы для настройки прозрачности
getgenv().SelfHighlightDependency = getgenv().SelfChamsGroup:AddDependencyBox()

-- Слайдер для прозрачности заливки
getgenv().SelfHighlightDependency:AddSlider('SelfHighlightFillTransparency', {
    Text = 'Fill Trans',
    Default = getgenv().SelfHighlightConfig.FillTransparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(val)
        getgenv().SelfHighlightConfig.FillTransparency = val
        
        -- Если включено, сразу применяем новую прозрачность
        if getgenv().SelfHighlightConfig.Enabled and getgenv().SelfHighlightConfig.HighlightInstance then
            getgenv().SelfHighlightConfig.HighlightInstance.FillTransparency = val
        end
    end
})

-- Слайдер для прозрачности контура
getgenv().SelfHighlightDependency:AddSlider('SelfHighlightOutlineTransparency', {
    Text = 'Outline Trans',
    Default = getgenv().SelfHighlightConfig.OutlineTransparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(val)
        getgenv().SelfHighlightConfig.OutlineTransparency = val
        
        -- Если включено, сразу применяем новую прозрачность
        if getgenv().SelfHighlightConfig.Enabled and getgenv().SelfHighlightConfig.HighlightInstance then
            getgenv().SelfHighlightConfig.HighlightInstance.OutlineTransparency = val
        end
    end
})

-- Устанавливаем зависимость от тогла SelfHighlight
getgenv().SelfHighlightDependency:SetupDependencies({{Toggles.SelfHighlightEnabled, true}})

-- === SelfTransparency (в той же секции) ===
-- Делаем конфигурацию глобальной
getgenv().SelfTransparencyConfig = {
    Enabled = false,
    Transparency = 0.5, -- Значение от 0 до 1
    OriginalTransparency = {}, -- Для хранения оригинальных значений прозрачности
}

-- Функция для применения прозрачности
getgenv().applySelfTransparency = function()
    if not Char then return end
    
    pcall(function()
        local config = getgenv().SelfTransparencyConfig
        
        -- Обрабатываем основные части тела R15
        local r15BodyParts = {
            "Head", 
            "UpperTorso", "LowerTorso", 
            "LeftUpperArm", "LeftLowerArm", "LeftHand",
            "RightUpperArm", "RightLowerArm", "RightHand",
            "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
            "RightUpperLeg", "RightLowerLeg", "RightFoot"
        }
        
        -- Обрабатываем основные части тела R6
        local r6BodyParts = {
            "Head", "Torso", 
            "Left Arm", "Right Arm", 
            "Left Leg", "Right Leg"
        }
        
        -- Применяем к частям тела
        for _, part in ipairs(Char:GetChildren()) do
            if part:IsA("BasePart") and 
               (table.find(r15BodyParts, part.Name) or table.find(r6BodyParts, part.Name)) and 
               part.Name ~= "HumanoidRootPart" then
                
                -- Сохраняем оригинальное значение прозрачности, если еще не сохранено
                if not config.OriginalTransparency[part] then
                    config.OriginalTransparency[part] = part.Transparency
                end
                
                -- Применяем новую прозрачность
                part.Transparency = config.Transparency
            end
            
            -- Обрабатываем аксессуары
            if part:IsA("Accessory") then
                local handle = part:FindFirstChild("Handle")
                if handle then
                    if not config.OriginalTransparency[handle] then
                        config.OriginalTransparency[handle] = handle.Transparency
                    end
                    
                    handle.Transparency = config.Transparency
                end
            end
        end
    end)
end

-- Функция для отключения прозрачности
getgenv().removeSelfTransparency = function()
    if not Char then return end
    
    pcall(function()
        local config = getgenv().SelfTransparencyConfig
        
        -- Восстанавливаем оригинальные значения прозрачности
        for part, transparency in pairs(config.OriginalTransparency) do
            if part and part:IsDescendantOf(game) then
                pcall(function()
                    part.Transparency = transparency
                end)
            end
        end
        
        -- Очищаем сохраненные значения прозрачности
        config.OriginalTransparency = {}
    end)
end

-- Функция для обновления при смене персонажа
getgenv().updateSelfTransparencyOnCharacterChange = function(char)
    -- Обновляем глобальную ссылку на персонажа
    Char = char
    
    -- Обновляем части тела
    Body = {
        Hum = Char:FindFirstChildOfClass('Humanoid'),
        HRP = Char:FindFirstChild('HumanoidRootPart'),
        Head = Char:FindFirstChild('Head'),
        Tor = Char:FindFirstChild('Torso') or Char:FindFirstChild('UpperTorso'),
        LA = Char:FindFirstChild('Left Arm') or Char:FindFirstChild('LeftUpperArm'),
        RA = Char:FindFirstChild('Right Arm') or Char:FindFirstChild('RightUpperArm'),
        LL = Char:FindFirstChild('Left Leg') or Char:FindFirstChild('LeftUpperLeg'),
        RL = Char:FindFirstChild('Right Leg') or Char:FindFirstChild('RightUpperLeg'),
    }
    
    pcall(function()
        local config = getgenv().SelfTransparencyConfig
        
        -- Очищаем старые сохраненные значения прозрачности
        config.OriginalTransparency = {}
        
        if config.Enabled then
            -- Небольшая задержка, чтобы персонаж полностью загрузился
            task.wait(0.5)
            getgenv().applySelfTransparency()
        end
    end)
end

-- Сохраняем соединение для возможности отключения
if getgenv().selfTransparencyCharacterConnection then
    getgenv().selfTransparencyCharacterConnection:Disconnect()
    getgenv().selfTransparencyCharacterConnection = nil
end
getgenv().selfTransparencyCharacterConnection = LP.CharacterAdded:Connect(getgenv().updateSelfTransparencyOnCharacterChange)

-- UI для SelfTransparency
getgenv().SelfTransparencyToggle = addToggleWithNotify(getgenv().SelfChamsGroup, 'SelfTransparencyEnabled', {
    Text = 'SelfTransparency',
    Default = getgenv().SelfTransparencyConfig.Enabled,
    Callback = function(v)
        getgenv().SelfTransparencyConfig.Enabled = v
        
        if v then
            getgenv().applySelfTransparency()
        else
            getgenv().removeSelfTransparency()
        end
    end,
    Tooltip = '>_<'
})

-- Создаем зависимый слайдер для настройки прозрачности
getgenv().SelfTransparencyDependency = getgenv().SelfChamsGroup:AddDependencyBox()

getgenv().SelfTransparencyDependency:AddSlider('SelfTransparencyValue', {
    Text = 'Transparency',
    Default = getgenv().SelfTransparencyConfig.Transparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(val)
        getgenv().SelfTransparencyConfig.Transparency = val
        
        if getgenv().SelfTransparencyConfig.Enabled then
            getgenv().applySelfTransparency()
        end
    end
})

-- Устанавливаем зависимость от тогла SelfTransparency
getgenv().SelfTransparencyDependency:SetupDependencies({{Toggles.SelfTransparencyEnabled, true}})

-- Функция для очистки всех ресурсов и соединений
getgenv().cleanupVisualEffects = function()
    -- Отключаем SelfChams если включен
    if getgenv().SelfChamsConfig and getgenv().SelfChamsConfig.Enabled then
        getgenv().removeSelfChams()
    end
    
    -- Отключаем SelfHighlight если включен
    if getgenv().SelfHighlightConfig and getgenv().SelfHighlightConfig.Enabled then
        getgenv().removeSelfHighlight()
    end
    
    -- Отключаем SelfTransparency если включен
    if getgenv().SelfTransparencyConfig and getgenv().SelfTransparencyConfig.Enabled then
        getgenv().removeSelfTransparency()
    end
    
    -- Функция для безопасного отключения соединений
    local function safeDisconnect(conn)
        if conn then
            conn:Disconnect()
            return nil
        end
        return nil
    end
    
    -- Отключаем соединения
    getgenv().selfChamsCharacterConnection = safeDisconnect(getgenv().selfChamsCharacterConnection)
    getgenv().selfHighlightCharacterConnection = safeDisconnect(getgenv().selfHighlightCharacterConnection)
    getgenv().selfTransparencyCharacterConnection = safeDisconnect(getgenv().selfTransparencyCharacterConnection)
    getgenv().InvisDesyncConnection = safeDisconnect(getgenv().InvisDesyncConnection)
    getgenv().InvisDesyncRespawnConnection = safeDisconnect(getgenv().InvisDesyncRespawnConnection)
    getgenv().memoryCleanupTimer = safeDisconnect(getgenv().memoryCleanupTimer)
    
    -- Отключаем InvisDesync если включен
    if getgenv().InvisDesyncConfig and getgenv().InvisDesyncConfig.Enabled then
        -- Вызываем функцию отключения, которая сбросит NetworkIsSleeping
        getgenv().toggleInvisDesync(false)
    end
    
    -- Принудительно запускаем сборщик мусора с правильным синтаксисом
    gcinfo()
end

-- Периодическая очистка памяти для предотвращения утечек
if getgenv().memoryCleanupTimer then
    getgenv().memoryCleanupTimer:Disconnect()
    getgenv().memoryCleanupTimer = nil
end

getgenv().memoryCleanupTimer = HRT:Connect(function()
    -- Запускаем очистку каждые 30 секунд
    if not getgenv().lastMemoryCleanup or tick() - getgenv().lastMemoryCleanup >= 30 then
        getgenv().lastMemoryCleanup = tick()
        gcinfo()
    end
end)

-- Добавляем функцию очистки при выходе из игры
S.PS.PlayerRemoving:Connect(function(player)
    if player == LP then
        getgenv().cleanupVisualEffects()
    end
end)

-- === Speedhack (Player tab, right) ===
local SpeedhackGroup = Tabs.Player:AddRightGroupbox('>_<')
local SpeedhackConfig = {
    Enabled = false, -- toggle
    Active = false,  -- keybind
    Speed = 50
}
local speedHackConnection
local function updateSpeedHack(character)
    if not character then return end
    local rootPart = character:WaitForChild('HumanoidRootPart')
    local humanoid = character:WaitForChild('Humanoid')
    if speedHackConnection then speedHackConnection:Disconnect() end
    speedHackConnection = HRT:Connect(function(dt)
        if SpeedhackConfig.Enabled and SpeedhackConfig.Active then
            local move = humanoid.MoveDirection
            if move.Magnitude > 0 then
                rootPart.CFrame = rootPart.CFrame + (move.Unit * SpeedhackConfig.Speed * dt)
            end
        end
    end)
end
addToggleWithNotify(SpeedhackGroup, 'SpeedhackEnabled', {
    Text = 'Speedhack',
    Default = false,
    Callback = function(v)
        SpeedhackConfig.Enabled = v
        if v then
            updateSpeedHack(LP.Character)
        else
            SpeedhackConfig.Active = false
            if speedHackConnection then speedHackConnection:Disconnect() speedHackConnection = nil end
        end
    end
})
:AddKeyPicker('SpeedhackKey', {
    Default = 'None',
    Text = 'Speedhack',
    NoUI = false,
    Callback = function()
        if not SpeedhackConfig.Enabled then return end
        SpeedhackConfig.Active = not SpeedhackConfig.Active
    end
})

local speedInput = SpeedhackGroup:AddInput('SpeedhackSpeedBox', {
    Text = 'Speed',
    Default = tostring(SpeedhackConfig.Speed),
    Numeric = true,
    Finished = true,
    Callback = function(val)
        local num = tonumber(val)
        if num then
            num = M.clamp(num, 1, 2000000)
            SpeedhackConfig.Speed = num
        end
    end
})

LP.CharacterAdded:Connect(function(char)
    if SpeedhackConfig.Enabled then
        updateSpeedHack(char)
    end
end)

-- === Fly (Player tab, left) ===
local FlyGroup = Tabs.Player:AddLeftGroupbox('>_<')
local FlyConfig = {
    Enabled = false, -- toggle (мастер)
    Active = false,  -- keybind (активность)
    Speed = 1,       -- множитель (1x = 50 studs/sec)
    Keybind = Enum.KeyCode.F
}
local FlyLoop = nil
local function setNoClip(character, state)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA('BasePart') then
            if state then
                if not part:GetAttribute('OriginalCollision') then
                    part:SetAttribute('OriginalCollision', part.CanCollide)
                    part:SetAttribute('OriginalTouch', part.CanTouch)
                    if part:GetAttribute('CanQuery') ~= nil then
                        part:SetAttribute('OriginalQuery', part.CanQuery)
                    end
                end
                part.CanCollide = false
                part.CanTouch = false
                part.CanQuery = false
            else
                if part:GetAttribute('OriginalCollision') ~= nil then
                    part.CanCollide = part:GetAttribute('OriginalCollision')
                    part.CanTouch = part:GetAttribute('OriginalTouch')
                    if part:GetAttribute('OriginalQuery') ~= nil then
                        part.CanQuery = part:GetAttribute('OriginalQuery')
                    end
                    part:SetAttribute('OriginalCollision', nil)
                    part:SetAttribute('OriginalTouch', nil)
                    part:SetAttribute('OriginalQuery', nil)
                end
            end
        end
    end
end
local function updateFly(character)
    if FlyLoop then FlyLoop:Disconnect() FlyLoop = nil end
    if not character then return end
    if not (FlyConfig.Enabled and FlyConfig.Active) then return end
    setNoClip(character, true)
    FlyLoop = SND:Connect(function()
        local char = LP.Character
        if not char then return end
        setNoClip(char, true)
        local hrp = char:FindFirstChild('HumanoidRootPart')
        local hum = char:FindFirstChild('Humanoid')
        if not hrp or not hum then return end
        local speed = FlyConfig.Speed * 50
        local velocity = Vector3.new(0, 0, 0)
        if S.UIS:IsKeyDown(Enum.KeyCode.Space) then velocity = velocity + Vector3.new(0, speed, 0) end
        if S.UIS:IsKeyDown(Enum.KeyCode.LeftControl) then velocity = velocity + Vector3.new(0, -speed, 0) end
        if S.UIS:IsKeyDown(Enum.KeyCode.W) then velocity = velocity + (Cam.CFrame.LookVector * speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.A) then velocity = velocity + (Cam.CFrame.RightVector * -speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.S) then velocity = velocity + (Cam.CFrame.LookVector * -speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.D) then velocity = velocity + (Cam.CFrame.RightVector * speed) end
        hrp.Velocity = velocity
        hum:ChangeState('Freefall')
    end)
end
local function stopFly()
    if FlyLoop then FlyLoop:Disconnect() FlyLoop = nil end
    local char = LP.Character
    setNoClip(char, false)
    if char then
        local hrp = char:FindFirstChild('HumanoidRootPart')
        local hum = char:FindFirstChild('Humanoid')
        if hrp then
            hrp.Velocity = Vector3.new(0, -2, 0)
            local tempConn
            tempConn = SND:Connect(function()
                if not hrp or not hrp.Parent then tempConn:Disconnect() return end
                hrp.Velocity = Vector3.new(0, hrp.Velocity.Y, 0)
                tempConn:Disconnect()
            end)
        end
        if hum then hum:ChangeState('Landing') end
    end
end
local function setFlyActive(state)
    FlyConfig.Active = state
    if FlyConfig.Enabled and FlyConfig.Active then
        updateFly(LP.Character)
    else
        stopFly()
    end
end
addToggleWithNotify(FlyGroup, 'FlyEnabled', {
    Text = 'Fly',
    Default = false,
    Callback = function(v)
        FlyConfig.Enabled = v
        if not v then
            setFlyActive(false)
        end
        if v and FlyConfig.Active then
            updateFly(LP.Character)
        end
    end
})
:AddKeyPicker('FlyKey', {
    Default = 'None',
    Text = 'Fly',
    NoUI = false,
    Callback = function()
        if not FlyConfig.Enabled then return end
        setFlyActive(not FlyConfig.Active)
    end
})
FlyGroup:AddInput('FlySpeed', {
    Text = 'Speed',
    Default = tostring(FlyConfig.Speed),
    Numeric = true,
    Finished = true,
    Callback = function(val)
        local num = tonumber(val)
        if num then
            num = M.clamp(num, 0.1, 100)
            FlyConfig.Speed = num
        end
    end
})
LP.CharacterAdded:Connect(function(char)
    if FlyConfig.Enabled and FlyConfig.Active then
        updateFly(char)
    end
end)

-- === NoRecoil (Misc tab, отдельная секция) ===
local NoRecoilGroup = Tabs.Misc:AddLeftGroupbox('>_<')

local noRecoilHook, originalNewIndex
local noRecoilEnabled = false

local function isframework(scriptInstance)
    return tostring(scriptInstance) == "Framework"
end

local function checkArgs(instance, index)
    return STR.lower(tostring(instance)):find("camera") and tostring(index) == "CFrame"
end

local function enableNoRecoil()
    if noRecoilHook then return end
    originalNewIndex = originalNewIndex or hookmetamethod(game, "__newindex", function(self, index, value)
        local callingScr = getcallingscript and getcallingscript() or nil
        if callingScr and isframework(callingScr) and checkArgs(self, index) then
            return
        end
        return originalNewIndex(self, index, value)
    end)
    noRecoilHook = true
end

local function disableNoRecoil()
    if not noRecoilHook then return end
    -- Снимаем хук: возвращаем оригинальный __newindex
    if originalNewIndex then
        hookmetamethod(game, "__newindex", originalNewIndex)
    end
    noRecoilHook = nil
end

addToggleWithNotify(NoRecoilGroup, 'No Recoil', {
    Text = 'NoRecoil',
    Default = false,
    Callback = function(v)
        noRecoilEnabled = v
        if v then
            enableNoRecoil()
        else
            disableNoRecoil()
        end
    end,
    Tooltip = '>_<'
})

-- === NoJumpCD (Misc tab, правая секция) ===
local NoJumpCDGroup = Tabs.Misc:AddRightGroupbox('>_<')

local noJumpCDHook, originalNewIndexJump, currentNoJumpCDHook
local noJumpCDEnabled = false

local function enableNoJumpCD()
    if noJumpCDHook then return end
    local IsA = game.IsA
    -- Сохраняем оригинальный только один раз
    if not originalNewIndexJump then
        originalNewIndexJump = hookmetamethod(game, "__newindex", function(self, Index, Value)
            return originalNewIndexJump(self, Index, Value)
        end)
    end
    -- Ставим кастомный хук, всегда используя оригинальный
    currentNoJumpCDHook = hookmetamethod(game, "__newindex", function(self, Index, Value)
        if not checkcaller() and IsA(self, "Humanoid") and Index == "JumpPower" then
            return
        end
        return originalNewIndexJump(self, Index, Value)
    end)
    noJumpCDHook = true
end

local function disableNoJumpCD()
    if not noJumpCDHook then return end
    if originalNewIndexJump then
        hookmetamethod(game, "__newindex", originalNewIndexJump)
    end
    noJumpCDHook = nil
    currentNoJumpCDHook = nil
end

addToggleWithNotify(NoJumpCDGroup, 'No Jump CD', {
    Text = 'NoJumpCD',
    Default = false,
    Callback = function(v)
        noJumpCDEnabled = v
        if v then
            enableNoJumpCD()
        else
            disableNoJumpCD()
        end
    end,
    Tooltip = '>_<'
})

-- Информация о сиденьях
local seatsInfo = {
    count = 0,
    destroyed = false,
    defaultParents = {} -- Таблица для хранения родительских объектов сидений по типу
}

-- Соединение для отслеживания новых сидений
local destroySeatsConnection = nil

addToggleWithNotify(NoJumpCDGroup, 'DestroySeatsToggle', {
    Text = 'DestroySeats',
    Default = false,
    Callback = function(v)
        if v then
            -- Подсчитываем и удаляем сиденья
            seatsInfo.count = 0
            
            -- Запускаем в отдельном потоке для предотвращения зависаний
            task.spawn(function()
                -- Собираем все сиденья
                local seats = {}
        for _, obj in ipairs(S.WS:GetDescendants()) do
            if obj:IsA('Seat') or obj:IsA('VehicleSeat') then
                        table.insert(seats, obj)
                        
                        -- Запоминаем родителя для данного типа сиденья, если еще не запомнили
                        if not seatsInfo.defaultParents[obj.ClassName] then
                            seatsInfo.defaultParents[obj.ClassName] = obj.Parent
                        end
                    end
                end
                
                -- Удаляем все сиденья
                for _, seat in ipairs(seats) do
                    pcall(function()
                        if seat and seat.Parent then
                            seat:Destroy()
                            seatsInfo.count = seatsInfo.count + 1
                        end
                    end)
                end
                
                seatsInfo.destroyed = true
                
                -- Уведомляем о количестве удаленных сидений
                Library:Notify('>_< on (' .. seatsInfo.count .. ' seats)', 3)
            end)
            
            -- Устанавливаем соединение для отслеживания новых сидений
            if destroySeatsConnection then
                destroySeatsConnection:Disconnect()
            end
            
            destroySeatsConnection = S.WS.DescendantAdded:Connect(function(obj)
                if obj:IsA('Seat') or obj:IsA('VehicleSeat') then
                    task.wait(0.1) -- Небольшая задержка для инициализации
                    if obj and obj.Parent then
                        -- Запоминаем родителя для данного типа сиденья, если еще не запомнили
                        if not seatsInfo.defaultParents[obj.ClassName] then
                            seatsInfo.defaultParents[obj.ClassName] = obj.Parent
                        end
                        
                obj:Destroy()
                        seatsInfo.count = seatsInfo.count + 1
            end
        end
            end)
        else
            -- Отключаем соединение
            if destroySeatsConnection then
                destroySeatsConnection:Disconnect()
                destroySeatsConnection = nil
            end
            
            -- Восстанавливаем сиденья только если они были удалены
            if seatsInfo.destroyed then
                task.spawn(function()
                    local createdCount = 0
                    
                    -- Создаем сиденья каждого типа
                    for className, parent in pairs(seatsInfo.defaultParents) do
                        -- Проверяем, что родитель все еще существует
                        if parent and parent:IsDescendantOf(game) then
                            -- Определяем, сколько сидений нужно создать
                            -- Подсчитываем количество типов сидений
                            local typeCount = 0
                            for _ in pairs(seatsInfo.defaultParents) do
                                typeCount = typeCount + 1
                            end
                            -- Ограничиваем количество создаваемых сидений, чтобы избежать лагов
                            local seatsToCreate = math.min(50, math.ceil(seatsInfo.count / (typeCount > 0 and typeCount or 1)))
                            
                            -- Создаем сиденья
                            for i = 1, seatsToCreate do
                                pcall(function()
                                    -- Проверяем, что родитель все еще существует
                                    if parent and parent:IsDescendantOf(game) then
                                        local newSeat = Instance.new(className)
                                        newSeat.Name = className .. i
                                        newSeat.Anchored = true
                                        newSeat.CanCollide = true
                                        newSeat.Parent = parent
                                        createdCount = createdCount + 1
                                    else
                                        -- Если родитель не существует, используем workspace
                                        local newSeat = Instance.new(className)
                                        newSeat.Name = className .. i
                                        newSeat.Anchored = true
                                        newSeat.CanCollide = true
                                        newSeat.Parent = workspace
                                        createdCount = createdCount + 1
                                    end
                                    
                                    -- Добавляем небольшую задержку каждые 10 сидений
                                    if i % 10 == 0 then
                                        task.wait(0.01)
                                    end
                                end)
                            end
                        end
                    end
                    
                    -- Уведомляем о восстановлении
                    Library:Notify('>_< off (' .. createdCount .. ' seats)', 3)
                end)
                
                -- Сбрасываем флаг
                seatsInfo.destroyed = false
            end
        end
    end,
    Tooltip = '>_<'
})

-- === AntiInertia (Misc tab, отдельная правая секция) ===
local AntiInertiaGroup = Tabs.Misc:AddRightGroupbox('>_<')

local AntiInertiaSettings = {
    Enabled = false,
    Speed = {
        Ground = 0.3,
        Air = 0.3
    },
    NoInertia = true
}

local antiInertiaConnection = nil

local function ToggleAntiInertia(state)
    AntiInertiaSettings.Enabled = state
    if antiInertiaConnection then
        antiInertiaConnection:Disconnect()
        antiInertiaConnection = nil
    end
    if state then
        antiInertiaConnection = HRT:Connect(function()
            if not AntiInertiaSettings.Enabled then return end
            local character = LP.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then return end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid then return end
            local rootPart = character.HumanoidRootPart
            local moveDir = humanoid.MoveDirection
            if moveDir.Magnitude > 0 then
                local speedMult = (humanoid:GetState() == Enum.HumanoidStateType.Freefall or humanoid:GetState() == Enum.HumanoidStateType.Jumping)
                    and AntiInertiaSettings.Speed.Air or AntiInertiaSettings.Speed.Ground
                local newVel = moveDir * speedMult * 50
                if AntiInertiaSettings.NoInertia then
                    rootPart.Velocity = Vector3.new(newVel.X, rootPart.Velocity.Y, newVel.Z)
                else
                    local curVel = rootPart.Velocity
                    rootPart.Velocity = Vector3.new(
                        curVel.X + (newVel.X - curVel.X) * 0.5,
                        rootPart.Velocity.Y,
                        curVel.Z + (newVel.Z - curVel.Z) * 0.5
                    )
                end
            elseif AntiInertiaSettings.NoInertia then
                rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
            end
        end)
    end
end

LP.CharacterAdded:Connect(function()
    if AntiInertiaSettings.Enabled then
        ToggleAntiInertia(true)
    end
end)

addToggleWithNotify(AntiInertiaGroup, 'Anti Inertia', {
    Text = 'AntiInertia',
    Default = false,
    Callback = function(v)
        ToggleAntiInertia(v)
    end,
    Tooltip = '>_<'
})

-- === Yaw Locker (Player tab, новая секция) ===
local YawLockerGroup = Tabs.Player:AddLeftGroupbox('>_<')

local YawLockerConfig = {
    Enabled = false,
    Angle = 0,
    Mode = 'Locked',
    Modes = {'Locked', 'Jitter', '3 Ways', '5 Ways'},
    AtTarget = false,
    DisableAutoRotate = false
}

-- Используем переменные из таблицы G для YawLocker

local function getYawAngles()
    local a = YawLockerConfig.Angle
    if YawLockerConfig.Mode == 'Locked' then
        return {a}
    elseif YawLockerConfig.Mode == 'Jitter' then
        return {a, -a}
    elseif YawLockerConfig.Mode == '3 Ways' then
        return {-a, 0, a}
    elseif YawLockerConfig.Mode == '5 Ways' then
        return {-a, -a/2, 0, a/2, a}
    end
    return {a}
end

local function applyYawLockerAutoRotate()
    local char = LP.Character
    if char then
        local hum = char:FindFirstChildOfClass('Humanoid')
        if hum then
            hum.AutoRotate = not YawLockerConfig.DisableAutoRotate
        end
    end
end

local function setYawLocker(state)
    YawLockerConfig.Enabled = state
    if G.yawLockerConnection then
        G.yawLockerConnection:Disconnect()
        G.yawLockerConnection = nil
    end
    G.yawJitterState = 1
    G.yawJitterTimer = 0
    applyYawLockerAutoRotate()
    if state then
        G.yawLockerConnection = RND:Connect(function(dt)
            local char = LP.Character
            if not char then return end
            local hrp = char:FindFirstChild('HumanoidRootPart')
            if not hrp then return end
            
            local myPos = hrp.Position
            local lookVector
            
            if YawLockerConfig.AtTarget then
                local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
                if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                    local targetHrp = target.Character.HumanoidRootPart
                    local directionToTarget = (targetHrp.Position - myPos)
                    local baseYaw = M.atan2(directionToTarget.X, directionToTarget.Z)
                    
                    local angles = getYawAngles()
                    local finalYaw
                    
                    if YawLockerConfig.Mode == 'Jitter' then
                        G.yawJitterTimer = G.yawJitterTimer + dt
                        if G.yawJitterTimer > 0.1 then
                            G.yawJitterState = 3 - G.yawJitterState -- 1 <-> 2
                            G.yawJitterTimer = 0
                        end
                        finalYaw = baseYaw + M.rad(angles[G.yawJitterState])
                    elseif YawLockerConfig.Mode == '3 Ways' then
                         G.yawJitterTimer = G.yawJitterTimer + dt
                        if G.yawJitterTimer > 0.15 then
                            G.yawJitterState = G.yawJitterState % 3 + 1
                            G.yawJitterTimer = 0
                        end
                        finalYaw = baseYaw + M.rad(angles[G.yawJitterState])
                    elseif YawLockerConfig.Mode == '5 Ways' then
                         G.yawJitterTimer = G.yawJitterTimer + dt
                        if G.yawJitterTimer > 0.12 then
                            G.yawJitterState = G.yawJitterState % 5 + 1
                             G.yawJitterTimer = 0
                        end
                        finalYaw = baseYaw + M.rad(angles[G.yawJitterState])
                    else -- Locked
                        finalYaw = baseYaw + M.rad(angles[1])
                    end
                    
                    lookVector = Vector3.new(M.sin(finalYaw), 0, M.cos(finalYaw))
                end
            else -- Режим не AtTarget
                local angles = getYawAngles()
                local yaw
                if YawLockerConfig.Mode == 'Locked' then
                    yaw = M.rad(angles[1])
                elseif YawLockerConfig.Mode == 'Jitter' then
                    G.yawJitterTimer = G.yawJitterTimer + dt
                    if G.yawJitterTimer > 0.1 then
                        G.yawJitterState = 3 - G.yawJitterState -- 1 <-> 2
                        G.yawJitterTimer = 0
                    end
                    yaw = M.rad(angles[G.yawJitterState])
                elseif YawLockerConfig.Mode == '3 Ways' then
                    G.yawJitterTimer = G.yawJitterTimer + dt
                    if G.yawJitterTimer > 0.15 then
                        G.yawJitterState = G.yawJitterState % 3 + 1
                        G.yawJitterTimer = 0
                    end
                    yaw = M.rad(angles[G.yawJitterState])
                elseif YawLockerConfig.Mode == '5 Ways' then
                    G.yawJitterTimer = G.yawJitterTimer + dt
                    if G.yawJitterTimer > 0.12 then
                        G.yawJitterState = G.yawJitterState % 5 + 1
                        G.yawJitterTimer = 0
                    end
                    yaw = M.rad(angles[G.yawJitterState])
                else
                    yaw = M.rad(YawLockerConfig.Angle)
                end
                lookVector = Vector3.new(M.sin(yaw), 0, M.cos(yaw))
            end

            if lookVector then
                hrp.CFrame = CFrame.new(myPos, myPos + lookVector)
            end
        end)
    end
end

addToggleWithNotify(YawLockerGroup, 'YawLocker', {
    Text = 'YawLock',
    Default = false,
    Callback = function(v)
        setYawLocker(v)
    end,
    Tooltip = '>_<'
})

YawLockerGroup:AddDropdown('YawLockerMode', {
    Text = 'Mode',
    Values = YawLockerConfig.Modes,
    Default = 'Locked',
    Callback = function(val)
        YawLockerConfig.Mode = val
        yawJitterState = 1
        yawJitterTimer = 0
    end,
    Tooltip = '>_<'
})

YawLockerGroup:AddSlider('YawLockerAngle', {
    Text = 'Angle',
    Default = 0,
    Min = 0,
    Max = 360,
    Rounding = 0,
    Callback = function(val)
        YawLockerConfig.Angle = val
    end,
    Tooltip = '>_<'
})

YawLockerGroup:AddToggle('YawLockerAtTarget', {
    Text = 'AtTarget',
    Default = false,
    Callback = function(v)
        YawLockerConfig.AtTarget = v
    end,
    Tooltip = '>_<'
})

YawLockerGroup:AddToggle('YawLockerDisableAutoRotate', {
    Text = 'DisableAutoRotate',
    Default = false,
    Callback = function(v)
        YawLockerConfig.DisableAutoRotate = v
        applyYawLockerAutoRotate()
    end,
    Tooltip = '>_<'
})
LP.CharacterAdded:Connect(function(char)
    if YawLockerConfig.Enabled or YawLockerConfig.DisableAutoRotate then
        applyYawLockerAutoRotate()
    end
end)

-- === Noclip (Player tab) ===
local NoclipGroup = Tabs.Player:AddLeftGroupbox('>_<')

-- Noclip configuration
getgenv().NoclipConfig = {
    Enabled = false,
    Connection = nil
}

-- Function to apply noclip
local function applyNoclip(character, state)
    if not character then return end
    
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA('BasePart') then
            if state then
                -- Store original collision state if not already stored
                if not part:GetAttribute('NoclipOrigCollision') then
                    part:SetAttribute('NoclipOrigCollision', part.CanCollide)
                end
                part.CanCollide = false
            else
                -- Restore original collision state
                if part:GetAttribute('NoclipOrigCollision') ~= nil then
                    part.CanCollide = part:GetAttribute('NoclipOrigCollision')
                    part:SetAttribute('NoclipOrigCollision', nil)
                end
            end
        end
    end
end

-- Function to toggle noclip
local function toggleNoclip(state)
    local config = getgenv().NoclipConfig
    config.Enabled = state
    
    -- Disconnect existing connection if any
    if config.Connection then
        config.Connection:Disconnect()
        config.Connection = nil
    end
    
    -- If enabling noclip, set up heartbeat connection
    if state then
        local char = LP.Character
        if char then
            applyNoclip(char, true)
        end
        
        config.Connection = HRT:Connect(function()
            local character = LP.Character
            if character then
                applyNoclip(character, true)
            end
        end)
    else
        -- If disabling, restore collision
        local char = LP.Character
        if char then
            applyNoclip(char, false)
        end
    end
end

-- Add noclip toggle to the UI
addToggleWithNotify(NoclipGroup, 'NoclipEnabled', {
    Text = 'Noclip',
    Default = false,
    Callback = function(v)
        toggleNoclip(v)
    end,
    Tooltip = 'Removes collision with objects'
})

-- Connect to CharacterAdded to handle respawns
LP.CharacterAdded:Connect(function(char)
    if getgenv().NoclipConfig.Enabled then
        task.wait(0.5) -- Small delay to ensure character is fully loaded
        applyNoclip(char, true)
    end
end)

-- === AnimBreaker (Player tab, новая секция) ===
local AnimBreakerGroup = Tabs.Player:AddRightGroupbox('>_<')

-- Глобальные переменные и настройки для AnimBreaker
getgenv().AnimBreakerSettings = {
    enabled = false,
    delayTime = 0.4,
    stepSize = 0.4,
    customAnimEnabled = false,
    customAnimId = "10714340543",
    persistAfterDeath = true -- Продолжать работу после смерти
}

getgenv().animBreakerTracks = {}
getgenv().animBreakerAnimatorConn = nil
getgenv().animBreakerHeartbeatConn = nil
getgenv().animBreakerCoroutine = nil
getgenv().customAnimCoroutine = nil
getgenv().deathConnection = nil
getgenv().respawnConnection = nil

-- Глобальные функции для AnimBreaker
function freezeAnimBreakerTrack(track)
    if not track or not track.IsPlaying then return end
    track:AdjustSpeed(0)
    getgenv().animBreakerTracks[track] = true
end

function restoreAnimations(character)
    local humanoid = character and character:FindFirstChildOfClass('Humanoid')
    if not humanoid then return end
    
    local animator = humanoid:FindFirstChildOfClass('Animator')
    if not animator then return end
    
    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        if getgenv().animBreakerTracks[track] then
            track:AdjustSpeed(1) -- Восстанавливаем нормальную скорость
            getgenv().animBreakerTracks[track] = nil
        end
    end
    
    if getgenv().animBreakerAnimatorConn then 
        getgenv().animBreakerAnimatorConn:Disconnect()
        getgenv().animBreakerAnimatorConn = nil
    end
    
    -- Восстанавливаем анимацию персонажа
    if humanoid:FindFirstChild("Animate") then
        humanoid.Animate.Disabled = false
    end
end

function playCustomAnimation(character, withLags)
    if not character then return end
    
    -- Проверяем, существует ли персонаж
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Добавляем обработчик события смерти для перезапуска анимации
    if not getgenv().deathConnection and humanoid then
        getgenv().deathConnection = humanoid.Died:Connect(function()
            -- Сохраняем труп для проигрывания анимации на нем
            local deadCharacter = character
            
            -- Продолжаем проигрывать анимацию на трупе
            task.spawn(function()
                if getgenv().AnimBreakerSettings.customAnimEnabled and deadCharacter then
                    -- Пытаемся проиграть анимацию на трупе
                    local animator = deadCharacter:FindFirstChildOfClass("Humanoid") and 
                                    deadCharacter:FindFirstChildOfClass("Humanoid"):FindFirstChildOfClass("Animator")
                    
                    if animator then
                        local animation = Instance.new("Animation")
                        animation.AnimationId = "rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId
                        
                        pcall(function()
                            local track = animator:LoadAnimation(animation)
                            if track then
                                track:Play()
                                track.Looped = true
                            end
                        end)
                    end
                end
            end)
            
            -- Также настраиваем анимацию для нового персонажа после респавна
            task.spawn(function()
                task.wait(1) -- Даем время на респавн
                if getgenv().AnimBreakerSettings.customAnimEnabled then
                    local newCharacter = LP.Character or LP.CharacterAdded:Wait()
                    if newCharacter and newCharacter ~= deadCharacter then
                        playCustomAnimation(newCharacter, getgenv().AnimBreakerSettings.enabled)
                    end
                end
            end)
        end)
    end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return end
    
    -- Отменяем предыдущую корутину
    if getgenv().customAnimCoroutine then
        task.cancel(getgenv().customAnimCoroutine)
        getgenv().customAnimCoroutine = nil
    end
    
    -- Создаем новую корутину для проигрывания анимации
    getgenv().customAnimCoroutine = task.spawn(function()
        -- Создаем анимацию
        local animation = Instance.new("Animation")
        animation.AnimationId = "rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId
        
        -- Загружаем анимацию
        local animTrack = nil
        pcall(function()
            animTrack = animator:LoadAnimation(animation)
        end)
        
        -- Если не удалось загрузить, пробуем еще раз
        if not animTrack then
            task.wait(0.1)
            pcall(function()
                animTrack = animator:LoadAnimation(animation)
            end)
        end
        
        -- Проигрываем анимацию, если удалось загрузить
        if animTrack then
            animTrack:Play()
            
            -- Если включен режим с лагами (AnimBreaker + CustomAnim)
            if withLags then
                -- Создаем эффект лагов, меняя скорость воспроизведения
                task.spawn(function()
                    while animTrack.IsPlaying and getgenv().AnimBreakerSettings.customAnimEnabled do
                        pcall(function()
                            -- Случайно меняем скорость для эффекта лагов
                            animTrack:AdjustSpeed(math.random(5, 20) / 10)
                            
                            -- Иногда перемещаем позицию воспроизведения
                            if math.random() > 0.5 then
                                animTrack.TimePosition = math.random() * animTrack.Length
                            end
                        end)
                        task.wait(math.random(5, 15) / 100)
                    end
                end)
            else
                -- Обычное воспроизведение без лагов
                animTrack:AdjustSpeed(1)
                animTrack.Looped = true
            end
        else
            -- Запасной метод через RemoteEvent
            pcall(function()
                if game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent") then
                    local args = {
                        [1] = "PlayAnimation",
                        [2] = "rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId
                    }
                    local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent")
            if mainEvent then
                mainEvent:FireServer(unpack(args))
            end
                end
            end)
        end
    end)
end

function setupAnimBreakerCharacter(character)
    if not getgenv().AnimBreakerSettings.enabled then return end
    
    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")
    
    table.clear(getgenv().animBreakerTracks)
    
    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        freezeAnimBreakerTrack(track)
    end
    
    if getgenv().animBreakerAnimatorConn then 
        getgenv().animBreakerAnimatorConn:Disconnect() 
    end
    
    getgenv().animBreakerAnimatorConn = animator.AnimationPlayed:Connect(freezeAnimBreakerTrack)
end

function toggleAnimBreaker(state)
    getgenv().AnimBreakerSettings.enabled = state
    
    if getgenv().animBreakerHeartbeatConn then 
        getgenv().animBreakerHeartbeatConn:Disconnect() 
        getgenv().animBreakerHeartbeatConn = nil 
    end
    
    if state then
        if LP.Character then
            setupAnimBreakerCharacter(LP.Character)
        end
        
        getgenv().animBreakerHeartbeatConn = HRT:Connect(function()
            for track in pairs(getgenv().animBreakerTracks) do
                if track and track.IsPlaying then
                    track:AdjustSpeed(0)
                else
                    getgenv().animBreakerTracks[track] = nil
                end
            end
        end)
        
        -- Запускаем отдельную корутину для обновления позиции анимации
        task.spawn(function()
            while getgenv().AnimBreakerSettings.enabled do
                for track in pairs(getgenv().animBreakerTracks) do
                    if track and track.IsPlaying then
                        pcall(function()
                            track.TimePosition = track.TimePosition + getgenv().AnimBreakerSettings.stepSize
                        end)
                    end
                end
                task.wait(getgenv().AnimBreakerSettings.delayTime)
            end
        end)
    else
        -- Восстанавливаем нормальные анимации при отключении
        if LP.Character then
            restoreAnimations(LP.Character)
        end
    end
    
    -- Обновляем состояние кастомной анимации при изменении AnimBreaker
    updateCustomAnimationState()
end

function toggleCustomAnimation(state)
    getgenv().AnimBreakerSettings.customAnimEnabled = state
    
    -- Очищаем предыдущие соединения смерти
    if getgenv().deathConnection then
        getgenv().deathConnection:Disconnect()
        getgenv().deathConnection = nil
    end
    
    if state and LP.Character then
        -- Запускаем анимацию с лагами или без в зависимости от состояния AnimBreaker
        local withLags = getgenv().AnimBreakerSettings.enabled
        playCustomAnimation(LP.Character, withLags)
    else
        -- Останавливаем корутину кастомной анимации
        if getgenv().customAnimCoroutine then
            task.cancel(getgenv().customAnimCoroutine)
            getgenv().customAnimCoroutine = nil
        end
        
        -- Останавливаем все анимации с нашим ID на всех персонажах в игре
        -- Это нужно, чтобы очистить анимации, которые могли остаться после смерти
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if player.Character then
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local animator = humanoid:FindFirstChildOfClass("Animator")
                    if animator then
                        for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                            if track.Animation and track.Animation.AnimationId and 
                               track.Animation.AnimationId:find(getgenv().AnimBreakerSettings.customAnimId) then
                                track:Stop()
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Обновляем состояние кастомной анимации при изменении AnimBreaker
function updateCustomAnimationState()
    if getgenv().AnimBreakerSettings.customAnimEnabled and LP.Character then
        -- Перезапускаем анимацию с новыми параметрами
        local withLags = getgenv().AnimBreakerSettings.enabled
        
        -- Останавливаем все текущие анимации
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local animator = humanoid:FindFirstChildOfClass("Animator")
            if animator then
                for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                    if track.Animation and track.Animation.AnimationId and 
                       track.Animation.AnimationId:find(getgenv().AnimBreakerSettings.customAnimId) then
                        track:Stop()
                    end
                end
            end
        end
        
        -- Запускаем с новыми параметрами
        playCustomAnimation(LP.Character, withLags)
    end
end

-- Глобальный обработчик появления персонажа
getgenv().respawnConnection = LP.CharacterAdded:Connect(function(character)
    -- Для AnimBreaker
    if getgenv().AnimBreakerSettings.enabled then
        setupAnimBreakerCharacter(character)
    end
    
    -- Для CustomAnim - запускаем анимацию после респавна
    if getgenv().AnimBreakerSettings.customAnimEnabled then
        -- Даем персонажу немного времени загрузиться
        task.wait(0.5)
        playCustomAnimation(character, getgenv().AnimBreakerSettings.enabled)
    end
end)

addToggleWithNotify(AnimBreakerGroup, 'AnimBreaker', {
    Text = 'AnimBreaker',
    Default = false,
    Callback = function(v)
        toggleAnimBreaker(v)
    end,
    Tooltip = '>_<'
})



-- Добавляем тогл для кастомной анимации
addToggleWithNotify(AnimBreakerGroup, 'CustomAnimation', {
    Text = 'CustomAnim',
    Default = false,
    Callback = function(v)
        toggleCustomAnimation(v)
    end,
    Tooltip = '>_<'
})

-- === RapidFireGunScript (Player tab, новая секция) ===
local RapidFireGunScriptGroup = Tabs.Player:AddRightGroupbox('>_<')

local Traced = { RapidFire = false }
local Orginal = {}
local rapidFireGunScriptConn = nil

local function enableRapidFireGunScript()
    if rapidFireGunScriptConn then rapidFireGunScriptConn:Disconnect() end
    
    -- Оптимизируем, добавив дебаунс и уменьшив частоту проверок
    local lastToolCheck = 0
    local toolCheckInterval = 0.2 -- Проверяем каждые 200мс вместо каждого кадра
    local currentTool = nil
    local isOptimizing = false
    
    rapidFireGunScriptConn = HRT:Connect(function()
        local now = tick()
        -- Проверяем оружие только через интервал или при смене оружия
        if now - lastToolCheck < toolCheckInterval and currentTool then return end
        
        lastToolCheck = now
        local tool = LP.Character and LP.Character:FindFirstChildOfClass('Tool')
        
        -- Если оружие не изменилось, не делаем повторную оптимизацию
        if tool == currentTool then return end
        currentTool = tool
        
        -- Если уже идет процесс оптимизации, не запускаем новый
        if isOptimizing then return end
        
        -- Запускаем оптимизацию в отдельном потоке, чтобы не влиять на FPS
        task.spawn(function()
            isOptimizing = true
            if tool and tool:FindFirstChild('GunScript') then
                for _, connection in ipairs(getconnections(tool.Activated)) do
                    local func = connection.Function
                    if func then
                        local funcInfo = debug.getinfo(func)
                        for i = 1, funcInfo.nups do
                            local c, n = debug.getupvalue(func, i)
                            if type(c) == 'number' then
                                if not Orginal[i] then
                                    Orginal[i] = c
                                end
                                debug.setupvalue(func, i, Traced.RapidFire and 0.00000000000000000001 or Orginal[i])
                            end
                        end
                    end
                end
            end
            isOptimizing = false
        end)
    end)
    
    Traced.RapidFire = true
end

local function disableRapidFireGunScript()
    if rapidFireGunScriptConn then rapidFireGunScriptConn:Disconnect() rapidFireGunScriptConn = nil end
    Traced.RapidFire = false
end

addToggleWithNotify(RapidFireGunScriptGroup, 'RapidFireGunScript', {
    Text = 'RapidFireGunScript',
    Default = false,
    Callback = function(v)
        if v then
            enableRapidFireGunScript()
        else
            disableRapidFireGunScript()
        end
    end,
    Tooltip = '>_<'
})

-- === RapidFireM1Spam (Player tab, новая секция) ===
local RapidFireM1Group = Tabs.Player:AddRightGroupbox('>_<')

-- Используем переменные из таблицы G

local function rapidFireM1SafeActivate(tool)
    if not G.rapidFireM1Debounce and tool and tool:IsA('Tool') then
        G.rapidFireM1Debounce = true
        pcall(function() tool:Activate() end)
        task.wait(G.rapidFireM1MinDelay)
        G.rapidFireM1Debounce = false
    end
end

local function rapidFireM1FireLoop()
    while G.rapidFireM1Firing do
        local character = LP.Character
        if character then
            local tool = character:FindFirstChildOfClass('Tool')
            rapidFireM1SafeActivate(tool)
        end
        HRT:Wait()
    end
end

local function rapidFireM1SetupCharacter(character)
    if G.rapidFireM1CharConn then G.rapidFireM1CharConn:Disconnect() end
    G.rapidFireM1CharConn = character.ChildAdded:Connect(function(child)
        if child:IsA('Tool') then
            child.Activated:Connect(function()
                if G.rapidFireM1Firing then
                    rapidFireM1SafeActivate(child)
                end
            end)
        end
    end)
end

local function enableRapidFireM1()
    if G.rapidFireM1ConnBegan then G.rapidFireM1ConnBegan:Disconnect() end
    if G.rapidFireM1ConnEnded then G.rapidFireM1ConnEnded:Disconnect() end
    G.rapidFireM1ConnBegan = S.UIS.InputBegan:Connect(function(input, gp)
        if not gp and input.UserInputType == Enum.UserInputType.MouseButton1 then
            G.rapidFireM1Firing = true
            rapidFireM1FireLoop()
        end
    end)
    G.rapidFireM1ConnEnded = S.UIS.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            G.rapidFireM1Firing = false
        end
    end)
    if LP.Character then rapidFireM1SetupCharacter(LP.Character) end
    LP.CharacterAdded:Connect(function(character)
        character:WaitForChild('Humanoid')
        rapidFireM1SetupCharacter(character)
    end)
end

local function disableRapidFireM1()
    if G.rapidFireM1ConnBegan then G.rapidFireM1ConnBegan:Disconnect() G.rapidFireM1ConnBegan = nil end
    if G.rapidFireM1ConnEnded then G.rapidFireM1ConnEnded:Disconnect() G.rapidFireM1ConnEnded = nil end
    if G.rapidFireM1CharConn then G.rapidFireM1CharConn:Disconnect() G.rapidFireM1CharConn = nil end
    G.rapidFireM1Firing = false
end

addToggleWithNotify(RapidFireM1Group, 'RapidFireM1Spam', {
    Text = 'RapidFireM1',
    Default = false,
    Callback = function(v)
        if v then
            enableRapidFireM1()
        else
            disableRapidFireM1()
        end
    end,
    Tooltip = '>_<'
})

-- === Misc Utilities (Misc tab, новая левая секция) ===
local MiscUtilsGroup = Tabs.Misc:AddLeftGroupbox('>_<')

-- === FOV Settings (Misc tab) ===
local FOVGroup = Tabs.Misc:AddRightGroupbox('>_<')

-- Создаем конфигурацию для FOV
local FOVConfig = {
    Enabled = false,
    Value = 70 -- Значение по умолчанию
}

-- Добавляем toggle для включения/выключения FOV
addToggleWithNotify(FOVGroup, 'FOVEnabled', {
    Text = 'FOV',
    Default = false,
    Callback = function(v)
        FOVConfig.Enabled = v
        -- Применяем или сбрасываем FOV
        if v then
            -- Проверяем, что значение FOV находится в допустимых пределах
            local fovValue = math.clamp(FOVConfig.Value, 1, 130)
            Cam.FieldOfView = fovValue
        else
            Cam.FieldOfView = 70 -- Стандартное значение FOV
        end
    end,
    Tooltip = '>_<'
})

-- Добавляем слайдер для настройки значения FOV без ограничений
FOVGroup:AddSlider('FOVValue', {
    Text = 'FOV Value',
    Default = 70,
    Min = 1,
    Max = 130,
    Rounding = 0,
    Step = 1,
    Callback = function(v)
        FOVConfig.Value = v
        -- Если FOV включен, сразу применяем новое значение
        if FOVConfig.Enabled then
            game:GetService("Workspace").CurrentCamera.FieldOfView = v
        end
    end,
    Tooltip = '>_<'
})

-- Добавляем соединение для обеспечения постоянного FOV при смене камеры
local fovConnection
fovConnection = S.RS.RenderStepped:Connect(function()
    if FOVConfig.Enabled then
        -- Проверяем, что значение FOV находится в допустимых пределах
        local fovValue = math.clamp(FOVConfig.Value, 1, 130)
        Cam.FieldOfView = fovValue
    end
end)

-- === Auto Talk (Misc tab, правая секция) ===
local TalkGroup = Tabs.Misc:AddRightGroupbox('>_<')

-- Глобальные переменные для Auto Talk
G.AutoTalk = {
    enabled = false,
    talkType = "TrashTalk",
    interval = 5, -- секунд между сообщениями
    connection = nil,
    targetInRadiusOnly = false, -- новая настройка для проверки радиуса
    phrases = {
        TrashTalk = {
            "ez kid",
            "ur bad",
            "get better",
            "u need to see ur monitor btw",
            "imagine losing",
            "clown down",
            "ur mom",
            "go cry",
            "trash",
            "zzzzz"
        },
        AdTalk = {
            "halalware on top",
            "get halal, lame",
            "get halalware or lose again",
            "imagine not using halal",
            "halalware > all",
            "halalware the best",
            "halalware never loses",
            "atleast better then ur script",
            "halalware user = godness",
            "halalware = win"
        }
    }
}

-- Функция для проверки, находится ли цель в радиусе
G.isTargetInRadius = function(radius)
    -- Получаем текущую цель аимбота
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    if not target or not target.Character then return false end
    
    -- Проверяем наличие HumanoidRootPart у цели
    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return false end
    
    -- Используем кэшированный персонаж и HRP
    if not Char then return false end
    
    local localHRP = Body.HRP
    if not localHRP then return false end
    
    -- Вычисляем расстояние между игроком и целью
    local distance = (localHRP.Position - targetHRP.Position).Magnitude
    
    -- Возвращаем true, если цель в радиусе
    return distance <= radius
end

-- Функция для отправки случайной фразы
G.sendRandomTalkMessage = function()
    -- Проверяем, нужно ли учитывать радиус
    if G.AutoTalk.targetInRadiusOnly then
        -- Если цель должна быть в радиусе, но её там нет - не отправляем сообщение
        if not G.isTargetInRadius(100) then
            return
        end
    end
    
    local phrases = G.AutoTalk.phrases[G.AutoTalk.talkType]
    if not phrases or #phrases == 0 then return end
    
    local randomIndex = math.random(1, #phrases)
    local message = phrases[randomIndex]
    
    -- Используем ту же функцию отправки, что и для ChatBypass
    G.sendMsg(message)
end

-- Функция для запуска/остановки автоматической отправки сообщений
G.toggleAutoTalk = function(state)
    G.AutoTalk.enabled = state
    
    if G.AutoTalk.connection then
        G.AutoTalk.connection:Disconnect()
        G.AutoTalk.connection = nil
    end
    
    if state then
        -- Запускаем цикл отправки сообщений
        G.AutoTalk.connection = task.spawn(function()
            while G.AutoTalk.enabled do
                G.sendRandomTalkMessage()
                task.wait(G.AutoTalk.interval)
        end
    end)
        Library:Notify('>_< Talk on', 3)
    else
        Library:Notify('>_< Talk off', 3)
    end
end

-- Добавляем toggle для включения/выключения Auto Talk
addToggleWithNotify(TalkGroup, 'AutoTalkEnabled', {
    Text = 'Talk',
    Default = false,
    Callback = function(v)
        G.toggleAutoTalk(v)
    end,
    Tooltip = '>_<'
})

-- Добавляем dropdown для выбора типа сообщений
TalkGroup:AddDropdown('AutoTalkType', {
    Text = 'Type',
    Values = {'TrashTalk', 'AdTalk'},
    Default = 'TrashTalk',
    Multi = false,
    Callback = function(v)
        G.AutoTalk.talkType = v
    end,
    Tooltip = '>_<'
})

-- Добавляем слайдер для интервала между сообщениями
TalkGroup:AddSlider('AutoTalkInterval', {
    Text = 'Interval (s)',
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Callback = function(v)
        G.AutoTalk.interval = v
    end,
    Tooltip = '>_<'
})

-- Добавляем тогл для проверки радиуса цели
addToggleWithNotify(TalkGroup, 'AutoTalkTargetInRadius', {
    Text = 'IfTargetInRadius100',
    Default = false,
    Callback = function(v)
        G.AutoTalk.targetInRadiusOnly = v
    end,
    Tooltip = '>_<'
})

-- === Chat Bypass (Misc tab, новая левая секция) ===
local ChatBypassGroup = Tabs.Misc:AddLeftGroupbox('>_<')

-- Глобальные переменные для ChatBypass
G.ChatBypass = {
    -- Карта замены латинских символов на кириллические
    letterMap = {
        ["o"] = "о",
        ["i"] = "і",
        ["l"] = "ӏ",
        ["p"] = "р",
        ["a"] = "а"
    },
    
    -- Карта замены кириллических символов на латинские
    cyrillicMap = {
        ["а"] = "a",
        ["е"] = "e",
        ["у"] = "y",
        ["т"] = "T"
    },
    
    -- Текст для отправки
    text = ""
}

-- Функция для стилизации текста
G.styleText = function(t)
    local r = ""
    for _, c in utf8.codes(t) do
        local ch = utf8.char(c)
        if ch == " " then
            r = r .. "," .. string.char(0x1E)
        else
            local newCh = G.ChatBypass.letterMap[string.lower(ch)] or G.ChatBypass.cyrillicMap[ch] or ch
            r = r .. newCh .. "ּ"
                        end
                    end
    return r
end

-- Функция для отправки сообщения
G.sendMsg = function(m)
    local success, result = pcall(function()
        if game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.LegacyChatService then
            game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest"):FireServer(m, "All")
        else
            game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(m)
        end
    end)
    
    if not success then
        Library:Notify('>_< Error: ' .. tostring(result), 3)
                end
            end

-- Функция отправки текста
G.sendChatBypassText = function()
    if G.ChatBypass.text and G.ChatBypass.text ~= "" then
        local bypassedText = G.styleText(G.ChatBypass.text)
        G.sendMsg(bypassedText)
        Library:Notify('>_<', 3)
    else
        Library:Notify('>_< No text', 3)
    end
end

-- Добавляем текстбокс для ввода текста
ChatBypassGroup:AddInput('ChatBypassInput', {
    Text = 'ChatBypass',
    Default = "",
    Numeric = false,
    Finished = true,
    Callback = function(value)
        G.ChatBypass.text = value
    end,
    Tooltip = '>_<'
})

-- Добавляем кнопку для отправки сообщения
ChatBypassGroup:AddButton({
    Text = 'Send',
    Func = function()
        G.sendChatBypassText()
    end,
    Tooltip = '>_<'
})

-- === InvisDesync (Misc tab, в MiscUtilsGroup) ===
-- Глобальные переменные для InvisDesync
getgenv().InvisDesyncConfig = {
    Enabled = false,
    FlipState = false
}

-- Функция для получения HumanoidRootPart
getgenv().getHRP = function()
    local character = S.PS.LocalPlayer.Character or S.PS.LocalPlayer.CharacterAdded:Wait()
    return character:WaitForChild("HumanoidRootPart", 5)
end

-- Соединение для десинка
getgenv().InvisDesyncConnection = nil

-- Функция для активации только FakePos без изменения состояния
getgenv().applyFakePos = function()
    pcall(function()
        setfflag("S2PhysicsSenderRate", "1")
        setfpscap(1)
        task.wait(0.1)
        setfflag("S2PhysicsSenderRate", "200")
        setfpscap(240)
    end)
end

-- Функция для включения/выключения комбинированного InvisDesync + FakePos
getgenv().toggleInvisDesync = function(state)
    getgenv().InvisDesyncConfig.Enabled = state
    
    -- Отключаем существующее соединение, если есть
    if getgenv().InvisDesyncConnection then
        getgenv().InvisDesyncConnection:Disconnect()
        getgenv().InvisDesyncConnection = nil
    end
    
    -- Сбрасываем NetworkIsSleeping в false при выключении
    if not state then
        local hrp = getgenv().getHRP()
        if hrp then
            pcall(function()
                sethiddenproperty(hrp, "NetworkIsSleeping", false)
            end)
        end
        return
    end
    
    if state then
        -- Активируем FakePos
        getgenv().applyFakePos()
        
        -- Активируем Desync
        getgenv().InvisDesyncConnection = S.RS.Heartbeat:Connect(function()
            if getgenv().InvisDesyncConfig.Enabled then
                local hrp = getgenv().getHRP()
                if hrp then
                    getgenv().InvisDesyncConfig.FlipState = not getgenv().InvisDesyncConfig.FlipState
                    pcall(function()
                        sethiddenproperty(hrp, "NetworkIsSleeping", getgenv().InvisDesyncConfig.FlipState)
                    end)
                end
            end
        end)
    end
end

-- UI для комбинированного InvisDesync + FakePos
addToggleWithNotify(MiscUtilsGroup, 'InvisDesyncEnabled', {
    Text = 'Fake Pos',
    Default = false,
    Callback = function(v)
        getgenv().toggleInvisDesync(v)
        
        -- Если включаем, добавляем обработчик восстановления после смерти
        if v then
            -- Отключаем предыдущий обработчик, если он существует
            if getgenv().InvisDesyncRespawnConnection then
                getgenv().InvisDesyncRespawnConnection:Disconnect()
                getgenv().InvisDesyncRespawnConnection = nil
            end
            
            -- Создаем новый обработчик для восстановления FakePos после смерти
            getgenv().InvisDesyncRespawnConnection = LP.CharacterAdded:Connect(function(newChar)
                -- Небольшая задержка для полной загрузки персонажа
                task.wait(0.5)
                
                -- Проверяем, что FakePos все еще должен быть включен
                if getgenv().InvisDesyncConfig and getgenv().InvisDesyncConfig.Enabled then
                    -- Повторно применяем FakePos
                    getgenv().applyFakePos()
                end
            end)
        else
            -- Отключаем обработчик при выключении функции
            if getgenv().InvisDesyncRespawnConnection then
                getgenv().InvisDesyncRespawnConnection:Disconnect()
                getgenv().InvisDesyncRespawnConnection = nil
            end
        end
    end,
    Tooltip = '>_<'
})

-- Сохраняем оригинальное значение FallenPartsDestroyHeight
local originalFallenPartsDestroyHeight = S.WS.FallenPartsDestroyHeight

addToggleWithNotify(MiscUtilsGroup, 'DestroyVoidToggle', {
    Text = 'DestroyVoid',
    Default = false,
    Callback = function(v)
        if v then
            -- Сохраняем текущее значение, если оно не сохранено или равно NaN
            if originalFallenPartsDestroyHeight ~= originalFallenPartsDestroyHeight then -- Проверка на NaN
                originalFallenPartsDestroyHeight = -500 -- Стандартное значение
            end
            -- Устанавливаем очень низкое значение вместо NaN для "уничтожения" пустоты
            S.WS.FallenPartsDestroyHeight = -10000000000000000000000000000000000000000000000000000000000000000 -- Очень низкое значение вместо NaN
            Library:Notify('>_< on', 3)
        else
            -- Восстанавливаем оригинальное значение
            S.WS.FallenPartsDestroyHeight = originalFallenPartsDestroyHeight
            Library:Notify('>_< off', 3)
        end
    end,
    Tooltip = '>_<'
})

-- === Silent Aim (Combat tab, новая секция) ===
local SilentAimGroup = Tabs.Combat:AddLeftGroupbox('>_<')

getgenv().SilentAim = {
    Options = {
    Enabled = false,
        Mode = "Nuker",
        StickyKey = Enum.KeyCode.Q,
        AutoAir = false, -- Добавлена новая опция AutoAir
        MagicBullet = false, -- Добавлена опция Magic Bullet
        ViewTarget = false, -- Добавлена опция View Target
        WallBang = false, -- Добавлена опция WallBang (стрельба сквозь стены)
    },
    Silent = {
        PredictionXZ = 0.12362,
        PredictionY = 0.12362,
        Part = "HumanoidRootPart",
        Offsets = {
            Jump = { Amount = 0 },
            Fall = { Amount = 0 },
        },
    },
    Misc = {
        Checks = {
            WallCheck = false,
            TargetDeathCheck = false,
            KOCheck = false,
            GrabbedCheck = false,
            Resolver = {
                Enabled = false,
                Type = "Calculate Cframe",
            },
        },
    },
    MagicBullet = {
        LastShot = 0,
        Cooldown = 0, -- Без задержки между выстрелами
        Range = 10000, -- Максимальная дистанция для Magic Bullet
        IgnoreKO = false, -- Не стрелять в KO цели по умолчанию
        IgnoreGrabbed = false, -- Не стрелять в схваченные цели по умолчанию
        IgnoreForceField = true, -- Не стрелять в цели с форсфилдом по умолчанию
    },
    WallBang = {
        Enabled = false, -- Состояние WallBang
        Ignored = {}, -- Объекты, которые будут игнорироваться при стрельбе
    },
    currentTarget = nil
}

-- UI для Silent Aim
addToggleWithNotify(SilentAimGroup, 'SilentAimEnabled', {
    Text = 'Ragebot',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.Enabled = v 
        
        -- Отключаем соединение для отслеживания выхода игроков, если SilentAim выключен
        if not v and getgenv().SilentAim.PlayerRemovingConnection then
            getgenv().SilentAim.PlayerRemovingConnection:Disconnect()
            getgenv().SilentAim.PlayerRemovingConnection = nil
        elseif v then
            -- Создаем соединение для отслеживания выхода игроков из игры, если оно не существует
            if not getgenv().SilentAim.PlayerRemovingConnection then
                getgenv().SilentAim.PlayerRemovingConnection = S.PS.PlayerRemoving:Connect(function(player)
                    -- Если текущая цель вышла из игры, сбрасываем её
                    if getgenv().SilentAim.currentTarget == player then
                        getgenv().SilentAim.currentTarget = nil
                        
                        -- Если TargetHUD активен, обновляем его
                        if G.TargetHUD and G.TargetHUD.Enabled then
                            getgenv().updateTargetInfo(nil)
                        end
                    end
                end)
            end
        end
    end
})
SilentAimGroup:AddDropdown('SilentAimMode', {
    Text = 'Mode',
    Values = {'Sticky', 'Nuker'},
    Default = 'Nuker',
    Callback = function(v) getgenv().SilentAim.Options.Mode = v end
})
addToggleWithNotify(SilentAimGroup, 'SilentAimAutoAir', {
    Text = 'AutoAir',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.AutoAir = v 
        
        -- Очищаем соединения при отключении AutoAir
        if not v and getgenv().SilentAim.AutoAirConnections then
            for _, conn in ipairs(getgenv().SilentAim.AutoAirConnections) do
                if conn then conn:Disconnect() end
            end
            getgenv().SilentAim.AutoAirConnections = {}
        end
        
        -- Переинициализируем соединения при включении
        if v and getgenv().SilentAim.Options.Enabled then
            -- Если функция уже загружена, вызываем setupAutoAirConnections
            if getgenv().Loaded_SilentAim then
                -- Устанавливаем небольшую задержку для гарантии корректной инициализации
                task.delay(0.1, function()
                    if getgenv().SilentAim and getgenv().SilentAim.setupAutoAirConnections then
                        getgenv().SilentAim.setupAutoAirConnections()
                    end
                end)
            end
        end
    end,
    Tooltip = '>_<'
})

-- Добавляем Magic Bullet
addToggleWithNotify(SilentAimGroup, 'SilentAimMagicBullet', {
    Text = 'MagicBullet',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.MagicBullet = v 
    end,
    Tooltip = '>_<'
})

-- Добавляем View Target
addToggleWithNotify(SilentAimGroup, 'SilentAimViewTarget', {
    Text = 'View',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.ViewTarget = v 
        -- Восстанавливаем камеру при выключении
        if not v then
            if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
                game:GetService("Workspace").CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
            end
        end
    end,
    Tooltip = '>_<'
})

-- Настройки Magic Bullet
local MagicBulletGroup = SilentAimGroup:AddDependencyBox()

MagicBulletGroup:AddSlider('MagicBulletRange', {
    Text = 'Range',
    Default = 10000,
    Min = 100, Max = 10000, Rounding = 0,
    Callback = function(v) 
        getgenv().SilentAim.MagicBullet.Range = tonumber(v) or 10000
    end,
    Tooltip = '>_<'
})

MagicBulletGroup:AddToggle('MagicBulletIgnoreKO', {
    Text = 'IgnoreKO',
    Default = false,
    Callback = function(v) getgenv().SilentAim.MagicBullet.IgnoreKO = v end,
    Tooltip = '>_<'
})

MagicBulletGroup:AddToggle('MagicBulletIgnoreGrabbed', {
    Text = 'IgnoreGrabbed',
    Default = false,
    Callback = function(v) getgenv().SilentAim.MagicBullet.IgnoreGrabbed = v end,
    Tooltip = '>_<'
})

MagicBulletGroup:AddToggle('MagicBulletIgnoreForceField', {
    Text = 'ForceField',
    Default = true,
    Callback = function(v) getgenv().SilentAim.MagicBullet.IgnoreForceField = v end,
    Tooltip = '>_<'
})

MagicBulletGroup:SetupDependencies({{Toggles.SilentAimMagicBullet, true}})
SilentAimGroup:AddInput('SilentAimPredictionXZ', {
    Text = 'PredictionXZ',
    Default = tostring(getgenv().SilentAim.Silent.PredictionXZ),
    Numeric = true,
    Finished = true,
    Callback = function(val) local n = tonumber(val); if n then getgenv().SilentAim.Silent.PredictionXZ = n end end
})
SilentAimGroup:AddInput('SilentAimPredictionY', {
    Text = 'PredictionY',
    Default = tostring(getgenv().SilentAim.Silent.PredictionY),
    Numeric = true,
    Finished = true,
    Callback = function(val) local n = tonumber(val); if n then getgenv().SilentAim.Silent.PredictionY = n end end
})
SilentAimGroup:AddInput('SilentAimJumpOffset', {
    Text = 'JumpOffset',
    Default = tostring(getgenv().SilentAim.Silent.Offsets.Jump.Amount),
    Numeric = true,
    Finished = true,
    Callback = function(val) local n = tonumber(val); if n then getgenv().SilentAim.Silent.Offsets.Jump.Amount = n end end
})
SilentAimGroup:AddInput('SilentAimFallOffset', {
    Text = 'FallOffset',
    Default = tostring(getgenv().SilentAim.Silent.Offsets.Fall.Amount),
    Numeric = true,
    Finished = true,
    Callback = function(val) local n = tonumber(val); if n then getgenv().SilentAim.Silent.Offsets.Fall.Amount = n end end
})
SilentAimGroup:AddLabel('Sticky Key'):AddKeyPicker('SilentAimStickyKey', {
    Default = 'None',
    Text = 'StickyKey',
    NoUI = false,
    Callback = function()
        -- Проверяем, что SilentAim включен и режим установлен на Sticky
        if Toggles.SilentAimEnabled and Toggles.SilentAimEnabled.Value and getgenv().SilentAim and getgenv().SilentAim.Options and getgenv().SilentAim.Options.Mode == "Sticky" then
            -- Если цель уже выбрана, сбрасываем её
            if _G.stickyTarget then
                stickyTarget = nil
                _G.stickyTarget = nil
                Library:Notify(">_< Target released", 2)
                return
            end
            
            -- Получаем новую цель
            local target = nil
            
            -- Пробуем использовать глобальную функцию
            pcall(function()
                if type(_G.getClosestPlayer) == "function" then
                    target = _G.getClosestPlayer()
                end
            end)
            
            if target then
                -- Сохраняем цель как в локальной, так и в глобальной переменной
                stickyTarget = target
                _G.stickyTarget = target
                Library:Notify(">_< Target locked: " .. target.Name, 2)
            else
                Library:Notify(">_< No target found", 2)
            end
        end
    end
})

-- ... существующий UI для Silent Aim ...
SilentAimGroup:AddToggle('SilentAimWallCheck', {
    Text = 'WallCheck',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.WallCheck = v end
})
SilentAimGroup:AddToggle('SilentAimKOCheck', {
    Text = 'KOCheck',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.KOCheck = v end
})
SilentAimGroup:AddToggle('SilentAimGrabbedCheck', {
    Text = 'GrabbedCheck',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.GrabbedCheck = v end
})
SilentAimGroup:AddToggle('SilentAimTargetDeathCheck', {
    Text = 'DeathCheck',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.TargetDeathCheck = v end
})

-- Добавляем тогл для Resolver
SilentAimGroup:AddToggle('SilentAimResolver', {
    Text = 'Resolver',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.Resolver.Enabled = v end
})

SilentAimGroup:AddDropdown('SilentAimResolverType', {
    Text = 'ResolverType',
    Values = {'Calculate Cframe', 'Velocity', 'Move direction'},
    Default = getgenv().SilentAim.Misc.Checks.Resolver.Type,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.Resolver.Type = v end
})

-- Удалили дублирующийся тогл AutoReload

-- Auto Shoot и Auto Reload
-- Создаем утилиты для работы с оружием
getgenv().utility = {
    getHeld = function()
        return LP.Character:FindFirstChildWhichIsA("Tool")
    end,
    target = nil,
    ValidateClient = function(self, player)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player ~= LP then
            return true
        end
        return false
    end
}

-- Настройки
getgenv().flags = {
    ["Auto Shoot"] = false,
    ["Auto Reload"] = false,
    ["Fix Auto Guns"] = false
}

-- Соединения
getgenv().connections = {
    ["auto reload"] = {}
}

-- Функция для создания виртуального клика
getgenv().createVirtualClick = function()
    -- Создаем виртуальный пользовательский ввод, если его еще нет
    if not getgenv().VirtualUser then
        getgenv().VirtualUser = game:GetService("VirtualUser")
    end
    
    -- Делаем клик в правом нижнем углу экрана (где нет интерфейса)
    getgenv().VirtualUser:CaptureController()
    getgenv().VirtualUser:ClickButton1(Vector2.new(900, 900))
end

-- Инициализация глобальных переменных для таймеров
getgenv().virtualClickTimer = 0

-- Функция автоматической перезарядки
getgenv().autoReload = function()
    -- Проверяем наличие цели для стрельбы
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    if not target then return end -- Не перезаряжаем, если нет цели
    
    getgenv().reloadTool = getgenv().utility:getHeld()
    if getgenv().flags["Auto Reload"] and getgenv().reloadTool and getgenv().reloadTool:FindFirstChild("Ammo") then 
        -- Проверяем, что в обойме точно 0 патронов
        if getgenv().reloadTool.Ammo.Value == 0 then
            -- Сразу перезаряжаем оружие
            local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent")
            if mainEvent then
                mainEvent:FireServer("Reload", getgenv().reloadTool)
            else
                -- Если MainEvent не найден, попробуем другие подходы
                pcall(function()
                    -- Пробуем найти MainEvent в других местах
                    for _, service in pairs({game:GetService("ReplicatedStorage"), game:GetService("Players").LocalPlayer, workspace}) do
                        local event = service:FindFirstChild("MainEvent", true)
                        if event then
                            event:FireServer("Reload", getgenv().reloadTool)
                            return
                        end
                    end
                    
                    -- Если всё еще не найден, пытаемся активировать оружие напрямую
                    getgenv().reloadTool:Activate()
                end)
            end
        end
    end 
end

-- Функция установки соединения для отслеживания патронов
getgenv().setupAmmoConnection = function(tool)
    if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
        if not getgenv().connections["auto reload"][tool] then 
            getgenv().connections["auto reload"][tool] = tool.Ammo:GetPropertyChangedSignal("Value"):Connect(getgenv().autoReload)
        end
    end
end

-- Установка соединений для текущего оружия
getgenv().setupAllAmmoConnections = function()
    for _, tool in pairs(LP.Backpack:GetChildren()) do
        getgenv().setupAmmoConnection(tool)
    end

    if LP.Character then
        for _, tool in pairs(LP.Character:GetChildren()) do
            getgenv().setupAmmoConnection(tool)
        end
    end
end

-- Auto Shoot
SilentAimGroup:AddToggle('AutoShoot', {
    Text = 'AutoShoot',
    Default = false,
    Callback = function(v)
        -- Синхронизируем состояние между _G и getgenv().flags
        getgenv().flags["Auto Shoot"] = v
        _G.AutoShoot = v
        
        -- Отключаем предыдущие соединения перед созданием новых
        if getgenv().AutoShootConnection then
            getgenv().AutoShootConnection:Disconnect()
            getgenv().AutoShootConnection = nil
        end
        
        if getgenv().VirtualClickConnection then
            getgenv().VirtualClickConnection:Disconnect()
            getgenv().VirtualClickConnection = nil
        end
        
        if getgenv().characterChildAddedConnection then
            getgenv().characterChildAddedConnection:Disconnect()
            getgenv().characterChildAddedConnection = nil
        end
        
        if getgenv().characterAddedConnection then
            getgenv().characterAddedConnection:Disconnect()
            getgenv().characterAddedConnection = nil
        end
        
        if getgenv().newCharacterChildAddedConnection then
            getgenv().newCharacterChildAddedConnection:Disconnect()
            getgenv().newCharacterChildAddedConnection = nil
        end
        
        if v then
            getgenv().AutoShootConnection = S.RS.RenderStepped:Connect(function()
                -- Проверяем, включен ли тогл AutoShoot
                if not getgenv().flags["Auto Shoot"] then return end
                
                -- Проверяем наличие цели перед выстрелом
                local silentAimTarget = getgenv().SilentAim and getgenv().SilentAim.currentTarget
                if not silentAimTarget then return end -- Не стреляем, если нет цели
                
                -- Проверяем, жив ли игрок
                local hasValidTarget = false
                if silentAimTarget.Character and silentAimTarget.Character:FindFirstChild("Humanoid") and
                   silentAimTarget.Character.Humanoid.Health > 0 then
                    -- Проверяем, не находится ли цель в нокауте
                    local bodyEffects = silentAimTarget.Character:FindFirstChild("BodyEffects")
                    if bodyEffects then
                        local ko = bodyEffects:FindFirstChild("K.O")
                        if ko and ko:IsA("BoolValue") then
                            hasValidTarget = not ko.Value -- Цель валидна, если она НЕ в нокауте
                        else
                            -- Если не можем проверить K.O. статус, считаем цель валидной
                            hasValidTarget = true
                        end
                    else
                        -- Если не можем проверить K.O. статус, считаем цель валидной
                        hasValidTarget = true
                    end
                end
                
                -- Активируем оружие только если есть валидная цель И тогл включен
                if hasValidTarget and getgenv().flags["Auto Shoot"] then
                    getgenv().currentTool = getgenv().utility:getHeld()
                    if getgenv().currentTool then
                        getgenv().currentTool:Activate()
                    end
                end
            end)
            
            -- Сохраняем ссылку на соединение в обеих переменных для совместимости
            _G.AutoShootConnection = getgenv().AutoShootConnection
            
            -- Если включен Fix Auto Guns, запускаем цикл виртуальных кликов
            if getgenv().flags["Fix Auto Guns"] then
                getgenv().VirtualClickConnection = S.RS.Heartbeat:Connect(function()
                    -- Проверяем, включен ли тогл AutoShoot
                    if not getgenv().flags["Auto Shoot"] then return end
                    
                    -- Проверяем наличие цели перед виртуальным кликом
                    local silentAimTarget = getgenv().SilentAim and getgenv().SilentAim.currentTarget
                    if not silentAimTarget then return end -- Не делаем клик, если нет цели
                    
                    getgenv().virtualClickTimer = getgenv().virtualClickTimer or 0
                    if tick() - getgenv().virtualClickTimer >= 1 then  -- Делаем клик каждую секунду
                        getgenv().virtualClickTimer = tick()
                        getgenv().createVirtualClick()
                    end
                end)
            end
            
            -- Настраиваем автоперезарядку при включении автострельбы
            getgenv().setupAllAmmoConnections()
            
            -- Устанавливаем соединение для отслеживания добавления нового оружия
            if LP.Character then
                getgenv().characterChildAddedConnection = LP.Character.ChildAdded:Connect(function(child)
                    getgenv().setupAmmoConnection(child)
                end)
            end
            
            -- Обработка смены персонажа
            getgenv().characterAddedConnection = LP.CharacterAdded:Connect(function(character)
                for tool, connection in pairs(getgenv().connections["auto reload"]) do
                    if connection then
                        connection:Disconnect()
                        getgenv().connections["auto reload"][tool] = nil
                    end
                end
                
                getgenv().newCharacterChildAddedConnection = character.ChildAdded:Connect(function(child)
                    getgenv().setupAmmoConnection(child)
                end)
            end)
        end
        
        Library:Notify(">_< " .. (v and "on" or "off"), 3)
    end,
    Tooltip = '>_<'
})

-- Создаем тогл для Fix Auto Guns, который будет появляться только при включении Auto Shoot
getgenv().FixAutoGunsToggle = SilentAimGroup:AddToggle('FixAutoGuns', {
    Text = 'Fix Auto Guns',
    Default = false,
    Callback = function(v)
        getgenv().flags["Fix Auto Guns"] = v
        
        -- Отключаем цикл виртуальных кликов, если он существует
        if getgenv().VirtualClickConnection then
            getgenv().VirtualClickConnection:Disconnect()
            getgenv().VirtualClickConnection = nil
        end
        
        -- Если включены и AutoShoot, и Fix Auto Guns, запускаем цикл виртуальных кликов
        if getgenv().flags["Auto Shoot"] and getgenv().flags["Fix Auto Guns"] then
            getgenv().VirtualClickConnection = S.RS.Heartbeat:Connect(function()
                -- Проверяем, включен ли тогл AutoShoot
                if not getgenv().flags["Auto Shoot"] then return end
                
                -- Проверяем наличие цели перед виртуальным кликом
                local silentAimTarget = getgenv().SilentAim and getgenv().SilentAim.currentTarget
                if not silentAimTarget then return end -- Не делаем клик, если нет цели
                
                getgenv().virtualClickTimer = getgenv().virtualClickTimer or 0
                if tick() - getgenv().virtualClickTimer >= 1 then  -- Делаем клик каждую секунду
                    getgenv().virtualClickTimer = tick()
                    getgenv().createVirtualClick()
                end
            end)
        end
    end,
    Tooltip = '>_<'
})

-- Auto Reload
SilentAimGroup:AddToggle('AutoReload', {
    Text = 'AutoReload',
    Default = false,
    Callback = function(v)
        -- Синхронизируем состояние между _G и getgenv().flags
        getgenv().flags["Auto Reload"] = v
        _G.AutoReload = v
        
        -- Отключаем предыдущие соединения
        if _G.AutoReloadConnection then
            _G.AutoReloadConnection:Disconnect()
            _G.AutoReloadConnection = nil
        end
        
        -- Отключаем все соединения для автоперезарядки перед созданием новых
        for tool, connection in pairs(getgenv().connections["auto reload"]) do
            if connection then
                connection:Disconnect()
                getgenv().connections["auto reload"][tool] = nil
            end
        end
        
        if v then
            getgenv().setupAllAmmoConnections()
        end
        
        Library:Notify(">_< " .. (v and "on" or "off"), 3)
    end,
    Tooltip = '>_<'
})

-- WallBang настройки
SilentAimGroup:AddToggle('WallBang', {
    Text = 'WallBang',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.WallBang = v
        getgenv().SilentAim.WallBang.Enabled = v
        
        -- Инициализируем игнорируемые объекты при первом включении
        if v and not getgenv().SilentAim.WallBang.Initialized then
            task.spawn(function()
                local Handler = game:FindService("ReplicatedStorage").MainModule
                local Module = require(Handler)
                
                -- Устанавливаем игнорируемые объекты для WallBang
                Module.Ignored = {
                    workspace:WaitForChild("Vehicles"), 
                    workspace:WaitForChild("MAP"), 
                    workspace:WaitForChild("Ignored")
                }
                
                getgenv().SilentAim.WallBang.Ignored = Module.Ignored
                getgenv().SilentAim.WallBang.Initialized = true
            end)
        end
        
        Library:Notify(">_< " .. (v and "on" or "off"), 3)
    end,
    Tooltip = '>_<'
})

-- NoSpread настройки
SilentAimGroup:AddToggle('NoSpread', {
    Text = 'NoSpread',
    Default = SpreadMod.BulletSpread.Enabled,
    Callback = function(v) 
        SpreadMod.BulletSpread.Enabled = v 
        Library:Notify(">_< " .. (v and "on" or "off"), 3)
    end,
    Tooltip = '>_<'
})

-- Слайдер для настройки разброса
SilentAimGroup:AddSlider('SpreadAmount', {
    Text = 'Spread%',
    Default = SpreadMod.BulletSpread.Amount,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(v) SpreadMod.BulletSpread.Amount = v end,
    Tooltip = '>_<'
})

SilentAimGroup:AddDropdown('SilentAimPart', {
    Text = 'Hitpart',
    Values = {'HumanoidRootPart', 'UpperTorso', 'LowerTorso', 'Head'},
    Default = getgenv().SilentAim.Silent.Part,
    Callback = function(v) getgenv().SilentAim.Silent.Part = v end
})

-- === Silent Aim Logic ===
if not getgenv().Loaded_SilentAim then
    getgenv().Loaded_SilentAim = true
    local SilentAim = getgenv().SilentAim
    local Players = S.PS
    local Workspace = S.WS
    local UserInputService = S.UIS
    local LocalPlayer = Players.LocalPlayer
    local Camera = Workspace.CurrentCamera
    local Inf = math.huge
    local NewVector2 = Vector2.new
    local NewCFrame = CFrame.new
    -- Делаем stickyTarget глобальной переменной для доступа из разных частей скрипта
    stickyTarget = nil
    _G.stickyTarget = nil
    
    -- Инициализация Auto Reload и Auto Shoot - синхронизируем _G и getgenv() переменные
    _G.AutoReload = getgenv().flags["Auto Reload"] or false
    _G.AutoReloadConnection = nil
    _G.AutoShoot = getgenv().flags["Auto Shoot"] or false
    _G.AutoShootConnection = getgenv().AutoShootConnection
    local lastPositions, lastUpdateTimes = {}, {}
    
    -- Добавляем соединение для отслеживания выхода игроков из игры
    if SilentAim.PlayerRemovingConnection then
        SilentAim.PlayerRemovingConnection:Disconnect()
    end
    
    SilentAim.PlayerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
        -- Если текущая цель вышла из игры, сбрасываем её
        if SilentAim.currentTarget == player then
            SilentAim.currentTarget = nil
            
            -- Если TargetHUD активен, обновляем его
            if G.TargetHUD and G.TargetHUD.Enabled then
                getgenv().updateTargetInfo(nil)
            end
        end
        
        -- Очищаем кэшированные данные для этого игрока
        local playerId = player.UserId
        if lastPositions[playerId] then
            lastPositions[playerId] = nil
        end
        
        if lastUpdateTimes[playerId] then
            lastUpdateTimes[playerId] = nil
        end
    end)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")

    local function isPlayerAlive(player)
        return player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0
    end
    local function isPlayerGrabbed(player)
        if not player or not player.Character then return false end
        return player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    end
    
    local function hasForceField(player)
        if not player or not player.Character then return false end
        return player.Character:FindFirstChildOfClass("ForceField") ~= nil
    end
    local function isPlayerKO(player)
        if not player or not player.Character then return false end
        local bodyEffects = player.Character:FindFirstChild("BodyEffects")
        if bodyEffects then
            local KO = bodyEffects:FindFirstChild("K.O")
            if KO and KO:IsA("BoolValue") and KO.Value then
                return true
            end
        end
        local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart and humanoidRootPart.Anchored then
            return true
        end
        return false
    end
    local function wallCheck(character)
        -- Если WallBang включен, всегда возвращаем true (игнорируем стены)
        if SilentAim.Options.WallBang then return true end
        
        -- Если проверка стен отключена, тоже возвращаем true
        if not SilentAim.Misc.Checks.WallCheck then return true end
        
        if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
        
        local targetPos = character.HumanoidRootPart.Position
        local cameraPos = Camera.CFrame.Position
        local distance = (targetPos - cameraPos).Magnitude
        local hitPart = Workspace:FindPartOnRayWithIgnoreList(
            Ray.new(cameraPos, (targetPos - cameraPos).Unit * distance),
            { LocalPlayer.Character, character }
        )
        return hitPart == nil
    end
    
    -- Делаем функцию getClosestPlayer доступной глобально
    getgenv().getClosestPlayer = function()
        getgenv().mousePos = UserInputService:GetMouseLocation()
        getgenv().shortestDistance = Inf
        getgenv().closestPlayer = nil
        getgenv().partName = SilentAim.Silent.Part
        
        for _, player in ipairs(Players:GetPlayers()) do
            -- Проверяем isPlayerAlive только если TargetDeathCheck включен
            getgenv().isAliveCheck = not SilentAim.Misc.Checks.TargetDeathCheck or isPlayerAlive(player)
            
            if player ~= LocalPlayer and getgenv().isAliveCheck and
               (not SilentAim.Misc.Checks.KOCheck or not isPlayerKO(player)) and
               (not SilentAim.Misc.Checks.GrabbedCheck or not isPlayerGrabbed(player)) and
               wallCheck(player.Character) then
                getgenv().character = player.Character
                getgenv().part = getgenv().character and getgenv().character:FindFirstChild(getgenv().partName)
                
                if getgenv().part then
                    getgenv().screenPos, getgenv().onScreen = Camera:WorldToViewportPoint(getgenv().part.Position)
                    getgenv().distance = (NewVector2(getgenv().screenPos.X, getgenv().screenPos.Y) - getgenv().mousePos).Magnitude
                    
                    if getgenv().distance < getgenv().shortestDistance and getgenv().onScreen then
                        getgenv().closestPlayer = player
                        getgenv().shortestDistance = getgenv().distance
                    end
                end
            end
        end
        
        -- Устанавливаем цель для автострельбы
        getgenv().utility.target = getgenv().closestPlayer
        
        return getgenv().closestPlayer
    end
    
    -- Сохраняем функцию в глобальной области видимости для доступа из других частей скрипта
    _G.getClosestPlayer = getgenv().getClosestPlayer
    
    local function predictPosition(player)
        if not player.Character or not player.Character:FindFirstChild(SilentAim.Silent.Part) then return nil end
        local aimPart = player.Character[SilentAim.Silent.Part]
        local aimPartPos = aimPart.Position
        local playerId = player.UserId
        if not lastPositions[playerId] or not lastUpdateTimes[playerId] then
            lastPositions[playerId] = aimPartPos
            lastUpdateTimes[playerId] = tick()
            return aimPartPos
        end
        local currentTime = tick()
        local deltaTime = currentTime - lastUpdateTimes[playerId]
        local predictedPos
        local resolverType = SilentAim.Misc.Checks.Resolver.Type
        if resolverType == "Velocity" then
            local velocity = aimPart.Velocity
            predictedPos = aimPartPos + Vector3.new(
                velocity.X * SilentAim.Silent.PredictionXZ,
                velocity.Y * SilentAim.Silent.PredictionY,
                velocity.Z * SilentAim.Silent.PredictionXZ
            )
        elseif resolverType == "Move direction" then
            predictedPos = aimPartPos + (player.Character.Humanoid.MoveDirection * (SilentAim.Silent.PredictionXZ * 10))
        elseif resolverType == "Calculate Cframe" then
            local distance = (aimPartPos - lastPositions[playerId]).Magnitude
            if distance < 0.001 then
                predictedPos = aimPartPos
            else
                local predictedDistance = (distance / deltaTime) * (0.1 * (SilentAim.Silent.PredictionXZ * 10))
                predictedPos = aimPartPos + (aimPartPos - lastPositions[playerId]).Unit * predictedDistance
                local yChange = (aimPartPos.Y - lastPositions[playerId].Y) / deltaTime * (0.1 * SilentAim.Silent.PredictionY)
                predictedPos = predictedPos + Vector3.new(0, yChange, 0)
            end
        end
        lastPositions[playerId] = aimPartPos
        lastUpdateTimes[playerId] = currentTime
        return predictedPos
    end

    -- Добавляем функции для AutoAir
    local function calculateVelocity(player)
        if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return Vector3.new(0, 0, 0)
        end
        return player.Character.HumanoidRootPart.Velocity
    end

    local function getGun(player)
        if not player or not player.Character then return end
        local tool = player.Character:FindFirstChildOfClass("Tool")
        if not tool then return end
        local info = {}
        for _, obj in pairs(tool:GetDescendants()) do
            if obj and obj.Name then
                local name = STR.lower(obj.Name)
                if name:find("ammo") and not name:find("max") and (obj:IsA("IntValue") or obj:IsA("NumberValue")) then
                    info.ammo = obj
                    info.tool = tool
                    return info
                end
            end
        end
    end

    -- Используем дебаунс из таблицы G для AutoAir

    local function autoAir(target)
        if G.autoAirDebounce or not SilentAim.Options.AutoAir or not target or not target.Character then return end
        
        local targetRootPart = target.Character:FindFirstChild("HumanoidRootPart")
        if not targetRootPart then return end
        
        local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        -- Проверяем состояние humanoid или скорость по Y
        local success, isInAir = pcall(function()
            return humanoid:GetState() == Enum.HumanoidStateType.Jumping or 
                   humanoid:GetState() == Enum.HumanoidStateType.Freefall
        end)
        
        if not success then isInAir = false end
        
        local targetVel = calculateVelocity(target)
        local isMovingUp = targetVel.Y > 15
        
        if isInAir or isMovingUp then -- Если цель в воздухе (по состоянию или скорости)
            local character = LocalPlayer.Character
            if not character then return end
            
            local tool = character:FindFirstChildOfClass("Tool")
            if tool then
                G.autoAirDebounce = true
                pcall(function() tool:Activate() end) -- Активировать оружие (выстрел) с защитой
                
                -- Сбрасываем дебаунс через указанное время
                task.delay(G.autoAirDebounceTime, function()
                    G.autoAirDebounce = false
                end)
            end
        end
    end

    -- Настройка соединений для AutoAir (оптимизированная версия)
    local function setupAutoAirConnections()
        -- Используем только один обработчик для текущей цели
        local targetStateConnection = nil
        
        -- Функция для обновления соединения с текущей целью
        local function updateTargetConnection()
            -- Отключаем предыдущее соединение, если оно существует
            if targetStateConnection then 
                targetStateConnection:Disconnect() 
                targetStateConnection = nil
            end
            
            -- Подключаемся только к текущей цели
            if SilentAim.currentTarget and SilentAim.currentTarget.Character then
                local humanoid = SilentAim.currentTarget.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    targetStateConnection = humanoid.StateChanged:Connect(function(_, newState)
                        if SilentAim.Options.AutoAir and 
                          (newState == Enum.HumanoidStateType.Jumping or newState == Enum.HumanoidStateType.Freefall) then
                            autoAir(SilentAim.currentTarget)
                        end
                    end)
                    
                    -- Добавляем соединение в таблицу для последующей очистки
                    SilentAim.AutoAirConnections = SilentAim.AutoAirConnections or {}
                    table.insert(SilentAim.AutoAirConnections, targetStateConnection)
                end
            end
        end
        
        -- Очищаем предыдущие соединения
        if SilentAim.AutoAirConnections then
            for _, conn in ipairs(SilentAim.AutoAirConnections) do
                if conn then conn:Disconnect() end
            end
            SilentAim.AutoAirConnections = {}
        end
        
        -- Обновляем соединение при изменении цели, но с дебаунсом
        local lastTargetUpdateTime = 0
        local targetUpdateDebounce = 0.1 -- 100 мс
        
        local targetChangeConnection = RND:Connect(function()
            if SilentAim.Options.Enabled and SilentAim.Options.AutoAir then
        local now = tick()
                if now - lastTargetUpdateTime > targetUpdateDebounce then
                    lastTargetUpdateTime = now
                    updateTargetConnection()
                end
            end
        end)
        
        -- Очищаем соединения при отключении AutoAir
        SilentAim.AutoAirConnections = SilentAim.AutoAirConnections or {}
        table.insert(SilentAim.AutoAirConnections, targetChangeConnection)
        
        -- Добавляем более редкую проверку вместо проверки каждый кадр
        local checkAutoAirConnection = HRT:Connect(function() -- Используем Heartbeat вместо RenderStepped
            if SilentAim.Options.Enabled and SilentAim.Options.AutoAir and SilentAim.currentTarget then
                local targetChar = SilentAim.currentTarget.Character
                if targetChar then
                    local humanoid = targetChar:FindFirstChildOfClass("Humanoid")
                    if humanoid and (humanoid:GetState() == Enum.HumanoidStateType.Jumping or 
                                    humanoid:GetState() == Enum.HumanoidStateType.Freefall) then
                        autoAir(SilentAim.currentTarget)
                    end
                end
            end
        end)
        
        table.insert(SilentAim.AutoAirConnections, checkAutoAirConnection)
        
        -- Сразу вызываем обновление соединения для текущей цели
        updateTargetConnection()
    end
    
    -- Делаем функцию доступной глобально
    SilentAim.setupAutoAirConnections = setupAutoAirConnections

    RND:Connect(function()
        if not SilentAim.Options.Enabled then
            SilentAim.currentTarget = nil
            return
        end
        local currentTarget = nil
        if SilentAim.Options.Mode == "Sticky" then
            -- Используем глобальную переменную, если она доступна
            local currentStickyTarget = _G.stickyTarget or stickyTarget
            
            -- Проверяем isPlayerAlive только если TargetDeathCheck включен
            local isAliveCheck = currentStickyTarget ~= nil and (not SilentAim.Misc.Checks.TargetDeathCheck or isPlayerAlive(currentStickyTarget))
            
            if currentStickyTarget and isAliveCheck and 
               (not SilentAim.Misc.Checks.KOCheck or not isPlayerKO(currentStickyTarget)) and 
               (not SilentAim.Misc.Checks.GrabbedCheck or not isPlayerGrabbed(currentStickyTarget)) then
                currentTarget = currentStickyTarget
            else
                -- Сбрасываем цель в обеих переменных
                stickyTarget = nil
                _G.stickyTarget = nil
            end
        else 
            currentTarget = getClosestPlayer()
        end
        SilentAim.currentTarget = currentTarget
        
        -- Обработка View Target
        pcall(function()
            -- Проверяем, включен ли ViewTarget и есть ли текущая цель
            if SilentAim.Options.ViewTarget and currentTarget and currentTarget.Character then
                local targetHumanoid = currentTarget.Character:FindFirstChildOfClass("Humanoid")
                if targetHumanoid then
                    game:GetService("Workspace").CurrentCamera.CameraSubject = targetHumanoid
                end
            else
                -- Возвращаем камеру к игроку, если View Target выключен или нет цели
                if LP.Character then
                    local playerHumanoid = LP.Character:FindFirstChildOfClass("Humanoid")
                    if playerHumanoid then
                        game:GetService("Workspace").CurrentCamera.CameraSubject = playerHumanoid
                    end
                end
            end
        end)
        
            -- Проверка AutoAir для текущей цели - ограничиваем частоту вызовов
    if SilentAim.Options.AutoAir and currentTarget and tick() % 0.2 < 0.02 then
        autoAir(currentTarget)
    end
    
    -- Magic Bullet логика
    if SilentAim.Options.MagicBullet and currentTarget and MainEvent then
        -- Убираем проверку задержки, так как она всегда 0
        local now = tick()
        SilentAim.MagicBullet.LastShot = now
            
        -- Проверяем, что цель валидна
        if currentTarget and currentTarget.Character then
            -- Проверка KO, Grabbed и ForceField с учетом настроек
            local isKO = isPlayerKO(currentTarget)
            local isGrabbed = isPlayerGrabbed(currentTarget)
            local hasFF = hasForceField(currentTarget)
            
            -- Если цель в KO, но мы игнорируем KO, или цель не в KO
            local koCheckPassed = (isKO and SilentAim.MagicBullet.IgnoreKO) or (not isKO)
            -- Если цель схвачена, но мы игнорируем Grabbed, или цель не схвачена
            local grabbedCheckPassed = (isGrabbed and SilentAim.MagicBullet.IgnoreGrabbed) or (not isGrabbed)
            -- Если у цели есть форсфилд и мы проверяем форсфилд, то не стреляем
            local ffCheckPassed = (SilentAim.MagicBullet.IgnoreForceField and not hasFF) or (not SilentAim.MagicBullet.IgnoreForceField)
            
            if koCheckPassed and grabbedCheckPassed and ffCheckPassed then
                local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Handle") then
                    -- Проверяем дистанцию
                    local targetHead = currentTarget.Character:FindFirstChild("Head")
                    local targetHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart")
                    
                    if targetHead and targetHRP then
                        local distance = (LocalPlayer.Character.HumanoidRootPart.Position - targetHRP.Position).Magnitude
                        local range = tonumber(SilentAim.MagicBullet.Range) or 5000
                        
                        if distance <= range then
                            -- Не нужно обновлять время последнего выстрела, так как это сделано выше
                            
                            -- Стреляем в цель через MainEvent (без проверки стен)
                            task.spawn(function()
                                local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent")
                                if mainEvent then
                                    mainEvent:FireServer(
                                        "ShootGun",
                                        tool:FindFirstChild("Handle"),
                                        tool:FindFirstChild("Handle").CFrame.Position,
                                        targetHRP.Position,
                                        targetHead,
                                        Vector3.new(0, 0, -1)
                                    )
                                end
                            end)
                        end
                    end
                end
            end
                    end
                end
                
    -- Обновляем LastAimbotTarget для Target Strafe
    if getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled then
        getgenv().TS.Runtime.LastAimbotTarget = currentTarget
    end
    end)
    
    -- Удаляем старый обработчик InputBegan для StickyKey, так как теперь используем KeyPicker
    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    setreadonly(mt, false)
    mt.__index = function(self, key)
        if not checkcaller() and self == LocalPlayer:GetMouse() and SilentAim.Options.Enabled then
            if key == "Hit" or key == "Target" then
                local targetPlayer = SilentAim.currentTarget
                if targetPlayer and targetPlayer.Character then
                    local targetPart = targetPlayer.Character:FindFirstChild(SilentAim.Silent.Part)
                    if targetPart then
                        local finalPos = SilentAim.Misc.Checks.Resolver.Enabled and predictPosition(targetPlayer) or
                            (targetPart.Position + (targetPart.Velocity * SilentAim.Silent.PredictionXZ))
                        if finalPos then
                            local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                            if humanoid then
                                if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                                    finalPos = finalPos + Vector3.new(0, SilentAim.Silent.Offsets.Jump.Amount, 0)
                                elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                                    finalPos = finalPos + Vector3.new(0, SilentAim.Silent.Offsets.Fall.Amount, 0)
                                end
                            end
                            return key == "Hit" and NewCFrame(finalPos) or targetPart
                        end
                    end
                end
            end
        end
        return oldIndex(self, key)
    end
    setreadonly(mt, true)
    local function fixTool(character)
        if character then
            for _, item in ipairs(character:GetChildren()) do
                if item:IsA("Tool") then
                    item.Parent = LocalPlayer:FindFirstChildOfClass("Backpack")
                        break
                    end
                end
        end
    end
    fixTool(LocalPlayer.Character)
    LocalPlayer.CharacterAdded:Connect(fixTool)
    
    -- Инициализация AutoAir соединений
    setupAutoAirConnections()
end

-- ... остальной код ...
-- ... остальной код ...

-- === Crosshair (Visuals tab, right) ===
local CrosshairGroup = Tabs.Visuals:AddRightGroupbox('>_<')

local CrosshairConfig = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255),
    Length = 100,
    Spacing = 5,
    Thickness = 2,
    Rotate = true,
    RotSpeed = 350,
    Outline = false,
    OutlineColor = Color3.fromRGB(0, 0, 0),
    OutlineThickness = 4,
    AttachToTarget = false,
    AttachPart = 'UpperTorso',
    StaticAngle = 0,
}

-- Используем переменные из таблицы G для crosshair

local function destroyCrosshair()
    for _, line in ipairs(G.crosshairLines) do pcall(function() line:Remove() end) end
    for _, line in ipairs(G.crosshairOutlines) do pcall(function() line:Remove() end) end
    G.crosshairLines, G.crosshairOutlines = {}, {}
    if G.crosshairConn then G.crosshairConn:Disconnect() G.crosshairConn = nil end
end

local function createCrosshair()
    destroyCrosshair()
    for i = 1, 4 do
        G.crosshairLines[i] = Drawing.new("Line")
        if CrosshairConfig.Outline then
            G.crosshairOutlines[i] = Drawing.new("Line")
        end
    end
    
    -- Кэшируем математические функции для оптимизации
    local cos, sin, rad = M.cos, M.sin, M.rad
    local lastMousePos = Vector2.new(0, 0)
    local lastTargetPos = Vector2.new(0, 0)
    local lastUpdateTime = 0
    local updateInterval = 1/60 -- Обновление максимум 60 раз в секунду
    
    G.crosshairConn = S.RS.RenderStepped:Connect(function(dt)
        if not CrosshairConfig.Enabled then
            for _, l in ipairs(G.crosshairLines) do l.Visible = false end
            for _, l in ipairs(G.crosshairOutlines) do l.Visible = false end
                return
            end
            
        -- Ограничиваем частоту обновлений
        local now = tick()
        if now - lastUpdateTime < updateInterval then
            return
        end
        lastUpdateTime = now
        
        local mousePos
        if CrosshairConfig.AttachToTarget and getgenv().SilentAim and getgenv().SilentAim.currentTarget then
            local target = getgenv().SilentAim.currentTarget
            if target and target.Character then
                local part = target.Character:FindFirstChild(CrosshairConfig.AttachPart) or target.Character:FindFirstChild('HumanoidRootPart')
                if part then
                    local screenPos, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(part.Position)
                    if onScreen then
                        mousePos = V2.new(screenPos.X, screenPos.Y)
                        -- Проверяем, изменилась ли позиция значительно
                        if (mousePos - lastTargetPos).Magnitude < 1 then
                            mousePos = lastTargetPos -- Используем кэшированную позицию
                        else
                            lastTargetPos = mousePos
                        end
                    end
                end
            end
        end
        
        if not mousePos then
            mousePos = S.UIS:GetMouseLocation()
            -- Проверяем, изменилась ли позиция мыши значительно
            if (mousePos - lastMousePos).Magnitude < 1 then
                mousePos = lastMousePos -- Используем кэшированную позицию
            else
                lastMousePos = mousePos
            end
        end
        
        if CrosshairConfig.Rotate then
            G.crosshairAngle = G.crosshairAngle + CrosshairConfig.RotSpeed * dt
        else
            G.crosshairAngle = CrosshairConfig.StaticAngle
        end
        
        local angle = rad(G.crosshairAngle)
        local cosA, sinA = cos(angle), sin(angle)
        
        local function rot(x, y)
            return V2.new(cosA * x - sinA * y, sinA * x + cosA * y)
        end
        
        local points = {
            {V2.new(0, -CrosshairConfig.Length/2 - CrosshairConfig.Spacing), V2.new(0, -CrosshairConfig.Spacing)},
            {V2.new(0, CrosshairConfig.Spacing), V2.new(0, CrosshairConfig.Length/2 + CrosshairConfig.Spacing)},
            {V2.new(-CrosshairConfig.Length/2 - CrosshairConfig.Spacing, 0), V2.new(-CrosshairConfig.Spacing, 0)},
            {V2.new(CrosshairConfig.Spacing, 0), V2.new(CrosshairConfig.Length/2 + CrosshairConfig.Spacing, 0)}
        }
        
        for i = 1, 4 do
            local startPoint = rot(points[i][1].X, points[i][1].Y)
            local endPoint = rot(points[i][2].X, points[i][2].Y)
            
            if CrosshairConfig.Outline and G.crosshairOutlines[i] then
                local ol = G.crosshairOutlines[i]
                ol.Visible = true
                ol.Thickness = CrosshairConfig.OutlineThickness
                ol.Color = CrosshairConfig.OutlineColor
                ol.From = mousePos + startPoint
                ol.To = mousePos + endPoint
                ol.ZIndex = 0
            elseif G.crosshairOutlines[i] then
                G.crosshairOutlines[i].Visible = false
            end
            
            local l = G.crosshairLines[i]
            l.Visible = true
            l.Thickness = CrosshairConfig.Thickness
            l.Color = CrosshairConfig.Color
            l.From = mousePos + startPoint
            l.To = mousePos + endPoint
            l.ZIndex = 1
        end
    end)
end

addToggleWithNotify(CrosshairGroup, 'CrosshairEnabled', {
    Text = 'Crosshair',
    Default = false,
    Callback = function(v)
        CrosshairConfig.Enabled = v
        if v then createCrosshair() else destroyCrosshair() end
    end
})
:AddColorPicker('CrosshairColor', {
    Default = CrosshairConfig.Color,
    Title = 'Color',
    Callback = function(val) CrosshairConfig.Color = val end
})

CrosshairGroup:AddSlider('CrosshairLength', {
    Text = 'Length',
    Default = CrosshairConfig.Length,
    Min = 10, Max = 300, Rounding = 0,
    Callback = function(val) CrosshairConfig.Length = val end
})
CrosshairGroup:AddSlider('CrosshairSpacing', {
    Text = 'Spacing',
    Default = CrosshairConfig.Spacing,
    Min = 0, Max = 30, Rounding = 0,
    Callback = function(val) CrosshairConfig.Spacing = val end
})
CrosshairGroup:AddSlider('CrosshairThickness', {
    Text = 'Thickness',
    Default = CrosshairConfig.Thickness,
    Min = 1, Max = 10, Rounding = 0,
    Callback = function(val) CrosshairConfig.Thickness = val end
})
CrosshairGroup:AddSlider('CrosshairRotSpeed', {
    Text = 'RotSpeed',
    Default = CrosshairConfig.RotSpeed,
    Min = 0, Max = 1000, Rounding = 0,
    Callback = function(val) CrosshairConfig.RotSpeed = val end
})
addToggleWithNotify(CrosshairGroup, 'CrosshairRotate', {
    Text = 'Spin',
    Default = CrosshairConfig.Rotate,
    Callback = function(v)
        CrosshairConfig.Rotate = v
        if not v then
            G.crosshairAngle = CrosshairConfig.StaticAngle
        end
    end
})
addToggleWithNotify(CrosshairGroup, 'CrosshairOutline', {
    Text = 'Outline',
    Default = CrosshairConfig.Outline,
    Callback = function(v)
        CrosshairConfig.Outline = v
        if CrosshairConfig.Enabled then createCrosshair() end
    end
})
:AddColorPicker('CrosshairOutlineColor', {
    Default = CrosshairConfig.OutlineColor,
    Title = 'Color',
    Callback = function(val) CrosshairConfig.OutlineColor = val end
})
CrosshairGroup:AddSlider('CrosshairOutlineThickness', {
    Text = 'OutlineThick',
    Default = CrosshairConfig.OutlineThickness,
    Min = 1, Max = 20, Rounding = 0,
    Callback = function(val) CrosshairConfig.OutlineThickness = val end
})

addToggleWithNotify(CrosshairGroup, 'CrosshairAttachToTarget', {
    Text = 'AttachTarget',
    Default = false,
    Callback = function(v) CrosshairConfig.AttachToTarget = v end,
    Tooltip = '>_<' 
})
CrosshairGroup:AddDropdown('CrosshairAttachPart', {
    Text = 'Part',
    Values = {'UpperTorso', 'HumanoidRootPart', 'Head', 'LowerTorso'},
    Default = 'UpperTorso',
    Callback = function(val) CrosshairConfig.AttachPart = val end,
    Tooltip = '>_<'
})

CrosshairGroup:AddSlider('CrosshairAngle', {
    Text = 'Angle',
    Default = CrosshairConfig.StaticAngle,
    Min = 0, Max = 360, Rounding = 0,
    Callback = function(val)
        CrosshairConfig.StaticAngle = val
        if not CrosshairConfig.Rotate then
            crosshairAngle = val
        end
    end
})

-- Hotkey for rotate toggle (R)
S.UIS.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.R and not gameProcessed and CrosshairConfig.Enabled then
        CrosshairConfig.Rotate = not CrosshairConfig.Rotate
    end
end)

-- === HitChams (Combat tab, правая секция) ===
-- Делаем конфигурацию глобальной для уменьшения количества локальных переменных
getgenv().HitChamsConfig = {
    Enabled = false,
    Material = Enum.Material.Neon,
    Duration = 2,
    Color = Color3.fromRGB(255, 255, 255), -- белый по умолчанию
    Transparency = 0,
    NoCollision = true, -- Добавляем новую опцию для отключения коллизии
}
local HitChamsConfig = getgenv().HitChamsConfig

-- Список частей тела для HitChams
G.HitChamsBodyParts = {
    "Head", "UpperTorso", "LowerTorso",
    "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand",
    "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot"
}

-- ВОССТАНОВЛЕНИЕ HitChams
local function HitChams(Player, config)
    config = config or HitChamsConfig
    if not config.Enabled or not Player or not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then return end
    
    -- Создаем группу коллизий NoCollision, если она еще не существует
    pcall(function()
        local PhysicsService = game:GetService("PhysicsService")
        if not pcall(function() PhysicsService:GetCollisionGroupName("NoCollision") end) then
            PhysicsService:CreateCollisionGroup("NoCollision")
            PhysicsService:CollisionGroupSetCollidable("NoCollision", "Default", false)
        end
    end)
    
    Player.Character.Archivable = true
    local Cloned = Player.Character:Clone()
    Cloned.Name = "Player Clone"
    
    -- Удаляем ненужные части
    for _, Part in ipairs(Cloned:GetChildren()) do
        if Part:IsA("BasePart") then
            local keep = false
            for _, validPart in ipairs(G.HitChamsBodyParts) do
                if Part.Name == validPart then keep = true; break end
            end
            if not keep then Part:Destroy() end
        elseif Part:IsA("Accessory") or Part:IsA("Tool") or Part.Name == "face" or Part:IsA("Shirt") or Part:IsA("Pants") or Part:IsA("Hat") then
            Part:Destroy()
        end
    end
    
    -- Удаляем гуманоида
    if Cloned:FindFirstChild("Humanoid") then Cloned.Humanoid:Destroy() end
    
    -- Настраиваем части тела с полным отключением физического взаимодействия
    for _, Part in ipairs(Cloned:GetChildren()) do
        if Part:IsA("BasePart") then
            -- Полностью отключаем все виды коллизий и физических взаимодействий
            Part.CanCollide = false
            Part.CanTouch = false
            Part.CanQuery = false
            Part.CollisionGroup = "NoCollision" -- Устанавливаем группу коллизий, которая не взаимодействует с другими
            Part.Massless = true -- Делаем часть без массы
            Part.Anchored = true -- Фиксируем позицию
            
            -- Визуальные настройки
            Part.Transparency = config.Transparency
            Part.Color = config.Color
            Part.Material = config.Material
        end
    end
    
    -- Настраиваем голову отдельно с теми же настройками безопасности
    if Cloned:FindFirstChild("Head") then
        local head = Cloned.Head
        head.Transparency = config.Transparency
        head.Color = config.Color
        head.Material = config.Material
        head.CanCollide = false
        head.CanTouch = false
        head.CanQuery = false
        head.CollisionGroup = "NoCollision"
        head.Massless = true
        head.Size = Vector3.new(0, 0, 0) -- Уменьшаем размер головы до нуля, чтобы избежать застревания
        
        -- Удаляем лицо для лучшего визуального эффекта
        if head:FindFirstChild("face") then head.face:Destroy() end
    end
    
    -- Перемещаем клон в отдельный контейнер для лучшей организации и безопасности
    local container = Instance.new("Folder")
    container.Name = "HitChamsContainer"
    container.Parent = S.WS
    
    -- Дополнительная проверка для всех частей клона перед добавлением в игру
    for _, part in pairs(Cloned:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Size = Vector3.new(part.Size.X * 0.9, part.Size.Y * 0.9, part.Size.Z * 0.9) -- Уменьшаем размер всех частей
            part.Position = part.Position + Vector3.new(0, 0.1, 0) -- Немного смещаем вверх, чтобы избежать застревания
        end
    end
    
    Cloned.Parent = container
    
    -- Настраиваем анимацию
    local tweenInfo = TweenInfo.new(config.Duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, true)
    
    -- Анимируем все части
    for _, Part in ipairs(Cloned:GetChildren()) do
        if Part:IsA("BasePart") then 
            S.TS:Create(Part, tweenInfo, {Transparency = 1}):Play() 
        end
    end
    
    -- Удаляем после окончания анимации весь контейнер
    task.delay(config.Duration, function() 
        if container and container.Parent then 
            container:Destroy() 
        end 
    end)
    
    -- Дополнительная защита: удаляем хитчамсы при движении игрока, чтобы избежать застревания
    task.spawn(function()
        local hrp = Player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local lastPos = hrp.Position
            
            -- Проверяем движение каждые 0.1 секунд
            for i = 1, 20 do -- Максимум 2 секунды проверок
                task.wait(0.1)
                if not hrp or not hrp.Parent then break end
                if not container or not container.Parent then break end
                
                -- Если игрок переместился более чем на 3 единицы, удаляем хитчамсы
                if (hrp.Position - lastPos).Magnitude > 3 then
                    if container and container.Parent then container:Destroy() end
                    break
                end
                
                lastPos = hrp.Position
            end
        end 
    end)
end

-- === HitSounds (инлайн-модуль) ===
-- Делаем конфигурацию глобальной для уменьшения количества локальных переменных
getgenv().HitSoundsConfig = {
    Enabled = false,
    Sound = "Bameware",
    Volume = 1,
}
local HitSoundsConfig = getgenv().HitSoundsConfig
-- Делаем таблицу звуков глобальной
getgenv().hitsounds = {
    ["RIFK7"]        = "rbxassetid://9102080552",
    ["Bubble"]       = "rbxassetid://6534947588",
    ["Minecraft"]    = "rbxassetid://8837706727",
    ["Cod"]          = "rbxassetid://160432334",
    ["Bameware"]     = "rbxassetid://3124331820",
    ["Neverlose"]    = "rbxassetid://6534948092",
    ["Gamesense"]    = "rbxassetid://4817809188",
    ["Rust"]         = "rbxassetid://1255040462",
    ["Bruh"]         = "rbxassetid://4578740568",
    ["Bell"]         = "rbxassetid://6534947240",
    ["Pick"]         = "rbxassetid://1347140027",
    ["Pop"]          = "rbxassetid://198598793",
    ["Sans"]         = "rbxassetid://3188795283",
    ["Fart"]         = "rbxassetid://130833677",
    ["Big"]          = "rbxassetid://5332005053",
    ["Vine"]         = "rbxassetid://5332680810",
    ["Fatality"]     = "rbxassetid://6534947869",
    ["Bonk"]         = "rbxassetid://5766898159",
    ["Totem"]        = "rbxassetid://135055101757201",
    ["CSHS"]         = "rbxassetid://9065951723"
}
local hitsounds = getgenv().hitsounds
local function PlayHitSound(config)
    config = config or HitSoundsConfig
    if not config.Enabled then return end
    
    local sound = Instance.new("Sound")
    sound.SoundId = hitsounds[config.Sound] or ""
    sound.Volume = config.Volume or 1
    sound.Parent = S.SS
    sound:Play()
    sound.Ended:Connect(function() sound:Destroy() end)
end

local HitChamsGroup = Tabs.Combat:AddRightGroupbox('>_<')
local HitChamsToggle = addToggleWithNotify(HitChamsGroup, 'HitChamsEnabled', {
    Text = 'Chams',
    Default = false,
    Callback = function(v) HitChamsConfig.Enabled = v end,
    Tooltip = '>_<'
})
:AddColorPicker('HitChamsColor', {
    Default = Color3.fromRGB(255,255,255), -- белый по умолчанию
    Title = 'Color',
    Callback = function(val) HitChamsConfig.Color = val end
})

-- Тоггл и саббокс для HitSounds
local HitSoundsToggle = addToggleWithNotify(HitChamsGroup, 'HitSoundsEnabled', {
    Text = 'Sounds',
    Default = false,
    Callback = function(v) HitSoundsConfig.Enabled = v end,
    Tooltip = '>_<'
})
local HitSoundsSub = HitChamsGroup:AddDependencyBox()
HitSoundsSub:AddDropdown('HitSoundsSound', {
    Text = 'Sound',
    Values = (function() local t = {}; for k in pairs(hitsounds) do T.insert(t, k) end; T.sort(t); return t end)(),
    Default = HitSoundsConfig.Sound,
    Callback = function(val) HitSoundsConfig.Sound = val end
})
HitSoundsSub:AddSlider('HitSoundsVolume', {
    Text = 'Volume',
    Default = HitSoundsConfig.Volume,
    Min = 0, Max = 3, Rounding = 2,
    Callback = function(val) HitSoundsConfig.Volume = val end
})
HitSoundsSub:SetupDependencies({{Toggles.HitSoundsEnabled, true}})

-- Логика: отслеживание уменьшения HP у цели аимбота
local lastTarget, lastHP
RND:Connect(function()
    if not HitChamsConfig.Enabled and not HitSoundsConfig.Enabled then
        lastTarget, lastHP = nil, nil
        return
    end
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    if target and target.Character and target.Character:FindFirstChild('Humanoid') then
        local hum = target.Character.Humanoid
        local hp = hum.Health
        if lastTarget ~= target then
            lastTarget = target
            lastHP = hp
        else
            if hp < lastHP then
                if HitChamsConfig.Enabled then
                    HitChams(target, HitChamsConfig)
                end
                if HitSoundsConfig.Enabled then
                    PlayHitSound(HitSoundsConfig)
                end
            end
            lastHP = hp
        end
    else
        lastTarget, lastHP = nil, nil
        end
    end)
    
-- === TargetHUD (Combat tab, новая секция) ===
getgenv().TargetHUDGroup = Tabs.Combat:AddRightGroupbox('>_<')

-- Глобальные настройки для TargetHUD
getgenv().G.TargetHUD = {
    Enabled = false,
    ScreenGui = nil,
    MainContainer = nil,
    CurrentTarget = nil,
    LastTarget = nil,
    Connection = nil,
    NoTargetImage = "rbxassetid://7648350113",
    HealthTween = nil, -- Для плавной анимации HP бара
    -- Фиксированные настройки без возможности изменения
    Opacity = 0.8,
    Scale = 1
}

-- Функция для создания интерфейса TargetHUD
getgenv().createTargetHUD = function()
    -- Удаляем предыдущий интерфейс, если он существует
    if G.TargetHUD.ScreenGui then
        G.TargetHUD.ScreenGui:Destroy()
    end
    
    -- Создание интерфейса
    G.TargetHUD.ScreenGui = Instance.new("ScreenGui")
    G.TargetHUD.ScreenGui.Name = "TargetHUD"
    G.TargetHUD.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    G.TargetHUD.ScreenGui.ResetOnSpawn = false
    G.TargetHUD.ScreenGui.DisplayOrder = 999 -- Устанавливаем высокий DisplayOrder чтобы был поверх других GUI
    G.TargetHUD.ScreenGui.Parent = LP.PlayerGui
    
    -- Основной контейнер
    G.TargetHUD.MainContainer = Instance.new("Frame")
    G.TargetHUD.MainContainer.Name = "MainContainer"
    G.TargetHUD.MainContainer.BackgroundColor3 = Library.MainColor
    G.TargetHUD.MainContainer.BackgroundTransparency = 1 - G.TargetHUD.Opacity
    G.TargetHUD.MainContainer.BorderColor3 = Library.OutlineColor
    G.TargetHUD.MainContainer.BorderSizePixel = 1
    G.TargetHUD.MainContainer.Position = U2.new(0.5, -150, 0.7, 0)
    G.TargetHUD.MainContainer.Size = U2.new(0, 300 * G.TargetHUD.Scale, 0, 100 * G.TargetHUD.Scale)
    G.TargetHUD.MainContainer.AnchorPoint = V2.new(0.5, 0)
    G.TargetHUD.MainContainer.Active = true
    G.TargetHUD.MainContainer.Draggable = true
    G.TargetHUD.MainContainer.Parent = G.TargetHUD.ScreenGui
    
    -- Аватарка
    G.TargetHUD.AvatarContainer = Instance.new("Frame")
    G.TargetHUD.AvatarContainer.Name = "AvatarContainer"
    G.TargetHUD.AvatarContainer.BackgroundColor3 = Library.MainColor
    G.TargetHUD.AvatarContainer.BackgroundTransparency = 0.3
    G.TargetHUD.AvatarContainer.BorderColor3 = Library.OutlineColor
    G.TargetHUD.AvatarContainer.BorderSizePixel = 1
    G.TargetHUD.AvatarContainer.Position = U2.new(0.05, 0, 0.2, 0)
    G.TargetHUD.AvatarContainer.Size = U2.new(0, 60 * G.TargetHUD.Scale, 0, 60 * G.TargetHUD.Scale)
    G.TargetHUD.AvatarContainer.Visible = true -- Всегда показываем аватар
    G.TargetHUD.AvatarContainer.ZIndex = 2
    G.TargetHUD.AvatarContainer.Parent = G.TargetHUD.MainContainer
    
    G.TargetHUD.AvatarImage = Instance.new("ImageLabel")
    G.TargetHUD.AvatarImage.Name = "AvatarImage"
    G.TargetHUD.AvatarImage.BackgroundTransparency = 1
    G.TargetHUD.AvatarImage.Size = U2.new(1, 0, 1, 0)
    G.TargetHUD.AvatarImage.Image = G.TargetHUD.NoTargetImage
    G.TargetHUD.AvatarImage.ScaleType = Enum.ScaleType.Crop
    G.TargetHUD.AvatarImage.ZIndex = 3
    G.TargetHUD.AvatarImage.Parent = G.TargetHUD.AvatarContainer
    
    -- Информация о цели
    G.TargetHUD.InfoContainer = Instance.new("Frame")
    G.TargetHUD.InfoContainer.Name = "InfoContainer"
    G.TargetHUD.InfoContainer.BackgroundTransparency = 1
    G.TargetHUD.InfoContainer.Position = U2.new(0.3, 0, 0.2, 0)
    G.TargetHUD.InfoContainer.Size = U2.new(0.65, -10, 0, 60 * G.TargetHUD.Scale)
    G.TargetHUD.InfoContainer.ZIndex = 2
    G.TargetHUD.InfoContainer.Parent = G.TargetHUD.MainContainer
    
    G.TargetHUD.UsernameLabel = Instance.new("TextLabel")
    G.TargetHUD.UsernameLabel.Name = "UsernameLabel"
    G.TargetHUD.UsernameLabel.BackgroundTransparency = 1
    G.TargetHUD.UsernameLabel.Size = U2.new(1, 0, 0.4, 0)
    G.TargetHUD.UsernameLabel.Font = Library.Font
    G.TargetHUD.UsernameLabel.Text = "No target"
    G.TargetHUD.UsernameLabel.TextColor3 = Library.FontColor
    G.TargetHUD.UsernameLabel.TextSize = 16
    G.TargetHUD.UsernameLabel.TextXAlignment = Enum.TextXAlignment.Left
    G.TargetHUD.UsernameLabel.TextTruncate = Enum.TextTruncate.AtEnd
    G.TargetHUD.UsernameLabel.ZIndex = 3
    G.TargetHUD.UsernameLabel.Parent = G.TargetHUD.InfoContainer
    
    -- Полоса здоровья в стиле UI Library
    G.TargetHUD.HealthContainer = Instance.new("Frame")
    G.TargetHUD.HealthContainer.Name = "HealthContainer"
    G.TargetHUD.HealthContainer.BackgroundColor3 = Library.BackgroundColor
    G.TargetHUD.HealthContainer.BorderColor3 = Library.OutlineColor
    G.TargetHUD.HealthContainer.BorderSizePixel = 1
    G.TargetHUD.HealthContainer.Position = U2.new(0, 0, 0.6, 5)
    G.TargetHUD.HealthContainer.Size = U2.new(1, 0, 0.3, 0)
    G.TargetHUD.HealthContainer.ZIndex = 3
    G.TargetHUD.HealthContainer.Parent = G.TargetHUD.InfoContainer
    
    G.TargetHUD.HealthBar = Instance.new("Frame")
    G.TargetHUD.HealthBar.Name = "HealthBar"
    G.TargetHUD.HealthBar.BackgroundColor3 = Library.AccentColor
    G.TargetHUD.HealthBar.BorderSizePixel = 0
    G.TargetHUD.HealthBar.Size = U2.new(1, 0, 1, 0)
    G.TargetHUD.HealthBar.ZIndex = 4
    G.TargetHUD.HealthBar.Parent = G.TargetHUD.HealthContainer
    
    G.TargetHUD.HealthText = Instance.new("TextLabel")
    G.TargetHUD.HealthText.Name = "HealthText"
    G.TargetHUD.HealthText.BackgroundTransparency = 1
    G.TargetHUD.HealthText.Size = U2.new(1, 0, 1, 0)
    G.TargetHUD.HealthText.Font = Library.Font
    G.TargetHUD.HealthText.Text = "100%"
    G.TargetHUD.HealthText.TextColor3 = Library.FontColor
    G.TargetHUD.HealthText.TextSize = 14
    G.TargetHUD.HealthText.TextStrokeTransparency = 0.7
    G.TargetHUD.HealthText.TextYAlignment = Enum.TextYAlignment.Center
    G.TargetHUD.HealthText.TextXAlignment = Enum.TextXAlignment.Center -- Центрируем текст по горизонтали
    G.TargetHUD.HealthText.ZIndex = 5
    G.TargetHUD.HealthText.Parent = G.TargetHUD.HealthContainer
    
    -- Скрываем интерфейс по умолчанию
    G.TargetHUD.MainContainer.Visible = false
    
    -- Применяем текущую тему
    task.spawn(function()
        task.wait() -- Небольшая задержка для уверенности, что все элементы созданы
        getgenv().updateTargetHUDTheme()
    end)
    
    return G.TargetHUD.ScreenGui, G.TargetHUD.MainContainer
end

-- Функция для обновления информации о цели
getgenv().updateTargetInfo = function(player)
    -- Оборачиваем всю функцию в pcall для предотвращения ошибок
    pcall(function()
        if not G or not G.TargetHUD or not G.TargetHUD.MainContainer then return end
    
    -- Анимация появления/исчезновения
    if player ~= G.TargetHUD.LastTarget then
        if player then
            G.TargetHUD.MainContainer.Visible = true
            G.TargetHUD.MainContainer.BackgroundTransparency = 1
            S.TS:Create(G.TargetHUD.MainContainer, TweenInfo.new(0.3), {BackgroundTransparency = 1 - G.TargetHUD.Opacity}):Play()
        else
            S.TS:Create(G.TargetHUD.MainContainer, TweenInfo.new(0.3), {BackgroundTransparency = 1}):Play()
            task.delay(0.3, function()
                    if G and G.TargetHUD and G.TargetHUD.CurrentTarget == nil and G.TargetHUD.MainContainer then
                    G.TargetHUD.MainContainer.Visible = false
                end
            end)
        end
    end
    
        -- Продолжаем обработку внутри pcall
        if player and player.Character and player.Parent then
        -- Никнейм
            pcall(function()
                local displayName = player.DisplayName
                if displayName and displayName ~= "" then
                    G.TargetHUD.MainContainer.InfoContainer.UsernameLabel.Text = tostring(displayName)
                else
                    G.TargetHUD.MainContainer.InfoContainer.UsernameLabel.Text = tostring(player.Name) or "Unknown"
                end
            end)
        
        -- Аватарка
            pcall(function()
                local userId = player and player.UserId
                if userId and type(userId) == "number" then
                    G.TargetHUD.MainContainer.AvatarContainer.AvatarImage.Image = "https://www.roblox.com/headshot-thumbnail/image?userId="..tostring(userId).."&width=420&height=420&format=png"
                else
                    G.TargetHUD.MainContainer.AvatarContainer.AvatarImage.Image = G.TargetHUD.NoTargetImage
                end
            end)
        
        -- Здоровье с плавной анимацией
            pcall(function()
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local healthPercent = humanoid.Health / humanoid.MaxHealth
            
            -- Отменяем предыдущую анимацию, если она есть
            if G.TargetHUD.HealthTween and G.TargetHUD.HealthTween.PlaybackState == Enum.PlaybackState.Playing then
                G.TargetHUD.HealthTween:Cancel()
            end
            
            -- Создаем новую анимацию с задержкой для плавности
            G.TargetHUD.HealthTween = S.TS:Create(
                G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, 
                TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
                {Size = U2.new(healthPercent, 0, 1, 0)}
            )
            G.TargetHUD.HealthTween:Play()
            
            -- Обновляем текст здоровья
            G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthText.Text = STR.fmt("%d%%", M.floor(healthPercent * 100))
            
            -- Изменение цвета в зависимости от здоровья, используя цвет акцента из библиотеки
            local healthColor = Library.AccentColor:Lerp(
                C3.fromRGB(255, 50, 50),
                (1 - healthPercent) * 0.7
            )
            
            -- Плавно меняем цвет
            S.TS:Create(
                G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, 
                TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
                {BackgroundColor3 = healthColor}
            ):Play()
        end
            end)
    else
            pcall(function()
                if G.TargetHUD and G.TargetHUD.MainContainer and G.TargetHUD.MainContainer.InfoContainer then
        G.TargetHUD.MainContainer.InfoContainer.UsernameLabel.Text = "No target"
        G.TargetHUD.MainContainer.AvatarContainer.AvatarImage.Image = G.TargetHUD.NoTargetImage
        S.TS:Create(G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, TweenInfo.new(0.3), {Size = U2.new(0, 0, 1, 0)}):Play()
        G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthText.Text = "0%"
                end
            end)
    end
    
    G.TargetHUD.LastTarget = player
    G.TargetHUD.CurrentTarget = player
    end)
end

-- Функция для включения/отключения TargetHUD
getgenv().toggleTargetHUD = function(enabled)
    -- Оборачиваем всю функцию в pcall для предотвращения ошибок
    pcall(function()
        if not G or not G.TargetHUD then return end
        
    G.TargetHUD.Enabled = enabled
    
    if enabled then
        -- Создаем интерфейс, если его еще нет
        if not G.TargetHUD.ScreenGui then
            getgenv().createTargetHUD()
        end
        
        -- Устанавливаем соединение для обновления информации о цели
        if G.TargetHUD.Connection then
            G.TargetHUD.Connection:Disconnect()
                    G.TargetHUD.Connection = nil
        end
        
        -- Отключаем соединение для отслеживания выхода игроков, если оно есть
        if G.TargetHUD.PlayerRemoving then
            G.TargetHUD.PlayerRemoving:Disconnect()
                    G.TargetHUD.PlayerRemoving = nil
        end
        
        -- Создаем соединение для отслеживания выхода игроков из игры
        G.TargetHUD.PlayerRemoving = S.PS.PlayerRemoving:Connect(function(player)
                pcall(function()
            -- Если текущая цель вышла из игры, сбрасываем TargetHUD
                    if G and G.TargetHUD and G.TargetHUD.CurrentTarget == player then
                getgenv().updateTargetInfo(nil)
                
                -- Если SilentAim использует этого игрока как цель, сбрасываем и его
                if getgenv().SilentAim and getgenv().SilentAim.currentTarget == player then
                    getgenv().SilentAim.currentTarget = nil
                end
            end
                end)
        end)
        
        G.TargetHUD.Connection = S.RS.Heartbeat:Connect(function()
                pcall(function()
                    if not G or not G.TargetHUD then return end
                    
            local currentTarget = getgenv().SilentAim and getgenv().SilentAim.currentTarget
            
            -- Проверяем, что цель существует и находится в игре
                        if currentTarget then
                            -- Проверяем, что игрок существует
                            if not currentTarget.Parent or not S.PS:FindFirstChild(currentTarget.Name) then
                currentTarget = nil
                if getgenv().SilentAim then
                    getgenv().SilentAim.currentTarget = nil
                                end
                end
            end
            
            if currentTarget ~= G.TargetHUD.CurrentTarget then
                getgenv().updateTargetInfo(currentTarget)
            end
            
            -- Обновляем здоровье цели, если она изменилась
            if currentTarget and currentTarget.Character then
                local humanoid = currentTarget.Character:FindFirstChildOfClass("Humanoid")
                if humanoid and G.TargetHUD.MainContainer and G.TargetHUD.MainContainer.Visible then
                    local healthPercent = humanoid.Health / humanoid.MaxHealth
                    
                    -- Отменяем предыдущую анимацию, если она есть
                    if G.TargetHUD.HealthTween and G.TargetHUD.HealthTween.PlaybackState == Enum.PlaybackState.Playing then
                        G.TargetHUD.HealthTween:Cancel()
                    end
                    
                    -- Создаем новую анимацию с задержкой для плавности
                    G.TargetHUD.HealthTween = S.TS:Create(
                        G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, 
                        TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
                        {Size = U2.new(healthPercent, 0, 1, 0)}
                    )
                    G.TargetHUD.HealthTween:Play()
                    
                    G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthText.Text = STR.fmt("%d%%", M.floor(healthPercent * 100))
                    
                    -- Изменение цвета в зависимости от здоровья, используя цвет акцента из библиотеки
                    local healthColor = Library.AccentColor:Lerp(
                        C3.fromRGB(255, 50, 50),
                        (1 - healthPercent) * 0.7
                    )
                    
                    -- Плавно меняем цвет
                    S.TS:Create(
                        G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, 
                        TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
                        {BackgroundColor3 = healthColor}
                    ):Play()
                end
            end
                end)
        end)
    else
        -- Отключаем соединения
        if G.TargetHUD.Connection then
            G.TargetHUD.Connection:Disconnect()
            G.TargetHUD.Connection = nil
        end
        
        if G.TargetHUD.PlayerRemoving then
            G.TargetHUD.PlayerRemoving:Disconnect()
            G.TargetHUD.PlayerRemoving = nil
        end
        
        -- Скрываем интерфейс
        if G.TargetHUD.MainContainer then
            G.TargetHUD.MainContainer.Visible = false
        end
        
        G.TargetHUD.CurrentTarget = nil
        G.TargetHUD.LastTarget = nil
    end
    end)
end

-- Добавляем toggle для включения/выключения TargetHUD
local TargetHUDToggle = addToggleWithNotify(getgenv().TargetHUDGroup, 'TargetHUD', {
    Text = 'TargetHUD',
    Default = false,
    Callback = function(v)
        getgenv().toggleTargetHUD(v)
    end,
    Tooltip = 'Отображает информацию о цели аимбота'
})

-- === Combat Tracer (трейсер до цели) ===
-- Делаем конфигурацию глобальной
getgenv().CombatTracerConfig = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
}
local CombatTracerConfig = getgenv().CombatTracerConfig
getgenv().combatTracerLine = nil
local combatTracerLine = getgenv().combatTracerLine

addToggleWithNotify(HitChamsGroup, 'CombatTracerEnabled', {
    Text = 'Tracer',
    Default = false,
    Callback = function(v)
        CombatTracerConfig.Enabled = v
        if not v and combatTracerLine then
            combatTracerLine.Visible = false
    end
end
}):AddColorPicker('CombatTracerColor', {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
    Title = 'Color',
    Callback = function(val)
        CombatTracerConfig.Color = val
        if combatTracerLine then
            combatTracerLine.Color = val
        end
    end
})

-- Логика отрисовки трейсеров
-- Используем переменные из таблицы G вместо локальных

HRT:Connect(function() -- Используем Heartbeat вместо RenderStepped
    if not CombatTracerConfig.Enabled then
        if combatTracerLine then
            combatTracerLine.Visible = false
        end
        return
    end
    
    -- Ограничиваем частоту обновлений
    local now = tick()
    if now - G.lastTracerUpdate < G.tracerUpdateInterval then
        return
    end
    G.lastTracerUpdate = now
    
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    if target and target.Character then
        local torso = target.Character:FindFirstChild('UpperTorso') or target.Character:FindFirstChild('HumanoidRootPart')
        if torso then
            local screenPos, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(torso.Position)
            if onScreen then
                local mousePos = S.UIS:GetMouseLocation()
                if not combatTracerLine then
                    combatTracerLine = Drawing.new('Line')
                    combatTracerLine.Thickness = 2
                    combatTracerLine.Color = CombatTracerConfig.Color
                    combatTracerLine.ZIndex = 10000
                end
                combatTracerLine.From = mousePos
                combatTracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
                combatTracerLine.Color = CombatTracerConfig.Color
                combatTracerLine.Visible = true
            else
                if combatTracerLine then
                    combatTracerLine.Visible = false
                end
            end
        else
            if combatTracerLine then
                combatTracerLine.Visible = false
            end
        end
    else
        if combatTracerLine then
            combatTracerLine.Visible = false
        end
    end
end)

-- 2. Добавить тоггл и дропдаун для HitEffects
local HitEffectsConfig = {
    Enabled = false,
    Type = 'Nova',
    Color = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
}
local hitEffectsTypes = {'Nova', 'Crescent Slash', 'Coom', 'Cosmic Explosion', 'Slash', 'Atomic Slash'}

-- Настройки для Highlight
local HighlightConfig = {
    Enabled = false,
    OutlineColor = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
    FillColor = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
    OutlineTransparency = 0, -- непрозрачный контур
    FillTransparency = 0.5, -- полупрозрачная заливка
    CurrentHighlight = nil
}
local HitEffectsToggle = addToggleWithNotify(HitChamsGroup, 'HitEffectsEnabled', {
    Text = 'HitEffects',
    Default = false,
    Callback = function(v) HitEffectsConfig.Enabled = v end,
    Tooltip = '>_<'
})
:AddColorPicker('HitEffectsColor', {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
    Title = 'Color',
    Callback = function(val) HitEffectsConfig.Color = val end
})
local HitEffectsSub = HitChamsGroup:AddDependencyBox()
HitEffectsSub:AddDropdown('HitEffectsType', {
    Text = 'EffectType',
    Values = hitEffectsTypes,
    Default = HitEffectsConfig.Type,
    Callback = function(val) HitEffectsConfig.Type = val end
})
HitEffectsSub:SetupDependencies({{Toggles.HitEffectsEnabled, true}})

-- Добавляем HitNotifications
local HitNotificationsConfig = {
    Enabled = false,
    Duration = 2,
    ShowDamage = true,
    ShowRemaining = true
}

local HitNotificationsToggle = addToggleWithNotify(HitChamsGroup, 'HitNotificationsEnabled', {
    Text = 'HitNotifications',
    Default = false,
    Callback = function(v) HitNotificationsConfig.Enabled = v end,
    Tooltip = '>_<'
})

local HitNotificationsSub = HitChamsGroup:AddDependencyBox()
HitNotificationsSub:AddSlider('HitNotificationsDuration', {
    Text = 'Duration',
    Default = HitNotificationsConfig.Duration,
    Min = 1, Max = 5, Rounding = 0,
    Callback = function(val) HitNotificationsConfig.Duration = val end
})
HitNotificationsSub:AddToggle('HitNotificationsShowDamage', {
    Text = 'Show Damage',
    Default = HitNotificationsConfig.ShowDamage,
    Callback = function(v) HitNotificationsConfig.ShowDamage = v end
})
HitNotificationsSub:AddToggle('HitNotificationsShowRemaining', {
    Text = 'Show HP',
    Default = HitNotificationsConfig.ShowRemaining,
    Callback = function(v) HitNotificationsConfig.ShowRemaining = v end
})
HitNotificationsSub:SetupDependencies({{Toggles.HitNotificationsEnabled, true}})

-- Добавляем Highlight
addToggleWithNotify(HitChamsGroup, 'HighlightEnabled', {
    Text = 'Highlight',
    Default = false,
    Callback = function(v) 
        HighlightConfig.Enabled = v 
        
        -- Удаляем существующий хайлайт при выключении
        if not v and HighlightConfig.CurrentHighlight then
            pcall(function()
                HighlightConfig.CurrentHighlight:Destroy()
                HighlightConfig.CurrentHighlight = nil
            end)
        end
    end,
    Tooltip = '>_<'
}):AddColorPicker('HighlightOutlineColor', {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
    Title = 'Outline',
    Callback = function(val) 
        HighlightConfig.OutlineColor = val 
        -- Обновляем цвет, если хайлайт активен
        if HighlightConfig.CurrentHighlight then
            HighlightConfig.CurrentHighlight.OutlineColor = val
        end
    end
}):AddColorPicker('HighlightFillColor', {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет по умолчанию
    Title = 'Fill',
    Callback = function(val) 
        HighlightConfig.FillColor = val 
        -- Обновляем цвет, если хайлайт активен
        if HighlightConfig.CurrentHighlight then
            HighlightConfig.CurrentHighlight.FillColor = val
        end
    end
})

local HighlightSub = HitChamsGroup:AddDependencyBox()

-- Добавляем слайдеры для прозрачности
HighlightSub:AddSlider('HighlightOutlineTransparency', {
    Text = 'Outline Transparency',
    Default = HighlightConfig.OutlineTransparency,
    Min = 0, Max = 1, Rounding = 2,
    Callback = function(val) 
        HighlightConfig.OutlineTransparency = val 
        -- Обновляем прозрачность, если хайлайт активен
        if HighlightConfig.CurrentHighlight then
            HighlightConfig.CurrentHighlight.OutlineTransparency = val
        end
    end
})

HighlightSub:AddSlider('HighlightFillTransparency', {
    Text = 'Fill Transparency',
    Default = HighlightConfig.FillTransparency,
    Min = 0, Max = 1, Rounding = 2,
    Callback = function(val) 
        HighlightConfig.FillTransparency = val 
        -- Обновляем прозрачность, если хайлайт активен
        if HighlightConfig.CurrentHighlight then
            HighlightConfig.CurrentHighlight.FillTransparency = val
        end
    end
})

HighlightSub:SetupDependencies({{Toggles.HighlightEnabled, true}})

-- 3. Загрузка библиотеки эффектов (один раз)
G.HitEffectsLib = nil
G.hitEffectsLoading = false
local function getHitEffectsLib()
    if G.HitEffectsLib then return G.HitEffectsLib end
    if G.hitEffectsLoading then return nil end
    
    G.hitEffectsLoading = true
    task.spawn(function()
        pcall(function()
            G.HitEffectsLib = loadstring(game:HttpGet('https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/effects'))()
        end)
        G.hitEffectsLoading = false
    end)
    
    return nil
end

-- 4. Вызов эффекта при уроне цели (в том же месте, где HitChams/HitSounds)
local lastTarget, lastHP = nil, nil
-- Используем G.lastDamageTick вместо локальной переменной

-- Функция для управления хайлайтом цели
G.updateHighlight = function(target)
    -- Если хайлайт выключен, удаляем существующий и выходим
    if not HighlightConfig.Enabled then
        if HighlightConfig.CurrentHighlight then
            pcall(function()
                HighlightConfig.CurrentHighlight:Destroy()
                HighlightConfig.CurrentHighlight = nil
            end)
        end
        return
    end
    
    -- Если нет цели или её персонажа, удаляем хайлайт
    if not target or not target.Character then
        if HighlightConfig.CurrentHighlight then
            pcall(function()
                HighlightConfig.CurrentHighlight:Destroy()
                HighlightConfig.CurrentHighlight = nil
            end)
        end
        return
    end
    
    -- Если хайлайт уже существует, проверяем, нужно ли его переместить на новую цель
    if HighlightConfig.CurrentHighlight then
        if HighlightConfig.CurrentHighlight.Parent ~= target.Character then
            -- Если цель изменилась, удаляем старый хайлайт
            pcall(function()
                HighlightConfig.CurrentHighlight:Destroy()
                HighlightConfig.CurrentHighlight = nil
            end)
        end
    end
    
    -- Если хайлайта нет, создаем новый
    if not HighlightConfig.CurrentHighlight then
        pcall(function()
            local highlight = Instance.new("Highlight")
            highlight.OutlineColor = HighlightConfig.OutlineColor
            highlight.FillColor = HighlightConfig.FillColor
            highlight.OutlineTransparency = HighlightConfig.OutlineTransparency
            highlight.FillTransparency = HighlightConfig.FillTransparency
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Parent = target.Character
            
            HighlightConfig.CurrentHighlight = highlight
        end)
    end
end

-- Объединяем все эффекты в одну функцию для оптимизации
G.processHitEffects = function(target, previousHP)
    if not target or not target.Character or not target.Character:FindFirstChild('Humanoid') then return end
    
    -- Обновляем время последнего урона (без проверки дебаунса)
    G.lastDamageTick = tick()
    
    -- Сохраняем предыдущее значение HP для расчета урона
    lastHP = previousHP
    
    -- Применяем эффекты
    if HitChamsConfig.Enabled then HitChams(target, HitChamsConfig) end
    if HitSoundsConfig.Enabled then PlayHitSound(HitSoundsConfig) end
    
    if HitEffectsConfig.Enabled then
        task.spawn(function()
            local lib = getHitEffectsLib()
            if lib and lib.Functions and lib.Functions.Effect then
                lib.Functions.Effect(target.Character, HitEffectsConfig.Type, HitEffectsConfig.Color)
            end
        end)
    end
    
    -- Показываем уведомление о нанесенном уроне
    if HitNotificationsConfig.Enabled and target.Character:FindFirstChild('Humanoid') then
        local hum = target.Character.Humanoid
        local notifText = ">_<"
        
        -- Добавляем информацию о нанесенном уроне и оставшемся HP
        if HitNotificationsConfig.ShowDamage or HitNotificationsConfig.ShowRemaining then
            local damage = lastHP - hum.Health
            
            if HitNotificationsConfig.ShowDamage then
                notifText = notifText .. " -" .. math.floor(damage)
            end
            
            if HitNotificationsConfig.ShowRemaining then
                notifText = notifText .. " [" .. math.floor(hum.Health) .. " HP]"
            end
        end
        
        Library:Notify(notifText, HitNotificationsConfig.Duration)
    end
end

-- Используем Heartbeat вместо RenderStepped для снижения нагрузки
HRT:Connect(function()
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    
    -- Обновляем хайлайт для текущей цели аимбота
    if HighlightConfig.Enabled then
        G.updateHighlight(target)
    end
    
    -- Если никакие эффекты при попадании не включены, выходим
    if not HitChamsConfig.Enabled and not HitSoundsConfig.Enabled and not HitEffectsConfig.Enabled and not HitNotificationsConfig.Enabled then
        lastTarget, lastHP = nil, nil
        return
    end
    
    if target and target.Character and target.Character:FindFirstChild('Humanoid') then
        local hum = target.Character.Humanoid
        local hp = hum.Health
        
        if lastTarget ~= target then
            lastTarget = target
            lastHP = hp
        else if hp < lastHP then
                local previousHP = lastHP
                G.processHitEffects(target, previousHP)
            end
            lastHP = hp
        end
    else
        lastTarget, lastHP = nil, nil
    end
end)

-- Поиск корневой части персонажа (оставляем, может пригодиться для других функций)
G.findRootPart = function(character)
    return character:FindFirstChild("HumanoidRootPart") or
           character:FindFirstChild("Torso") or
           character:FindFirstChild("UpperTorso") or
           character:FindFirstChild("LowerTorso")
end

-- === Target Strafe (Combat tab, новая секция) ===
local TargetStrafeGroup = Tabs.Combat:AddLeftGroupbox('>_<')

-- Объединяем все переменные в одну таблицу
local TS = {
    Config = {
        Enabled = false,
        Radius = 10,
        Height = 5,
        Speed = 2,
        Visualise = false,
        VisualiseColor = Color3.fromRGB(255, 255, 255),
        UseDesync = false -- Новая опция для переключения между режимами
    },
    Runtime = {
        Angle = 0,
        Connection = nil,
        Target = nil,
        FollowPart = nil,
        DesyncPosition = nil,
        VisualiseDrawing = nil,
        LastAimbotTarget = nil,
        LastUpdateTime = 0 -- Добавляем отслеживание времени последнего обновления
    }
}

-- Делаем TS доступным глобально
getgenv().TS = TS

-- Функция для создания FollowPart для камеры
TS.createFollowPart = function()
    if TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent then
        TS.Runtime.FollowPart:Destroy()
    end
    
    local part = Instance.new("Part")
    part.Name = "TargetStrafeFollowPart"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(0.1, 0.1, 0.1)
    part.Parent = game:GetService("Workspace")

    -- Инициализируем начальную позицию
    if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
        part.CFrame = LP.Character.HumanoidRootPart.CFrame + Vector3.new(0, 2.0, 0)
    end
    
    return part
end

-- Функция восстановления камеры
TS.resetCamera = function()
    if TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent then
        TS.Runtime.FollowPart:Destroy()
        TS.Runtime.FollowPart = nil
    end
    
    if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
        game:GetService("Workspace").CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
    end
end

-- Функция для визуализации десинка
TS.updateVisual = function()
    -- Если визуализация отключена, удаляем трейсер
    if not TS.Config.Visualise or not TS.Runtime.DesyncPosition then
        if TS.Runtime.VisualiseDrawing then 
            TS.Runtime.VisualiseDrawing.Visible = false 
        end
        return
    end
    
    -- Проверяем, не слишком ли часто обновляем визуализацию
    local currentTime = tick()
    if currentTime - TS.Runtime.LastUpdateTime < 0.016 then -- Примерно 60 FPS
        return
    end
    TS.Runtime.LastUpdateTime = currentTime
    
    -- Создаем трейсер, если его еще нет
    if not TS.Runtime.VisualiseDrawing then
        TS.Runtime.VisualiseDrawing = Drawing.new("Line")
        TS.Runtime.VisualiseDrawing.Thickness = 2
        TS.Runtime.VisualiseDrawing.ZIndex = 10000
    end
    
    -- Получаем позицию десинка на экране
    local screenPos, onScreen = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(TS.Runtime.DesyncPosition)
    
    if onScreen then
        TS.Runtime.VisualiseDrawing.From = game:GetService("UserInputService"):GetMouseLocation()
        TS.Runtime.VisualiseDrawing.To = Vector2.new(screenPos.X, screenPos.Y)
        TS.Runtime.VisualiseDrawing.Color = TS.Config.VisualiseColor
        TS.Runtime.VisualiseDrawing.Visible = true
    else
        TS.Runtime.VisualiseDrawing.Visible = false
    end
end

-- Функция для полного удаления визуализации
TS.cleanupVisual = function()
    if TS.Runtime.VisualiseDrawing then
        TS.Runtime.VisualiseDrawing:Remove()
        TS.Runtime.VisualiseDrawing = nil
    end
end

-- Основная функция стрейфа с десинком
local function performTargetStrafeDesync()
    if not TS.Config.Enabled or not TS.Config.UseDesync then 
        TS.Runtime.DesyncPosition = nil
        
        -- Убедимся, что визуализация скрыта при отключении
        if TS.Runtime.VisualiseDrawing and TS.Runtime.VisualiseDrawing.Visible then
            TS.Runtime.VisualiseDrawing.Visible = false
        end
        
        return 
    end
    
    -- Получаем цель только из аимбота
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    
    -- Если нет цели, выходим
    if not target or not target.Character then 
        TS.Runtime.DesyncPosition = nil
        return 
    end
    
    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then 
        TS.Runtime.DesyncPosition = nil
        return 
    end
    
    local character = LP.Character
    if not character then 
        TS.Runtime.DesyncPosition = nil
        return 
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then 
        TS.Runtime.DesyncPosition = nil
        return 
    end
    
    -- Обновляем угол
    TS.Runtime.Angle = TS.Runtime.Angle + TS.Config.Speed * HRT:Wait()
    
    -- Вычисляем смещение
    local offset = Vector3.new(
        math.cos(TS.Runtime.Angle) * TS.Config.Radius,
        TS.Config.Height,
        math.sin(TS.Runtime.Angle) * TS.Config.Radius
    )
    
    -- Сохраняем оригинальный CFrame
    local originalCFrame = hrp.CFrame
    
    -- Новая позиция вокруг цели
    local targetPos = targetHRP.Position
    local newPos = targetPos + offset
    local newCFrame = CFrame.new(newPos, targetPos) -- Смотрим на цель
    
    -- Сохраняем позицию десинка для визуализации
    TS.Runtime.DesyncPosition = newPos
    
    -- Обновляем визуализацию
    if TS.Config.Visualise then
        TS.updateVisual()
    end
    
    -- Обновляем позицию FollowPart для фиксации камеры
    if TS.Config.Enabled and TS.Config.UseDesync then  -- Проверяем, что Target Strafe всё ещё активен
        if TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent then
            TS.Runtime.FollowPart.CFrame = originalCFrame + Vector3.new(0, 2.0, 0) -- Увеличил высоту с 1.5 до 2.0
        else
            TS.Runtime.FollowPart = TS.createFollowPart()
            TS.Runtime.FollowPart.CFrame = originalCFrame + Vector3.new(0, 2.0, 0)
        end
        game:GetService("Workspace").CurrentCamera.CameraSubject = TS.Runtime.FollowPart
    end
    
    -- Устанавливаем новую позицию
    hrp.CFrame = newCFrame
    
    -- Возвращаем оригинальную позицию после отрисовки кадра
    task.spawn(function()
        game:GetService("RunService").RenderStepped:Wait() -- Ждем один кадр отрисовки в отдельном потоке
        if hrp and hrp.Parent then -- Проверяем, что HRP все еще существует
            hrp.CFrame = originalCFrame
        end
    end)
    
    -- Возвращаем камеру к игроку после десинка
    task.spawn(function()
        game:GetService("RunService").RenderStepped:Wait() -- Используем RenderStepped для синхронизации с отрисовкой
        if character and character:FindFirstChildOfClass("Humanoid") then
            game:GetService("Workspace").CurrentCamera.CameraSubject = character:FindFirstChildOfClass("Humanoid")
        end
    end)
end

-- Основная функция стрейфа (без десинка)
local function performTargetStrafe()
    if not TS.Config.Enabled then return end
    if TS.Config.UseDesync then return end
    
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    
    if not target or not target.Character then return end
    
    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end
    
    local character = LP.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    -- Обновляем угол
    TS.Runtime.Angle = TS.Runtime.Angle + TS.Config.Speed * HRT:Wait()
    
    -- Вычисляем смещение
    local offset = Vector3.new(
        math.cos(TS.Runtime.Angle) * TS.Config.Radius,
        TS.Config.Height,
        math.sin(TS.Runtime.Angle) * TS.Config.Radius
    )
    
    -- Новая позиция вокруг цели
    local targetPos = targetHRP.Position
    local newPos = targetPos + offset
    
    -- Плавно перемещаемся к новой позиции
    hrp.CFrame = CFrame.new(hrp.Position:Lerp(newPos, 0.1), targetPos)
end

-- Функция включения стрейфа
local function toggleTargetStrafe(state)
    TS.Config.Enabled = state
    
    -- Отключаем предыдущие соединения
    if TS.Runtime.Connection then
        TS.Runtime.Connection:Disconnect()
        TS.Runtime.Connection = nil
    end
    
    -- Очищаем визуализацию при отключении
    if not state then
        TS.Runtime.DesyncPosition = nil
        TS.cleanupVisual()
        TS.resetCamera()
    end
    
    if state then
        -- Создаем FollowPart для камеры если нужен десинк
        if TS.Config.UseDesync then
            TS.Runtime.FollowPart = TS.createFollowPart()
        end
        
        -- Запускаем стрейф с правильной функцией в зависимости от режима
        if TS.Config.UseDesync then
            TS.Runtime.Connection = HRT:Connect(performTargetStrafeDesync)
        else
            TS.Runtime.Connection = HRT:Connect(performTargetStrafe)
        end
        -- Уведомления удалены, так как они будут вызваны через UI
    else
        -- Отключаем камеру
        TS.resetCamera()
        -- Уведомления удалены, так как они будут вызваны через UI
    end
end

-- UI для Target Strafe
TargetStrafeGroup:AddToggle('TargetStrafeEnabled', {
    Text = 'TargetStrafe',
    Default = false,
    Callback = function(v) toggleTargetStrafe(v) end,
    Tooltip = '>_<'
})

TargetStrafeGroup:AddToggle('TargetStrafeDesync', {
    Text = 'UseDesync',
    Default = false,
    Callback = function(v)
        TS.Config.UseDesync = v
        if TS.Config.Enabled then
            toggleTargetStrafe(false)
            toggleTargetStrafe(true)
        end
    end,
    Tooltip = '>_<'
})

TargetStrafeGroup:AddSlider('TargetStrafeRadius', {
    Text = 'Radius',
    Default = TS.Config.Radius,
    Min = 1, Max = 20, Rounding = 1,
    Callback = function(v) TS.Config.Radius = v end
})

TargetStrafeGroup:AddSlider('TargetStrafeHeight', {
    Text = 'Height',
    Default = TS.Config.Height,
    Min = -50, Max = 50, Rounding = 1,
    Callback = function(val) TS.Config.Height = val end
})

TargetStrafeGroup:AddSlider('TargetStrafeSpeed', {
    Text = 'Speed',
    Default = TS.Config.Speed,
    Min = 0.5, Max = 30, Rounding = 1,
    Callback = function(val) TS.Config.Speed = val end
})

TargetStrafeGroup:AddToggle('TargetStrafeVisualise', {
    Text = 'Visualise',
    Default = false,
    Callback = function(v) 
        TS.Config.Visualise = v
        
        -- Если отключаем визуализацию, удаляем трейсер
        if not v then
            TS.cleanupVisual()
        end
    end,
    Tooltip = '>_<'
}):AddColorPicker('TargetStrafeVisualiseColor', {
    Default = TS.Config.VisualiseColor,
    Title = 'Color',
    Transparency = 0,
    Callback = function(val)
        TS.Config.VisualiseColor = val
    end
})

-- Обработка смены персонажа
LP.CharacterAdded:Connect(function(newCharacter)
    if TS.Config.Enabled then
        -- Пересоздаем камеру при смене персонажа
        task.wait(0.5) -- Ждем загрузки персонажа
        if TS.Runtime.FollowPart and TS.Config.UseDesync then
            TS.resetCamera()
            TS.Runtime.FollowPart = TS.createFollowPart()
        end
    end
end)

-- Следим за изменениями цели аимбота и обновляем визуализацию
local aimbotTargetWatcher = nil
aimbotTargetWatcher = HRT:Connect(function()
    -- Обновляем визуализацию десинка на каждом кадре
    if TS.Config.Enabled and TS.Config.UseDesync and TS.Config.Visualise and TS.Runtime.DesyncPosition then
        TS.updateVisual()
    else
        if TS.Runtime.VisualiseDrawing and TS.Runtime.VisualiseDrawing.Visible then
            TS.Runtime.VisualiseDrawing.Visible = false
        end
    end
end)

-- === Camera Unlock (Player tab) ===
local CameraGroup = Tabs.Player:AddRightGroupbox('>_<')

CameraGroup:AddToggle('UnlockCameraDistance', {
    Text = 'Unlock Camera',
    Default = false,
    Callback = function(v) 
        if v then
            game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
        else
            game.Players.LocalPlayer.CameraMaxZoomDistance = 128 -- Стандартное значение
        end
    end,
    Tooltip = '>_<'
})

-- === AutoStomp (Combat tab, new section) ===
local AutoStompGroup = Tabs.Combat:AddRightGroupbox('>_<')

-- Настройки AutoStomp
getgenv().AutoStomp = {
    Enabled = false,
    StompCount = 100,
    StompInterval = 0.099,
    YOffset = 2,
    DelayBeforeStart = 0, -- Задержка перед началом стомпа
    isActive = false,
    stompCounter = 0,
    lastStompTime = nil,
    followPart = nil,
    delayStartTime = nil -- Время начала задержки
}

-- UI для AutoStomp
AutoStompGroup:AddToggle('AutoStompEnabled', {
    Text = 'AutoStomp',
    Default = false,
    Callback = function(v) 
        getgenv().AutoStomp.Enabled = v 
        if not v and getgenv().AutoStomp.isActive then
            -- Очистка при отключении
            getgenv().AutoStomp.isActive = false
            getgenv().AutoStomp.stompCounter = 0
            getgenv().AutoStomp.lastStompTime = nil
            resetAutoStompCamera()
        end
    end,
    Tooltip = '>_<'
})

AutoStompGroup:AddSlider('AutoStompInterval', {
    Text = 'Stomp Interval',
    Default = getgenv().AutoStomp.StompInterval,
    Min = 0.01, Max = 1, Rounding = 3,
    Callback = function(v) getgenv().AutoStomp.StompInterval = v end,
    Tooltip = '>_<'
})

AutoStompGroup:AddSlider('AutoStompDelay', {
    Text = 'Start Delay',
    Default = getgenv().AutoStomp.DelayBeforeStart,
    Min = 0, Max = 5, Rounding = 1,
    Callback = function(v) getgenv().AutoStomp.DelayBeforeStart = v end,
    Tooltip = '>_<'
})

-- Функции AutoStomp
local function isPlayerKO(player)
    if not player or not player.Character then return false end
    
    local bodyEffects = player.Character:FindFirstChild("BodyEffects")
    if not bodyEffects then return false end
    
    local ko = bodyEffects:FindFirstChild("K.O")
    local grabbed = bodyEffects:FindFirstChild("Grabbed")
    
    -- Проверяем, что игрок в нокауте и не схвачен
    return ko and ko.Value and (not grabbed or not grabbed.Value)
end

local function getRagdollPart(character)
    if not character then return nil end
    
    -- Приоритет частей тела для стомпа
    for _, partName in ipairs({"UpperTorso", "LowerTorso"}) do
        local part = character:FindFirstChild(partName)
        if part then return part end
    end
    
    return nil
end

-- Создаем FollowPart для камеры
local function createAutoStompFollowPart()
    if getgenv().AutoStomp.followPart and getgenv().AutoStomp.followPart.Parent then
        getgenv().AutoStomp.followPart:Destroy()
    end
    
    local part = Instance.new("Part")
    part.Name = "AutoStompFollowPart"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = V3.new(0.1, 0.1, 0.1)
    part.Parent = S.WS
    
    return part
end

-- Восстановление камеры
local function resetAutoStompCamera()
    if getgenv().AutoStomp.followPart and getgenv().AutoStomp.followPart.Parent then
        getgenv().AutoStomp.followPart:Destroy()
        getgenv().AutoStomp.followPart = nil
    end
    
    -- Проверяем, не активен ли Target Strafe
    local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled
    
    -- Восстанавливаем камеру только если Target Strafe не активен
    if not isTargetStrafeActive then
        if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
            S.WS.CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
        end
    end
end

local function performStomp()
    local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent")
                if mainEvent then
                    mainEvent:FireServer("Stomp")
                end
    
    -- Для некоторых игр может потребоваться дополнительный вызов
    local assets = game:GetService("ReplicatedStorage"):FindFirstChild("assets")
    if assets and assets:FindFirstChild("dh") then
        if assets.dh and assets.dh.MainEvent then
                    assets.dh.MainEvent:FireServer("Stomp")
                end
    end
    
    getgenv().AutoStomp.stompCounter = getgenv().AutoStomp.stompCounter - 1
    getgenv().AutoStomp.lastStompTime = tick()
    
    if getgenv().AutoStomp.stompCounter <= 0 then
        getgenv().AutoStomp.isActive = false
        resetAutoStompCamera()
        
        -- Восстанавливаем FakePos после завершения цикла стомпов
        if getgenv().InvisDesyncConfig and getgenv().InvisDesyncConfig.Enabled then
            -- Небольшая задержка перед восстановлением FakePos
            task.delay(0.2, function()
                getgenv().applyFakePos()
            end)
        end
    end
end

-- Основная функция AutoStomp
G.applyAutoStomp = function()
    -- Сохраняем состояние FakePos перед выполнением AutoStomp
    local fakePosWasActive = getgenv().InvisDesyncConfig and getgenv().InvisDesyncConfig.Enabled
    
    if not getgenv().AutoStomp.Enabled then
        if getgenv().AutoStomp.isActive then
            getgenv().AutoStomp.isActive = false
            getgenv().AutoStomp.stompCounter = 0
            getgenv().AutoStomp.lastStompTime = nil
            getgenv().AutoStomp.delayStartTime = nil
            resetAutoStompCamera()
            
            -- Восстанавливаем FakePos после завершения AutoStomp, если он был активен
            if fakePosWasActive and getgenv().InvisDesyncConfig and getgenv().InvisDesyncConfig.Enabled then
                getgenv().applyFakePos()
            end
        end
        return
    end
    
    local targetPlayer = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    if not targetPlayer or not targetPlayer.Character then return end
    
    -- Проверяем, находится ли игрок в нокауте и не схвачен
    if not isPlayerKO(targetPlayer) then 
        if getgenv().AutoStomp.isActive then
            getgenv().AutoStomp.isActive = false
            getgenv().AutoStomp.delayStartTime = nil
            resetAutoStompCamera()
        end
        return 
    end
    
    -- Получаем часть тела для телепорта
    local ragdollPart = getRagdollPart(targetPlayer.Character)
    if not ragdollPart then return end
    
    -- Проверяем, не покупает ли AutoArmor броню в данный момент
    local isAutoArmorBuying = G.AutoArmorSettings and G.AutoArmorSettings.IsBuying
    
    -- Инициализируем стомп, если ещё не активен
    if not getgenv().AutoStomp.isActive then
        getgenv().AutoStomp.isActive = true
        getgenv().AutoStomp.stompCounter = getgenv().AutoStomp.StompCount
        getgenv().AutoStomp.lastStompTime = tick()
        getgenv().AutoStomp.delayStartTime = tick() -- Запоминаем время начала задержки
        getgenv().AutoStomp.followPart = createAutoStompFollowPart()
    end
    
    -- Если AutoArmor покупает броню, пропускаем телепорт к цели
    if isAutoArmorBuying then return end
    
    -- Проверяем, прошла ли задержка перед началом стомпа
    if getgenv().AutoStomp.delayStartTime and 
       (tick() - getgenv().AutoStomp.delayStartTime) < getgenv().AutoStomp.DelayBeforeStart then
        -- Задержка еще не прошла, пропускаем телепорт
        return
    end
    
    if getgenv().AutoStomp.isActive then
        -- Сохраняем оригинальную позицию
        local hrp = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local originalCFrame = hrp.CFrame
        local targetPosition = ragdollPart.Position
        
        -- Обновляем позицию FollowPart для фиксации камеры
        -- Проверяем, не активен ли Target Strafe
        local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled
        
        if getgenv().AutoStomp.followPart and not isTargetStrafeActive then
            getgenv().AutoStomp.followPart.CFrame = originalCFrame + V3.new(0, 2.0, 0)
            Cam.CameraSubject = getgenv().AutoStomp.followPart
        end
        
        -- Телепортируемся к цели для стомпа
        hrp.CFrame = CFrame.new(targetPosition + Vector3.new(0, getgenv().AutoStomp.YOffset, 0))
        S.RS.RenderStepped:Wait()
        hrp.CFrame = originalCFrame
        
        -- Возвращаем камеру к игроку после десинка только если Target Strafe не активен
        task.spawn(function()
            S.RS.RenderStepped:Wait() -- Используем RenderStepped для синхронизации с отрисовкой
            
            -- Проверяем, не активен ли Target Strafe
            local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled
            
            -- Возвращаем камеру только если Target Strafe не активен
            if not isTargetStrafeActive then
                if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
                    Cam.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
                end
            end
        end)
        
        -- Выполняем стомп с заданным интервалом
        if getgenv().AutoStomp.lastStompTime and 
           (tick() - getgenv().AutoStomp.lastStompTime) >= getgenv().AutoStomp.StompInterval and 
           getgenv().AutoStomp.stompCounter > 0 then
            performStomp()
        end
    end
end

-- Добавляем AutoStomp в основной цикл
HRT:Connect(function()
    if getgenv().AutoStomp.Enabled then
        G.applyAutoStomp()
    end
end)

-- === Grip (Combat tab, new section) ===
local GripGroup = Tabs.Combat:AddRightGroupbox('>_<')

-- Create UI components
GripGroup:AddToggle('GripEnabled', {
    Text = 'CustomGrip',
    Default = false,
    Callback = function(v) G.GripSettings.Enabled = v end,
    Tooltip = '>_<'
})

-- Position sliders
GripGroup:AddLabel('Position:')
GripGroup:AddSlider('GripPosX', {
    Text = 'X',
    Default = 0,
    Min = -100, Max = 100, Rounding = 1,
    Callback = function(val) G.GripSettings.Position = Vector3.new(val, G.GripSettings.Position.Y, G.GripSettings.Position.Z) end
})

GripGroup:AddSlider('GripPosY', {
    Text = 'Y',
    Default = 0,
    Min = -100, Max = 100, Rounding = 1,
    Callback = function(val) G.GripSettings.Position = Vector3.new(G.GripSettings.Position.X, val, G.GripSettings.Position.Z) end
})

GripGroup:AddSlider('GripPosZ', {
    Text = 'Z',
    Default = 0,
    Min = -100, Max = 100, Rounding = 1,
    Callback = function(val) G.GripSettings.Position = Vector3.new(G.GripSettings.Position.X, G.GripSettings.Position.Y, val) end
})

-- Rotation sliders
GripGroup:AddLabel('Rotation:')
GripGroup:AddSlider('GripRotX', {
    Text = 'X',
    Default = 0,
    Min = -180, Max = 180, Rounding = 1,
    Callback = function(val) G.GripSettings.Rotation = Vector3.new(val, G.GripSettings.Rotation.Y, G.GripSettings.Rotation.Z) end
})

GripGroup:AddSlider('GripRotY', {
    Text = 'Y',
    Default = 0,
    Min = -180, Max = 180, Rounding = 1,
    Callback = function(val) G.GripSettings.Rotation = Vector3.new(G.GripSettings.Rotation.X, val, G.GripSettings.Rotation.Z) end
})

GripGroup:AddSlider('GripRotZ', {
    Text = 'Z',
    Default = 0,
    Min = -180, Max = 180, Rounding = 1,
    Callback = function(val) G.GripSettings.Rotation = Vector3.new(G.GripSettings.Rotation.X, G.GripSettings.Rotation.Y, val) end
})

-- Reset button
GripGroup:AddLabel('Options:')
GripGroup:AddButton({
    Text = 'Reset',
    Func = function()
        G.GripSettings.Position = Vector3.new(0, 0, 0)
        G.GripSettings.Rotation = Vector3.new(0, 0, 0)
        -- Update UI sliders to match the reset values
        Options.GripPosX:SetValue(0)
        Options.GripPosY:SetValue(0)
        Options.GripPosZ:SetValue(0)
        Options.GripRotX:SetValue(0)
        Options.GripRotY:SetValue(0)
        Options.GripRotZ:SetValue(0)
    end,
    Tooltip = '>_<'
})





-- Main grip logic
local gripConnection
if gripConnection then gripConnection:Disconnect() end

gripConnection = S.RS.Stepped:Connect(function()
    if G.GripSettings.Enabled then
        local character = LP.Character
        local tool = character and character:FindFirstChildOfClass("Tool")
        if tool then
            local position = G.GripSettings.Position
            
            -- Apply rotation using proper CFrame
            local angles = CFrame.Angles(
                M.rad(G.GripSettings.Rotation.X),
                M.rad(G.GripSettings.Rotation.Y),
                M.rad(G.GripSettings.Rotation.Z)
            )
            
            -- Применяем позицию и вращение
            tool.Grip = CFrame.new(position) * angles
        end
    end
end)

-- === BulletTP (Combat tab, новая секция) ===
local BulletTpGroup = Tabs.Combat:AddLeftGroupbox('>_<')

-- Инициализация настроек BulletTP
getgenv().BulletTp = {
    Enabled = false,
    Toggle = true,
    Keybind = Enum.KeyCode.C,
    Part = "Head",
    Selected = nil,
    UseAimbotTarget = true -- Всегда используем цель аимбота
}

-- UI для BulletTP
addToggleWithNotify(BulletTpGroup, 'BulletTpToggle', {
    Text = 'BulletTP',
    Default = false,
    Callback = function(v) 
        getgenv().BulletTp.Toggle = v 
    end,
    Tooltip = '>_<'
})

BulletTpGroup:AddLabel('BulletTP Key'):AddKeyPicker('BulletTpKey', {
    Default = 'None',
    Text = 'Key',
    NoUI = false,
    Callback = function()
        -- Переключаем состояние BulletTP при нажатии клавиши, если функция включена
        if getgenv().BulletTp and getgenv().BulletTp.Toggle then
            local wasEnabled = getgenv().BulletTp.Enabled
            getgenv().BulletTp.Enabled = not wasEnabled
            
            -- Отправляем уведомление
            Library:Notify(">_< " .. (getgenv().BulletTp.Enabled and "on" or "off"), 2)
        end
    end
})

BulletTpGroup:AddDropdown('BulletTpPart', {
    Text = 'Part',
    Values = {'Head', 'HumanoidRootPart', 'Torso', 'UpperTorso', 'LowerTorso', 'Left Arm', 'Right Arm', 'Left Leg', 'Right Leg', 'LeftUpperArm', 'RightUpperArm', 'LeftUpperLeg', 'RightUpperLeg'},
    Default = 'Head',
    Callback = function(v) getgenv().BulletTp.Part = v end,
    Tooltip = '>_<'
})

-- Убрали тогл UseAimbot, т.к. BulletTP всегда работает с аимботом

-- Улучшенная функция поиска части тела
G.findBodyPart = function(character, partName)
    if not character then return nil end
    
    -- Прямой поиск по имени
    local part = character:FindFirstChild(partName)
    if part and part:IsA("BasePart") then return part end
    
    -- Мапинг альтернативных имен частей тела
    local partMap = {
        ["Torso"] = {"UpperTorso", "LowerTorso"},
        ["UpperTorso"] = {"Torso"},
        ["LowerTorso"] = {"Torso"},
        ["Left Arm"] = {"LeftUpperArm", "LeftLowerArm", "LeftHand"},
        ["Right Arm"] = {"RightUpperArm", "RightLowerArm", "RightHand"},
        ["Left Leg"] = {"LeftUpperLeg", "LeftLowerLeg", "LeftFoot"},
        ["Right Leg"] = {"RightUpperLeg", "RightLowerLeg", "RightFoot"},
        ["LeftUpperArm"] = {"Left Arm"},
        ["RightUpperArm"] = {"Right Arm"},
        ["LeftUpperLeg"] = {"Left Leg"},
        ["RightUpperLeg"] = {"Right Leg"}
    }
    
    -- Проверяем альтернативные названия
    if partMap[partName] then
        for _, altName in ipairs(partMap[partName]) do
            part = character:FindFirstChild(altName)
            if part and part:IsA("BasePart") then return part end
        end
    end
    
    -- Если не нашли, возвращаем HumanoidRootPart или Head как запасной вариант
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head")
end

-- Функции BulletTP с защитой от ошибок
G.TeleportBullet = function(tool)
    local success, err = pcall(function()
        local BTP = getgenv().BulletTp
        if not BTP.Toggle or not BTP.Enabled then return end

        -- Всегда используем цель аимбота
        local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget or BTP.Selected
        if not target or not target.Character then return end

        local originPart = LP.Character and LP.Character:FindFirstChild("RightHand")
        if not originPart then
            originPart = LP.Character and LP.Character:FindFirstChild("Right Arm")
        end
        if not originPart then return end
        
        local targetPart = G.findBodyPart(target.Character, BTP.Part)
        if not targetPart then return end

        if originPart and targetPart then
            local grip = tool.Grip
            tool.Parent = LP.Backpack
            tool.Grip = G.bulletTpCFOffset(originPart.CFrame, targetPart.CFrame)
            tool.Parent = LP.Character
            S.RS.RenderStepped:Wait()
            tool.Parent = LP.Backpack
            tool.Grip = grip
            tool.Parent = LP.Character
        end
    end)
    
    if not success and err then
        -- В режиме отладки можно логировать ошибки
        -- print("BulletTP error:", err)
    end
end

-- Переносим функцию в глобальную таблицу G с защитой от ошибок
G.HandleCharacter = function(character)
    local success, err = pcall(function()
        -- Очищаем предыдущие соединения
        for k, conn in pairs(G.bulletTpConns) do
            if k ~= "InputBegan" and k ~= "CharacterAdded" and k ~= "CharacterRemoving" and k ~= "TargetUpdate" then
                if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
                G.bulletTpConns[k] = nil
            end
        end

        -- Обрабатываем инструменты при их добавлении
        G.bulletTpConns.CharacterChildAdded = character.ChildAdded:Connect(function(tool)
            if tool:IsA("Tool") then
                -- Отключаем стандартные обработчики изменения Grip
                for _, conn in ipairs(getconnections(tool:GetPropertyChangedSignal("Grip"))) do conn:Disable() end
                
                -- Создаем соединение с активацией инструмента
                if G.bulletTpConns.ToolActivated then
                    G.bulletTpConns.ToolActivated:Disconnect()
                end
                G.bulletTpConns.ToolActivated = tool.Activated:Connect(function() G.TeleportBullet(tool) end)
            end
        end)

        -- Обрабатываем удаление инструментов
        G.bulletTpConns.ChildRemovingCharacter = character.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") and G.bulletTpConns.ToolActivated then
                G.bulletTpConns.ToolActivated:Disconnect()
                G.bulletTpConns.ToolActivated = nil
            end
        end)
        
        -- Проверяем, есть ли уже инструмент в руках
        local existingTool = character:FindFirstChildOfClass("Tool")
        if existingTool then
            for _, conn in ipairs(getconnections(existingTool:GetPropertyChangedSignal("Grip"))) do conn:Disable() end
            if G.bulletTpConns.ToolActivated then
                G.bulletTpConns.ToolActivated:Disconnect()
            end
            G.bulletTpConns.ToolActivated = existingTool.Activated:Connect(function() G.TeleportBullet(existingTool) end)
        end
    end)
    
    if not success and err then
        -- В режиме отладки можно логировать ошибки
        -- print("BulletTP HandleCharacter error:", err)
    end
end

-- Функция для выбора ближайшего игрока как цели BulletTP с защитой от ошибок
G.getClosestPlayer = function()
    local success, result = pcall(function()
        local closest, dist = nil, math.huge
        local myPos = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and LP.Character.HumanoidRootPart.Position
        if not myPos then return nil end
        
        for _, p in ipairs(S.PS:GetPlayers()) do
            if p ~= LP and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and 
               p.Character:FindFirstChildOfClass("Humanoid") and p.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
                local d = (p.Character.HumanoidRootPart.Position - myPos).Magnitude
                if d < dist then closest, dist = p, d end
            end
        end
        return closest
    end)
    
    if success then
        return result
    else
        return nil
    end
end

-- Заменяем на глобальную функцию с защитой от ошибок
G.SetupBulletTp = function()
    local success, err = pcall(function()
        -- Очищаем все соединения
        for k, conn in pairs(G.bulletTpConns) do
            if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
        end
        G.bulletTpConns = {}
        
        -- Настраиваем для текущего персонажа
        if LP.Character then
            G.HandleCharacter(LP.Character)
        end

        -- Соединение с событием добавления персонажа
        G.bulletTpConns.CharacterAdded = LP.CharacterAdded:Connect(function(newCharacter)
            task.wait(0.5) -- Ждем, чтобы персонаж полностью загрузился
            G.HandleCharacter(newCharacter)
        end)

        -- Соединение с событием удаления персонажа
        G.bulletTpConns.CharacterRemoving = LP.CharacterRemoving:Connect(function()
            -- Очищаем соединения, связанные с конкретным персонажем
            for k, conn in pairs(G.bulletTpConns) do
                if k ~= "InputBegan" and k ~= "CharacterAdded" and k ~= "CharacterRemoving" and k ~= "TargetUpdate" then
                    if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
                    G.bulletTpConns[k] = nil
                end
            end
        end)
        
        -- Удаляем старый обработчик InputBegan для BulletTP, так как теперь используем KeyPicker
        
        -- Соединение с обновлением цели для запасного варианта
        if not G.bulletTpConns.TargetUpdate then
            G.bulletTpConns.TargetUpdate = HRT:Connect(function()
                -- Если нет цели аимбота, используем ближайшего игрока
                if not getgenv().SilentAim or not getgenv().SilentAim.currentTarget then
                    getgenv().BulletTp.Selected = G.getClosestPlayer()
                end
            end)
        end
    end)
    
    if not success and err then
        -- В режиме отладки можно логировать ошибки
        -- print("BulletTP Setup error:", err)
        
        -- Пробуем повторить установку через 5 секунд
        task.delay(5, G.SetupBulletTp)
    end
end

-- Запускаем BulletTP с защитой от ошибок
task.spawn(function()
    pcall(G.SetupBulletTp)
end)

-- Очистка соединений BulletTP при выходе из игры
S.PS.PlayerRemoving:Connect(function(player)
    if player == LP then
        pcall(function()
            for k, conn in pairs(G.bulletTpConns) do
                if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
            end
            G.bulletTpConns = {}
        end)
    end
end)

-- === Save Distance (Combat tab, новая секция) ===
local SaveDistanceGroup = Tabs.Combat:AddRightGroupbox('>_<')

-- Настройки SaveDistance
getgenv().SaveDistance = {
    Enabled = false,
    OffsetX = 0,
    OffsetY = 100,
    OffsetZ = 0,
    Connection = nil,
    IsBuyingArmor = false,
    LastTarget = nil,
    DampingConnection = nil
}

-- UI для SaveDistance
SaveDistanceGroup:AddToggle('SaveDistanceEnabled', {
    Text = 'SavePos',
    Default = false,
    Callback = function(v) 
        getgenv().SaveDistance.Enabled = v
        toggleSaveDistance(v)
    end,
    Tooltip = '>_<'
})

SaveDistanceGroup:AddSlider('SaveDistanceOffsetX', {
    Text = 'X',
    Default = 0,
    Min = -200, Max = 200, Rounding = 0,
    Increment = 1,
    Callback = function(v) getgenv().SaveDistance.OffsetX = v end,
    Tooltip = '>_<'
})

SaveDistanceGroup:AddSlider('SaveDistanceOffsetY', {
    Text = 'Y',
    Default = 100,
    Min = -200, Max = 200, Rounding = 0,
    Increment = 1,
    Callback = function(v) getgenv().SaveDistance.OffsetY = v end,
    Tooltip = '>_<'
})

SaveDistanceGroup:AddSlider('SaveDistanceOffsetZ', {
    Text = 'Z',
    Default = 0,
    Min = -200, Max = 200, Rounding = 0,
    Increment = 1,
    Callback = function(v) getgenv().SaveDistance.OffsetZ = v end,
    Tooltip = '>_<'
})

-- Функция для получения "настоящей" позиции цели с учетом анти-аимбота
G.resolveCFrame = function(player)
    if not player or not player.Character then return nil end
    
    local success, result = pcall(function()
        local character = player.Character
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local hrp = character:FindFirstChild("HumanoidRootPart")
        
        if not humanoid or not hrp then return nil end
        
        -- Базовые компоненты для расчета
        local velocity = hrp.Velocity
        local moveDirection = humanoid.MoveDirection
        local lookVector = hrp.CFrame.LookVector
        
        -- Проверяем передвижение
        local isMoving = velocity.Magnitude > 0.1
        local isPredictable = moveDirection.Magnitude > 0.1
        
        -- Если у цели есть явная скорость и направление движения
        if isMoving and isPredictable then
            -- Коррекция CFrame на основе направления движения и скорости
            local velocityUnit = velocity.Unit
            local dot = velocityUnit:Dot(lookVector)
            
            -- Если игрок движется примерно в направлении, куда смотрит (или в противоположном)
            if math.abs(dot) > 0.7 then
                -- Создаем новый CFrame, который учитывает реальное направление движения
                local forward = moveDirection.Unit
                local right = Vector3.new(forward.z, 0, -forward.x).Unit
                local up = Vector3.new(0, 1, 0)
                
                -- Сохраняем позицию, но корректируем ориентацию
                return CFrame.fromMatrix(hrp.Position, right, up, forward)
            end
        end
        
        -- Если не смогли определить лучше, возвращаем оригинальный CFrame
        return hrp.CFrame
    end)
    
    if success and result then
        return result
    else
        -- В случае ошибки возвращаем стандартный CFrame, если доступен
        return player.Character and player.Character:FindFirstChild("HumanoidRootPart") and 
               player.Character.HumanoidRootPart.CFrame
    end
end

-- Функция плавного затухания скорости
function smoothDamping(hrp, duration)
    -- Сначала отключаем предыдущее соединение на всякий случай
    if getgenv().SaveDistance.DampingConnection then
        getgenv().SaveDistance.DampingConnection:Disconnect()
        getgenv().SaveDistance.DampingConnection = nil
    end
    
    if not hrp then return end
    
    -- Сохраняем текущую скорость для плавного гашения
    local initialVelocity = hrp.Velocity
    local startTime = tick()
    
    -- Создаем соединение для плавного снижения скорости
    getgenv().SaveDistance.DampingConnection = game:GetService("RunService").Heartbeat:Connect(function()
        local elapsedTime = tick() - startTime
        local progress = math.min(elapsedTime / duration, 1) -- От 0 до 1
        
        if progress >= 1 then
            -- Когда время вышло, завершаем процесс
            hrp.Velocity = Vector3.new(0, -1, 0) -- Небольшая скорость вниз для естественного падения
            
            if getgenv().SaveDistance.DampingConnection then
                getgenv().SaveDistance.DampingConnection:Disconnect()
                getgenv().SaveDistance.DampingConnection = nil
            end
            return
        end
        
        -- Экспоненциальная функция затухания для более плавного эффекта
        local dampFactor = math.exp(-10 * progress)
        hrp.Velocity = initialVelocity * dampFactor
    end)
end

-- Функция для включения/отключения SaveDistance
function toggleSaveDistance(state)
    -- Отключаем предыдущее соединение SaveDistance
    if getgenv().SaveDistance.Connection then
        getgenv().SaveDistance.Connection:Disconnect()
        getgenv().SaveDistance.Connection = nil
        
        -- Плавно гасим скорость при отключении
        if not state and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
            smoothDamping(LP.Character.HumanoidRootPart, 0.8) -- 0.8 секунд на затухание скорости
        end
    end
    
    -- Отключаем предыдущее соединение затухания, если включаем SaveDistance
    if state and getgenv().SaveDistance.DampingConnection then
        getgenv().SaveDistance.DampingConnection:Disconnect()
        getgenv().SaveDistance.DampingConnection = nil
    end
    
    if state then
        getgenv().SaveDistance.Connection = HRT:Connect(function()
            -- Если в данный момент покупается броня, пропускаем обновление позиции
            if getgenv().SaveDistance.IsBuyingArmor then return end
            
            local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
            
            -- Если цель изменилась, плавно гасим скорость перед переходом к новой цели
            if target ~= getgenv().SaveDistance.LastTarget and getgenv().SaveDistance.LastTarget then
                -- Проверяем наличие локального персонажа
                if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
                    -- Плавное затухание перед переходом к новой цели
                    smoothDamping(LP.Character.HumanoidRootPart, 0.3) -- Меньше времени для смены цели
                end
            end
            
            -- Обновляем последнюю цель
            getgenv().SaveDistance.LastTarget = target
            
            if not target or not target.Character then return end
            
            -- Получаем реальный CFrame цели с учетом анти-аимбота
            local resolvedTargetCF = G.resolveCFrame(target)
            if not resolvedTargetCF then return end
            
            local character = LP.Character
            if not character then return end
            
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            
            -- Перемещаем игрока относительно цели с учетом всех осей
            local targetPos = resolvedTargetCF.Position
            local offset = Vector3.new(
                getgenv().SaveDistance.OffsetX,
                getgenv().SaveDistance.OffsetY,
                getgenv().SaveDistance.OffsetZ
            )
            
            -- Учитываем ориентацию цели для правильного смещения по X и Z
            -- Используем разрешенный CFrame для более точного расчета
            local offsetInWorldSpace = resolvedTargetCF.RightVector * offset.X + 
                                      Vector3.new(0, offset.Y, 0) + 
                                      resolvedTargetCF.LookVector * offset.Z
            
            local newPos = targetPos + offsetInWorldSpace
            hrp.CFrame = CFrame.new(newPos, targetPos) -- Смотрим на цель
        end)
        
        Library:Notify('>_< on', 3)
    else
        Library:Notify('>_< off', 3)
    end
end

-- === AutoArmor (Misc tab, new section) ===
-- Используем глобальную переменную вместо локальной
G.AutoArmorGroup = Tabs.Misc:AddLeftGroupbox('AutoArmor')

-- Глобальные настройки AutoArmor
G.AutoArmorSettings = {
    Enabled = false,
    LastArmorCheck = 0,
    CheckInterval = 1, -- Проверять каждую секунду
    MinArmorValue = 50, -- Покупать броню, когда значение меньше этого
    ArmorType = 1, -- Тип брони для покупки (1 = Max Armor 1)
    Notify = true, -- Уведомлять о покупке брони
    DebugMode = false, -- Режим отладки для вывода значения брони
    -- Переменные для функции autoArmorFunction
    BuyingArmor = nil,
    IsBuying = false, -- Флаг, что в данный момент покупаем броню
    BuyingTimeout = 0, -- Время, когда закончится блокировка
    Connection = nil,
    char = nil,
    armorValue = 0,
    hrp = nil,
    armorShop = nil,
    armorItem = nil,
    originalCFrame = nil,
    originalVelocity = nil,
    autoStompOriginalState = nil, -- Сохранение состояния AutoStomp
    originalTSState = nil, -- Сохранение состояния Target Strafe
    DesyncPosition = nil -- Сохранение позиции десинка для восстановления
}

-- Функция для определения текущего значения брони в зависимости от игры
G.getCurrentArmorValue = function()
    -- Для Da Hood: Character.BodyEffects.Armor
    G.char = LP.Character
    if G.char and G.char:FindFirstChild("BodyEffects") and G.char.BodyEffects:FindFirstChild("Armor") then
        return G.char.BodyEffects.Armor.Value
    end
    
    -- Для Del Hood: DataFolder.Information.Armor
    if LP:FindFirstChild("DataFolder") and 
       LP.DataFolder:FindFirstChild("Information") and 
       LP.DataFolder.Information:FindFirstChild("Armor") then
        return tonumber(LP.DataFolder.Information.Armor.Value) or 0
    end
    
    -- Если не нашли, пробуем другие возможные места
    G.possiblePaths = {
        {LP.Character, "Armor"},
        {LP, "Armor"},
        {LP, "stats", "Armor"},
        {LP, "Data", "Armor"},
        {LP, "PlayerData", "Armor"}
    }
    
    for _, path in ipairs(G.possiblePaths) do
        G.current = path[1]
        G.found = true
        
        for i = 2, #path do
            if G.current and G.current:FindFirstChild(path[i]) then
                G.current = G.current[path[i]]
            else
                G.found = false
                break
            end
        end
        
        if G.found and G.current and (typeof(G.current) == "number" or 
            (typeof(G.current) == "Instance" and G.current:IsA("NumberValue") or G.current:IsA("IntValue"))) then
            return typeof(G.current) == "number" and G.current or G.current.Value
        end
    end
    
    -- Если все методы не сработали, возвращаем 0
    return 0
end

-- Функция автоматической покупки брони
G.autoArmorFunction = function()
    -- Защита от ошибок
    G.success = pcall(function()
        if not G.AutoArmorSettings.Enabled then return end
        
        -- Проверяем, не покупаем ли уже броню
        G.now = tick()
        if G.AutoArmorSettings.IsBuying then
            -- Если процесс покупки длится слишком долго, сбрасываем флаг (защита от зависания)
            if G.now >= G.AutoArmorSettings.BuyingTimeout then
                G.AutoArmorSettings.IsBuying = false
                if getgenv().SaveDistance then
                    getgenv().SaveDistance.IsBuyingArmor = false
                end
                
                -- Восстанавливаем состояние Target Strafe, если он был сохранен
                if G.AutoArmorSettings.originalTSState and getgenv().TS then
                    getgenv().TS.Config.Enabled = G.AutoArmorSettings.originalTSState.Enabled
                    getgenv().TS.Config.UseDesync = G.AutoArmorSettings.originalTSState.UseDesync
                    
                    -- Если был активен десинк, восстанавливаем позицию десинка
                    if G.AutoArmorSettings.originalTSState.UseDesync and G.AutoArmorSettings.DesyncPosition then
                        getgenv().TS.Runtime.DesyncPosition = G.AutoArmorSettings.DesyncPosition
                    end
                end
                
                if G.AutoArmorSettings.Notify then
                    Library:Notify(">_<", 2)
                end
            else
                return -- Пропускаем выполнение, пока не завершится текущая покупка
            end
        end
        
        -- Проверяем не слишком часто для оптимизации
        if G.now - G.AutoArmorSettings.LastArmorCheck < G.AutoArmorSettings.CheckInterval then
            return
        end
        G.AutoArmorSettings.LastArmorCheck = G.now
        
        G.AutoArmorSettings.char = LP.Character
        if not G.AutoArmorSettings.char then return end
        
        -- Проверяем состояние K.O. и Grabbed
        local bodyEffects = G.AutoArmorSettings.char:FindFirstChild("BodyEffects")
        if bodyEffects then
            -- Проверка на K.O.
            local ko = bodyEffects:FindFirstChild("K.O")
            if ko and ko.Value then
                return -- Не покупаем броню, если в нокауте
            end
            
            -- Проверка на Grabbed
            local grabbed = bodyEffects:FindFirstChild("Grabbed")
            if grabbed and grabbed.Value then
                return -- Не покупаем броню, если схвачен
            end
        end
        
        -- Получаем текущее значение брони с учетом разных игр
        G.AutoArmorSettings.armorValue = G.getCurrentArmorValue()
        
        -- Если включен режим отладки, показываем текущее значение брони
        if G.AutoArmorSettings.DebugMode then
            print("Current armor value:", G.AutoArmorSettings.armorValue)
        end
        
        -- Если броня ниже минимального значения, покупаем новую
        if G.AutoArmorSettings.armorValue < G.AutoArmorSettings.MinArmorValue then
            -- Устанавливаем флаг, что сейчас покупаем броню
            G.AutoArmorSettings.IsBuying = true
            -- Устанавливаем таймаут в 15 секунд (увеличиваем для большей надежности)
            G.AutoArmorSettings.BuyingTimeout = G.now + 15
            
            -- Выполняем покупку в отдельном потоке, чтобы не блокировать основной цикл
            task.spawn(function()
                -- Сохраняем состояние AutoStomp, но не отключаем его
                local isAutoStompActive = getgenv().AutoStomp and getgenv().AutoStomp.isActive
                G.AutoArmorSettings.autoStompOriginalState = nil
                if isAutoStompActive then
                    G.AutoArmorSettings.autoStompOriginalState = {
                        Enabled = getgenv().AutoStomp.Enabled,
                        isActive = getgenv().AutoStomp.isActive
                    }
                    -- Больше не отключаем AutoStomp во время покупки брони
                    -- AutoStomp сам проверит, идет ли покупка брони и пропустит телепорт
                end
                
                -- Сохраняем текущую позицию
                G.AutoArmorSettings.hrp = G.AutoArmorSettings.char:FindFirstChild("HumanoidRootPart")
                if not G.AutoArmorSettings.hrp then 
                    G.AutoArmorSettings.IsBuying = false
                    return 
                end
                
                -- Проверяем, активен ли Target Strafe с десинком
                local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled
                local isTargetStrafeDesync = isTargetStrafeActive and getgenv().TS.Config.UseDesync
                
                -- Сохраняем реальную позицию игрока (с учетом Target Strafe)
                if isTargetStrafeDesync and getgenv().TS.Runtime.DesyncPosition then
                    -- Если активен десинк, используем реальную позицию персонажа, а не позицию десинка
                G.AutoArmorSettings.BuyingArmor = G.AutoArmorSettings.hrp.CFrame
                    -- Сохраняем также позицию десинка для возврата
                    G.AutoArmorSettings.DesyncPosition = getgenv().TS.Runtime.DesyncPosition
                else
                    G.AutoArmorSettings.BuyingArmor = G.AutoArmorSettings.hrp.CFrame
                    G.AutoArmorSettings.DesyncPosition = nil
                end
                
                -- Сохраняем скорость для восстановления после телепорта
                G.AutoArmorSettings.originalVelocity = G.AutoArmorSettings.hrp.Velocity
                
                -- Устанавливаем флаг, что покупаем броню (для SavePosition)
                if getgenv().SaveDistance and getgenv().SaveDistance.Enabled then
                    getgenv().SaveDistance.IsBuyingArmor = true
                end
                
                -- Сохраняем состояние Target Strafe для последующего восстановления
                G.AutoArmorSettings.originalTSState = nil
                if getgenv().TS and getgenv().TS.Config then
                    G.AutoArmorSettings.originalTSState = {
                        Enabled = getgenv().TS.Config.Enabled,
                        UseDesync = getgenv().TS.Config.UseDesync
                    }
                    -- Временно отключаем Target Strafe
                    getgenv().TS.Config.Enabled = false
                end
                
                -- Определяем тип выбранной брони
                local isDelHoodArmor = false
                local selectedArmorIndex = nil
                
                -- Проверяем, является ли выбранная броня индексом (Del Hood)
                if type(G.AutoArmorSettings.ArmorType) == "number" then
                    isDelHoodArmor = true
                    selectedArmorIndex = G.AutoArmorSettings.ArmorType
                elseif G.AutoArmorSettings.ArmorType:lower():find("max") then
                    isDelHoodArmor = true
                end
                
                -- Для брони Del Hood используем функцию безопасного выбора
                if isDelHoodArmor then
                    -- Используем функцию для поиска безопасного магазина брони
                    G.AutoArmorSettings.armorItem = G.getSafeArmorShop()
                    
                    -- Если нашли безопасный объект брони, устанавливаем его как магазин
                    if G.AutoArmorSettings.armorItem then
                        G.AutoArmorSettings.armorShop = G.AutoArmorSettings.armorItem.Parent
                    else
                        -- Если не нашли безопасный объект, ищем обычным способом
                        G.AutoArmorSettings.armorShop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop")
                        
                        if G.AutoArmorSettings.armorShop then
                            -- Если указан индекс, пробуем найти по нему
                            if selectedArmorIndex then
                                G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:GetChildren()[selectedArmorIndex]
                            else
                                -- Иначе ищем по имени
                                G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:FindFirstChild(G.AutoArmorSettings.ArmorType)
                                
                                -- Если не нашли, ищем любую Max Armor
                                if not G.AutoArmorSettings.armorItem then
                                    for _, item in pairs(G.AutoArmorSettings.armorShop:GetChildren()) do
                                        if item.Name:lower():find("armor") and item.Name:lower():find("max") then
                                            G.AutoArmorSettings.armorItem = item
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                else
                    -- Для обычной брони Da Hood используем стандартный поиск
                    G.AutoArmorSettings.armorShop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop")
                    
                    if G.AutoArmorSettings.armorShop then
                        G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:FindFirstChild(G.AutoArmorSettings.ArmorType)
                    end
                    
                    -- Если не нашли магазин или броню, пробуем найти в других местах
                    if not G.AutoArmorSettings.armorShop or not G.AutoArmorSettings.armorItem then
                        for _, folder in pairs(workspace:GetChildren()) do
                            if folder:FindFirstChild("Shop") then
                                G.AutoArmorSettings.armorShop = folder.Shop
                                G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:FindFirstChild(G.AutoArmorSettings.ArmorType)
                                if G.AutoArmorSettings.armorItem then break end
                            end
                        end
                    end
                    
                    -- Если всё ещё не нашли броню, ищем любую
                    if G.AutoArmorSettings.armorShop and not G.AutoArmorSettings.armorItem then
                        for _, item in pairs(G.AutoArmorSettings.armorShop:GetChildren()) do
                            if item.Name:lower():find("armor") then
                                G.AutoArmorSettings.armorItem = item
                                break
                            end
                        end
                    end
                end
                
                -- Если не нашли броню, отменяем покупку
                if not G.AutoArmorSettings.armorItem or not G.AutoArmorSettings.armorItem:FindFirstChild("Head") or 
                   not G.AutoArmorSettings.armorItem:FindFirstChild("ClickDetector") then
                    -- Сбрасываем флаги покупки брони
                    if getgenv().SaveDistance then
                        getgenv().SaveDistance.IsBuyingArmor = false
                    end
                    G.AutoArmorSettings.IsBuying = false
                    
                    -- Восстанавливаем состояние Target Strafe
                    if G.AutoArmorSettings.originalTSState and getgenv().TS then
                        getgenv().TS.Config.Enabled = G.AutoArmorSettings.originalTSState.Enabled
                        getgenv().TS.Config.UseDesync = G.AutoArmorSettings.originalTSState.UseDesync
                    end
                    
                    -- Восстанавливаем состояние AutoStomp
                    if G.AutoArmorSettings.autoStompOriginalState then
                        getgenv().AutoStomp.Enabled = G.AutoArmorSettings.autoStompOriginalState.Enabled
                        getgenv().AutoStomp.isActive = G.AutoArmorSettings.autoStompOriginalState.isActive
                    end
                    
                    return 
                end
                
                if not (G.AutoArmorSettings.armorItem:FindFirstChild("Head") and 
                       G.AutoArmorSettings.armorItem:FindFirstChild("ClickDetector")) then
                    -- Сбрасываем флаги покупки брони
                    if getgenv().SaveDistance then
                        getgenv().SaveDistance.IsBuyingArmor = false
                    end
                    G.AutoArmorSettings.IsBuying = false
                    
                    -- Восстанавливаем состояние AutoStomp
                    if G.AutoArmorSettings.autoStompOriginalState then
                        getgenv().AutoStomp.Enabled = G.AutoArmorSettings.autoStompOriginalState.Enabled
                        getgenv().AutoStomp.isActive = G.AutoArmorSettings.autoStompOriginalState.isActive
                    end
                    
                    return
                end
                
                -- Телепортируемся к броне, покупаем и возвращаемся
                G.AutoArmorSettings.originalCFrame = G.AutoArmorSettings.hrp.CFrame
                G.AutoArmorSettings.originalVelocity = G.AutoArmorSettings.hrp.Velocity
                
                -- Телепортируемся к броне для покупки
                local armorPosition = G.AutoArmorSettings.armorItem.Head.CFrame
                
                -- Сохраняем оригинальную позицию
                G.AutoArmorSettings.originalCFrame = G.AutoArmorSettings.hrp.CFrame
                G.AutoArmorSettings.originalVelocity = G.AutoArmorSettings.hrp.Velocity
                
                -- Телепортируемся к броне
                G.AutoArmorSettings.hrp.CFrame = armorPosition
                G.AutoArmorSettings.hrp.Velocity = Vector3.new(0, 0, 0)
                
                -- Создаем механизм фиксации позиции во время покупки
                local fixPositionConnection = nil
                fixPositionConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    -- Проверяем, что HRP все еще существует
                    if G.AutoArmorSettings.hrp and G.AutoArmorSettings.hrp.Parent then
                        -- Постоянно устанавливаем позицию у магазина брони
                        G.AutoArmorSettings.hrp.CFrame = armorPosition
                        G.AutoArmorSettings.hrp.Velocity = Vector3.new(0, 0, 0)
                    else
                        -- Если HRP больше нет, отключаем соединение
                        if fixPositionConnection then
                            fixPositionConnection:Disconnect()
                            fixPositionConnection = nil
                        end
                    end
                end)
                
                -- Пытаемся купить броню до тех пор, пока она не достигнет нужного уровня
                while G.getCurrentArmorValue() < G.AutoArmorSettings.MinArmorValue do
                    -- Проверяем timeout
                    if tick() >= G.AutoArmorSettings.BuyingTimeout then
                        -- Если время вышло, выходим из цикла
                        break
                    end
                    
                    -- Проверяем состояние K.O. и Grabbed
                    local bodyEffects = G.AutoArmorSettings.char:FindFirstChild("BodyEffects")
                    if bodyEffects then
                        local ko = bodyEffects:FindFirstChild("K.O")
                        local grabbed = bodyEffects:FindFirstChild("Grabbed")
                        
                        if (ko and ko.Value) or (grabbed and grabbed.Value) then
                            -- Если в нокауте или схвачен, прерываем покупку
                            break
                        end
                    end
                    
                    -- Нажимаем на кнопку покупки
                    fireclickdetector(G.AutoArmorSettings.armorItem.ClickDetector)
                    
                    -- Ждем небольшое время перед следующей попыткой
                    task.wait(0.2)
                end
                
                -- Отключаем соединение фиксации позиции
                if fixPositionConnection then
                    fixPositionConnection:Disconnect()
                    fixPositionConnection = nil
                end
                
                -- Возвращаемся на исходную позицию только если броня успешно куплена
                if G.getCurrentArmorValue() >= G.AutoArmorSettings.MinArmorValue then
                    G.AutoArmorSettings.hrp.CFrame = G.AutoArmorSettings.originalCFrame
                    G.AutoArmorSettings.hrp.Velocity = G.AutoArmorSettings.originalVelocity
                else
                    -- Если броня не купилась и не в таймауте, продолжаем попытки в следующем цикле
                    if tick() < G.AutoArmorSettings.BuyingTimeout then
                        return -- Продолжаем попытки покупки в следующих циклах
                    end
                end
                
                -- Процесс покупки брони уже выполнен выше
                
                -- Восстанавливаем состояние Target Strafe
                if G.AutoArmorSettings.originalTSState and getgenv().TS then
                    getgenv().TS.Config.Enabled = G.AutoArmorSettings.originalTSState.Enabled
                    getgenv().TS.Config.UseDesync = G.AutoArmorSettings.originalTSState.UseDesync
                    
                    -- Если был активен десинк, восстанавливаем позицию десинка
                    if G.AutoArmorSettings.originalTSState.UseDesync and G.AutoArmorSettings.DesyncPosition then
                        -- Ждем немного, чтобы Target Strafe успел инициализироваться
                        task.wait(0.2)
                        -- Обновляем позицию десинка
                        getgenv().TS.Runtime.DesyncPosition = G.AutoArmorSettings.DesyncPosition
                    end
                end
                
                -- Проверяем, что HumanoidRootPart все еще существует перед возвратом
                if G.AutoArmorSettings.hrp and G.AutoArmorSettings.hrp.Parent then
                    -- Возвращаемся с несколькими попытками для надежности
                    for i = 1, 3 do
                        G.AutoArmorSettings.hrp.CFrame = G.AutoArmorSettings.BuyingArmor
                        G.AutoArmorSettings.hrp.Velocity = G.AutoArmorSettings.originalVelocity -- Восстанавливаем скорость
                        task.wait(0.1) -- Ждем между попытками
                    end
                end
                
                -- Небольшая задержка для стабилизации
                task.wait(0.2)
                
                -- Восстанавливаем состояние AutoStomp
                if G.AutoArmorSettings.autoStompOriginalState then
                    getgenv().AutoStomp.Enabled = G.AutoArmorSettings.autoStompOriginalState.Enabled
                    getgenv().AutoStomp.isActive = G.AutoArmorSettings.autoStompOriginalState.isActive
                end
                
                -- Сбрасываем флаги покупки брони
                if getgenv().SaveDistance then
                    getgenv().SaveDistance.IsBuyingArmor = false
                end
                G.AutoArmorSettings.IsBuying = false
                
                -- Уведомляем о покупке, если включены уведомления
                if G.AutoArmorSettings.Notify then
                    Library:Notify(">_<", 2)
                end
            end)
        else
            G.AutoArmorSettings.BuyingArmor = nil
        end
    end)
    
    if not G.success and G.AutoArmorSettings.Notify then
        -- Если произошла ошибка и включены уведомления, показываем сообщение об ошибке
        Library:Notify(">_<", 3)
        -- Сбрасываем флаги при ошибке
        G.AutoArmorSettings.IsBuying = false
        if getgenv().SaveDistance then
            getgenv().SaveDistance.IsBuyingArmor = false
        end
        
        -- Восстанавливаем состояние Target Strafe при ошибке
        if G.AutoArmorSettings.originalTSState and getgenv().TS then
            getgenv().TS.Config.Enabled = G.AutoArmorSettings.originalTSState.Enabled
            getgenv().TS.Config.UseDesync = G.AutoArmorSettings.originalTSState.UseDesync
        end
        
        -- Восстанавливаем состояние AutoStomp при ошибке
        if getgenv().AutoStomp and G.AutoArmorSettings.autoStompOriginalState then
            getgenv().AutoStomp.Enabled = G.AutoArmorSettings.autoStompOriginalState.Enabled
            getgenv().AutoStomp.isActive = G.AutoArmorSettings.autoStompOriginalState.isActive
        end
    end
end

-- Глобальная функция для включения/отключения AutoArmor
G.toggleAutoArmor = function(state)
    G.AutoArmorSettings.Enabled = state
    
    -- Отключаем предыдущее соединение
    if G.AutoArmorSettings.Connection then
        G.AutoArmorSettings.Connection:Disconnect()
        G.AutoArmorSettings.Connection = nil
    end
    
    -- Создаем новое соединение, если включено
    if state then
        G.AutoArmorSettings.Connection = game:GetService("RunService").RenderStepped:Connect(G.autoArmorFunction)
        
        -- Немедленно вызываем функцию для проверки текущего значения брони
        task.spawn(function()
            G.autoArmorFunction()
        end)
        
        Library:Notify(">_< on", 3)
    else
        Library:Notify(">_< off", 3)
    end
end

-- UI для AutoArmor
addToggleWithNotify(G.AutoArmorGroup, 'AutoArmorEnabled', {
    Text = 'AutoArmor',
    Default = false,
    Callback = function(v) 
        G.toggleAutoArmor(v)
    end,
    Tooltip = '>_<'
})

-- UseDesync опция удалена

G.AutoArmorGroup:AddSlider('AutoArmorMinValue', {
    Text = 'MinValue',
    Default = G.AutoArmorSettings.MinArmorValue,
    Min = 0, Max = 200, Rounding = 0,
    Callback = function(v) G.AutoArmorSettings.MinArmorValue = v end,
    Tooltip = '>_<'
})

G.AutoArmorGroup:AddSlider('AutoArmorInterval', {
    Text = 'Interval',
    Default = G.AutoArmorSettings.CheckInterval,
    Min = 0.1, Max = 5, Rounding = 1,
    Callback = function(v) G.AutoArmorSettings.CheckInterval = v end,
    Tooltip = '>_<'
})

-- Убран слайдер MaxAttempts, так как теперь броня покупается до успешного результата

-- Список всех известных объектов брони для Del Hood
G.delHoodArmorOptions = {
    [1] = {index = 59, name = "Max Armor 1"},
    [2] = {index = 46, name = "Max Armor 2"},
    [3] = {index = 63, name = "Max Armor 3"},
    [4] = {index = 68, name = "Max Armor 4"},
    [5] = {name = "[Max Armor]", direct = true}
}

-- Функция для проверки наличия игроков рядом с объектом
G.isAreaSafe = function(position, radius)
    if not position then return false end
    
    -- Проверяем всех игроков
    for _, player in pairs(S.PS:GetPlayers()) do
        if player ~= LP and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - position).Magnitude
            if distance <= radius then
                return false -- Обнаружен игрок в радиусе
            end
        end
    end
    
    return true -- Игроков в радиусе нет
end

-- Функция для получения безопасного объекта брони
G.getSafeArmorShop = function()
    if not workspace:FindFirstChild("Ignored") or not workspace.Ignored:FindFirstChild("Shop") then
        return nil
    end
    
    local shop = workspace.Ignored.Shop
    local safeOptions = {}
    
    -- Проверяем все варианты Max Armor
    for i, option in pairs(G.delHoodArmorOptions) do
        local armorObj
        
        if option.direct then
            -- Прямой доступ по имени
            armorObj = shop:FindFirstChild(option.name)
        else
            -- Доступ по индексу
            armorObj = shop:GetChildren()[option.index]
        end
        
        if armorObj and armorObj:FindFirstChild("Head") then
            local position = armorObj.Head.Position
            local isSafe = G.isAreaSafe(position, 15) -- Проверяем радиус 15 studs
            
            -- Сохраняем информацию о броне и её безопасности
            table.insert(safeOptions, {
                object = armorObj,
                isSafe = isSafe,
                name = option.name
            })
        end
    end
    
    -- Сначала ищем безопасные варианты
    for _, option in ipairs(safeOptions) do
        if option.isSafe then
            return option.object
        end
    end
    
    -- Если безопасных вариантов нет, возвращаем первый доступный
    for _, option in ipairs(safeOptions) do
        return option.object
    end
    
    -- Если всё ещё не нашли броню, ищем любую
    for _, item in pairs(shop:GetChildren()) do
        if item.Name:lower():find("armor") and item.Name:lower():find("max") then
            return item
        end
    end
    
    return nil
end

-- Упрощаем систему брони только до 4 вариантов Max Armor для Del Hood
G.setupArmorOptions = function()
    -- Сначала определяем глобальные массивы и карты
    G.armorDropdownValues = {"Max Armor 1 (Del Hood)", "Max Armor 2 (Del Hood)", "Max Armor 3 (Del Hood)", "Max Armor 4 (Del Hood)"}
    G.armorValueMap = {}
    
    -- Сопоставляем каждому варианту соответствующий индекс
    G.armorValueMap["Max Armor 1 (Del Hood)"] = 1
    G.armorValueMap["Max Armor 2 (Del Hood)"] = 2
    G.armorValueMap["Max Armor 3 (Del Hood)"] = 3
    G.armorValueMap["Max Armor 4 (Del Hood)"] = 4
end

-- Настраиваем опции брони
G.setupArmorOptions()

-- Сохраняем карту значений для использования в колбэке
G.AutoArmorSettings.ArmorValuesMap = G.armorValueMap

G.AutoArmorGroup:AddDropdown('AutoArmorType', {
    Text = 'ArmorType',
    Values = {"Max Armor 1 (Del Hood)", "Max Armor 2 (Del Hood)", "Max Armor 3 (Del Hood)", "Max Armor 4 (Del Hood)"},
    Default = "Max Armor 1 (Del Hood)",
    Callback = function(v) 
        -- Получаем номер брони из названия
        local armorNumber = tonumber(string.match(v, "Max Armor (%d)"))
        
        -- Используем числовой индекс для Del Hood
        G.AutoArmorSettings.ArmorType = armorNumber or 1
        
        -- Выводим информацию о выбранном типе брони для отладки
        if G.AutoArmorSettings.DebugMode then
            print("Selected armor type:", G.AutoArmorSettings.ArmorType, "Type:", type(G.AutoArmorSettings.ArmorType))
        end
    end,
    Tooltip = '>_<'
})

-- === VelocityAA (Player tab, новая секция) ===
local VelocityAAGroup = Tabs.Player:AddRightGroupbox('>_<')

-- Инициализация переменных
getgenv().VelocityAA = {
    Enable = false,
    Visualise = false
}

-- Создаем соединение для VelocityAA
getgenv().velocityAAConnection = nil
-- Используем напрямую getgenv().velocityAAConnection

-- Визуализация скорости
-- Делаем объект глобальным для уменьшения количества локальных переменных
getgenv().velocityVisualizer = {
    anchorPart = nil,
    billboard = nil,
    imageLabel = nil,
    connection = nil,
    characterConnection = nil
}
-- Используем напрямую getgenv().velocityVisualizer

-- Функция для создания визуализатора скорости
-- Делаем функцию глобальной для уменьшения количества локальных переменных
getgenv().createVelocityVisualizer = function()
    -- Удаляем предыдущий визуализатор, если он существует
    if velocityVisualizer.anchorPart then
        velocityVisualizer.anchorPart:Destroy()
    end
    
    -- Используем напрямую getgenv().createVelocityVisualizer
    
    -- Отключаем предыдущие соединения
    if velocityVisualizer.connection then
        velocityVisualizer.connection:Disconnect()
        velocityVisualizer.connection = nil
    end
    
    if velocityVisualizer.characterConnection then
        velocityVisualizer.characterConnection:Disconnect()
        velocityVisualizer.characterConnection = nil
    end
    
    -- Создаем невидимую Part для привязки GUI
    local anchorPart = Instance.new("Part")
    anchorPart.Name = "VelocityAnchor"
    anchorPart.Anchored = true
    anchorPart.CanCollide = false
    anchorPart.Transparency = 1
    anchorPart.Size = Vector3.new(0.1, 0.1, 0.1)
    anchorPart.Parent = workspace

    -- Создаем BillboardGui с ImageLabel
    local billboard = Instance.new("BillboardGui")
    billboard.Adornee = anchorPart
    billboard.Size = UDim2.new(1.5, 0, 1.5, 0) -- Уменьшенный размер (было 2, 0, 2, 0)
    billboard.AlwaysOnTop = true
    billboard.LightInfluence = 0
    billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    billboard.MaxDistance = 10000
    billboard.Parent = anchorPart

    -- ImageLabel с указанной текстурой
    local imageLabel = Instance.new("ImageLabel")
    imageLabel.Image = "rbxassetid://108758683130028"
    imageLabel.Size = UDim2.new(1, 0, 1, 0)
    imageLabel.BackgroundTransparency = 1
    imageLabel.ZIndex = 999999
    imageLabel.Parent = billboard
    
    -- Сохраняем ссылки
    velocityVisualizer.anchorPart = anchorPart
    velocityVisualizer.billboard = billboard
    velocityVisualizer.imageLabel = imageLabel
    
    -- Настройки визуализации
    local velocityMultiplier = 0.3
    local maxDistance = 15
    local lowerTorso = nil
    
    -- Функция обновления визуализатора
    local function updateVisualizer()
        -- Проверяем, что визуализация включена
        if not getgenv().VelocityAA.Visualise then return end
        
        -- Получаем текущий LowerTorso
        if not lowerTorso or not lowerTorso:IsDescendantOf(workspace) then
            if LP.Character then
                lowerTorso = LP.Character:FindFirstChild("LowerTorso")
                -- Если LowerTorso не найден, попробуем использовать HumanoidRootPart как запасной вариант
                if not lowerTorso then
                    lowerTorso = LP.Character:FindFirstChild("HumanoidRootPart")
                end
            end
            if not lowerTorso then return end
        end

        -- Если VelocityAA включен, показываем позицию анти-аима
        if getgenv().VelocityAA.Enable then
            imageLabel.Visible = true
            -- Позиция анти-аима всегда над персонажем
            anchorPart.CFrame = CFrame.new(
                lowerTorso.Position + Vector3.new(0, 250, 0)
            )
            -- Устанавливаем цвет для анти-аима
            imageLabel.ImageColor3 = Color3.fromRGB(255, 0, 0) -- Красный для анти-аима
        else
            -- Если анти-аим выключен, но визуализация включена, показываем обычный вектор скорости
            local vel = lowerTorso.Velocity
            local speed = vel.Magnitude

            -- Если скорость мала, скрываем ImageLabel
            if speed < 1 then
                imageLabel.Visible = false
                return
            else
                imageLabel.Visible = true
            end

            -- Двигаем anchorPart по вектору скорости
            local direction = vel.Unit
            local distance = math.min(speed * velocityMultiplier, maxDistance)
            anchorPart.CFrame = CFrame.new(
                lowerTorso.Position + (direction * distance) + Vector3.new(0, 0.5, 0)
            )

            -- Поворачиваем ImageLabel в сторону движения
            imageLabel.Rotation = math.deg(math.atan2(direction.X, direction.Z)) + 180
            -- Используем текущий цвет из колорпикера (не перезаписываем его)
        end
    end
    
    -- Обновляем каждый кадр
    velocityVisualizer.connection = game:GetService("RunService").Heartbeat:Connect(updateVisualizer)
    
    -- Обновляем ссылки при перерождении
    velocityVisualizer.characterConnection = LP.CharacterAdded:Connect(function(newChar)
        task.wait(0.5) -- Ждем загрузки персонажа
        lowerTorso = newChar:FindFirstChild("LowerTorso") or newChar:WaitForChild("LowerTorso", 3)
        -- Если LowerTorso не найден, используем HumanoidRootPart как запасной вариант
        if not lowerTorso then
            lowerTorso = newChar:FindFirstChild("HumanoidRootPart") or newChar:WaitForChild("HumanoidRootPart", 3)
        end
    end)
    
    -- Инициализируем LowerTorso
    if LP.Character then
        lowerTorso = LP.Character:FindFirstChild("LowerTorso")
        -- Если LowerTorso не найден, используем HumanoidRootPart как запасной вариант
        if not lowerTorso then
            lowerTorso = LP.Character:FindFirstChild("HumanoidRootPart")
        end
    end
end

-- Функция для включения/выключения визуализации скорости
-- Делаем функцию глобальной для уменьшения количества локальных переменных
getgenv().toggleVelocityVisualizer = function(state)
    getgenv().VelocityAA.Visualise = state
    
    if state then
        getgenv().createVelocityVisualizer()
        Library:Notify(">_<", 3)
    else
        -- Отключаем соединения
        if getgenv().velocityVisualizer.connection then
            getgenv().velocityVisualizer.connection:Disconnect()
            getgenv().velocityVisualizer.connection = nil
        end
        
        if getgenv().velocityVisualizer.characterConnection then
            getgenv().velocityVisualizer.characterConnection:Disconnect()
            getgenv().velocityVisualizer.characterConnection = nil
        end
        
        -- Удаляем визуализатор
        if getgenv().velocityVisualizer.anchorPart then
            getgenv().velocityVisualizer.anchorPart:Destroy()
            getgenv().velocityVisualizer.anchorPart = nil
        end
    end
end
-- Используем напрямую getgenv().toggleVelocityVisualizer

-- Функция для включения/выключения VelocityAA
-- Делаем функцию глобальной для уменьшения количества локальных переменных
getgenv().toggleVelocityAA = function(state)
    getgenv().VelocityAA.Enable = state
    
    if state then
        if getgenv().velocityAAConnection then getgenv().velocityAAConnection:Disconnect() end
        
        getgenv().velocityAAConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if getgenv().VelocityAA.Enable then
                local character = LP.Character
                if character and character:FindFirstChild("HumanoidRootPart") then
                    local hrp = character.HumanoidRootPart
                    local vel = hrp.Velocity
                    hrp.Velocity = Vector3.new(0, 250, 0)
                    game:GetService("RunService").RenderStepped:Wait()
                    hrp.Velocity = vel
                end
            end
        end)
        
        -- Если визуализация включена, но визуализатор не создан, создаем его
        if getgenv().VelocityAA.Visualise and not getgenv().velocityVisualizer.anchorPart then
            getgenv().createVelocityVisualizer()
        end
    else
        if getgenv().velocityAAConnection then
            getgenv().velocityAAConnection:Disconnect()
            getgenv().velocityAAConnection = nil
        end
    end
end

-- Добавляем тоггл для VelocityAA
getgenv().VelocityAAToggle = addToggleWithNotify(VelocityAAGroup, 'VelocityAAEnabled', {
    Text = 'VelocityAA',
    Default = false,
    Callback = function(v)
        getgenv().toggleVelocityAA(v)
    end,
    Tooltip = '>_<'
})

-- Добавляем тоггл для визуализации скорости
addToggleWithNotify(VelocityAAGroup, 'VisualiseVeloEnabled', {
    Text = 'VisualiseVelo',
    Default = false,
    Callback = function(v)
        getgenv().toggleVelocityVisualizer(v)
    end,
    Tooltip = '>_<'
}):AddColorPicker('VisualiseVeloColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Color',
    Transparency = 0,
    Callback = function(val)
        if getgenv().velocityVisualizer and getgenv().velocityVisualizer.imageLabel then
            getgenv().velocityVisualizer.imageLabel.ImageColor3 = val
        end
    end
})

-- Отключаем VelocityAA, визуализацию и другие функции при выходе из игры
LP.CharacterRemoving:Connect(function()
    if getgenv().VelocityAA.Enable then
        getgenv().toggleVelocityAA(false)
        Toggles.VelocityAAEnabled:SetValue(false)
    end
    
    if getgenv().VelocityAA.Visualise then
        getgenv().toggleVelocityVisualizer(false)
        Toggles.VisualiseVeloEnabled:SetValue(false)
    end
    
    -- Отключаем соединения при смене персонажа
    -- Используем единую систему соединений
    if getgenv().AutoShootConnection then
        getgenv().AutoShootConnection:Disconnect()
        getgenv().AutoShootConnection = nil
        _G.AutoShootConnection = nil
    end
    
    if getgenv().VirtualClickConnection then
        getgenv().VirtualClickConnection:Disconnect()
        getgenv().VirtualClickConnection = nil
    end
end)

-- Обработка Auto Reload и Auto Shoot при смене персонажа
LP.CharacterAdded:Connect(function(character)
    -- Если Auto Reload включен, нужно переподключить его к новому персонажу
    if getgenv().flags["Auto Reload"] and Toggles.AutoReload and Toggles.AutoReload.Value then
        -- Переподключаем Auto Reload - используем тот же подход, что и для AutoShoot
        if Toggles.AutoReload and Toggles.AutoReload.Callback then
            Toggles.AutoReload:SetValue(false)
            task.wait(0.1)
            Toggles.AutoReload:SetValue(true)
        end
    end
    
    -- Если Auto Shoot включен, нужно переподключить его к новому персонажу
    -- Используем только getgenv().flags для проверки состояния
    if getgenv().flags["Auto Shoot"] and Toggles.AutoShoot and Toggles.AutoShoot.Value then
        -- Переподключаем Auto Shoot - используем getgenv().AutoShootConnection
        -- Не создаем новое соединение здесь, а просто вызываем колбэк тогла
        -- для переподключения всех соединений правильно
        if Toggles.AutoShoot and Toggles.AutoShoot.Callback then
            Toggles.AutoShoot:SetValue(false)
            task.wait(0.1)
            Toggles.AutoShoot:SetValue(true)
        end
    end
end)

-- Trail UI и логика
getgenv().TrailSettings = {
    enabled = false,
    color1 = Color3.new(1, 1, 1),
    color2 = Color3.new(1, 1, 1),
    transparency = 0.2,
    lifetime = 2
}

-- Функция для удаления трейла
getgenv().removeTrail = function()
    if getgenv().currentTrail and getgenv().currentTrail.Parent then
        -- Удаляем все компоненты трейла
        for _, child in pairs(LP.Character:GetChildren()) do
            if child:IsA("Trail") or (child:IsA("Attachment") and (child.Name == "TrailAttachment0" or child.Name == "TrailAttachment1")) then
                child:Destroy()
            end
        end
    end
    getgenv().currentTrail = nil
end

-- Функция для создания трейла
getgenv().createTrail = function(character)
    getgenv().removeTrail()
    
    getgenv().trailHead = character:FindFirstChild("Head")
    getgenv().trailHrp = character:FindFirstChild("HumanoidRootPart")
    
    if getgenv().trailHead and getgenv().trailHrp then
        getgenv().trailAttachment0 = Instance.new("Attachment", getgenv().trailHead)
        getgenv().trailAttachment0.Name = "TrailAttachment0"
        
        getgenv().trailAttachment1 = Instance.new("Attachment", getgenv().trailHrp)
        getgenv().trailAttachment1.Name = "TrailAttachment1"
        
        getgenv().trail = Instance.new("Trail")
        getgenv().trail.Attachment0 = getgenv().trailAttachment0
        getgenv().trail.Attachment1 = getgenv().trailAttachment1
        getgenv().trail.Lifetime = getgenv().TrailSettings.lifetime
        
        getgenv().trail.Texture = "rbxassetid://18421838422"
        getgenv().trail.TextureMode = Enum.TextureMode.Stretch
        getgenv().trail.Transparency = NumberSequence.new(getgenv().TrailSettings.transparency, 1)
        getgenv().trail.MinLength = 0.5
        getgenv().trail.WidthScale = NumberSequence.new(0.7)
        getgenv().trail.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, getgenv().TrailSettings.color1),
            ColorSequenceKeypoint.new(1, getgenv().TrailSettings.color2)
        })
        
        getgenv().trail.Parent = character
        getgenv().currentTrail = getgenv().trail
    end
end

-- Функция для обновления параметров трейла
getgenv().updateTrail = function(prop)
    if not (getgenv().currentTrail and getgenv().currentTrail.Parent) then return end
    
    if prop == "color" or prop == nil then
        getgenv().currentTrail.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, getgenv().TrailSettings.color1),
            ColorSequenceKeypoint.new(1, getgenv().TrailSettings.color2)
        })
    end
    
    if prop == "transparency" or prop == nil then
        getgenv().currentTrail.Transparency = NumberSequence.new(getgenv().TrailSettings.transparency, 1)
    end
    
    if prop == "lifetime" or prop == nil then
        getgenv().currentTrail.Lifetime = getgenv().TrailSettings.lifetime
    end
end

-- Функция для применения трейла
getgenv().applyTrail = function()
    getgenv().trailCharacter = LP.Character
    if not getgenv().trailCharacter then
        if getgenv().trailCharacterAddedConnection then
            getgenv().trailCharacterAddedConnection:Disconnect()
            getgenv().trailCharacterAddedConnection = nil
        end
        
        getgenv().trailCharacterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if getgenv().TrailSettings.enabled then 
                getgenv().createTrail(newCharacter) 
            end
        end)
        return
    end
    
    getgenv().createTrail(getgenv().trailCharacter)
    
    if not getgenv().trailCharacterAddedConnection then
        getgenv().trailCharacterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if getgenv().TrailSettings.enabled then 
                getgenv().createTrail(newCharacter) 
            end
        end)
    end
end

-- Создание UI для трейла
getgenv().TrailGroup = Tabs.Visuals:AddRightGroupbox('Trail')
addToggleWithNotify(getgenv().TrailGroup, 'Trail', {
    Text = 'Trail',
    Default = false,
    Callback = function(v)
        getgenv().TrailSettings.enabled = v
        if v then
            getgenv().applyTrail()
        else
            getgenv().removeTrail()
        end
    end,
    Tooltip = '>_<'
}):AddColorPicker('TrailColor1', {
    Default = getgenv().TrailSettings.color1,
    Title = 'Color 1',
    Callback = function(val)
        getgenv().TrailSettings.color1 = val
        getgenv().updateTrail("color")
    end
}):AddColorPicker('TrailColor2', {
    Default = getgenv().TrailSettings.color2,
    Title = 'Color 2',
    Callback = function(val)
        getgenv().TrailSettings.color2 = val
        getgenv().updateTrail("color")
    end
})

getgenv().TrailSub = getgenv().TrailGroup:AddDependencyBox()
getgenv().TrailSub:AddSlider('TrailTransparency', {
    Text = 'Transparency',
    Default = getgenv().TrailSettings.transparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(val)
        getgenv().TrailSettings.transparency = val
        getgenv().updateTrail("transparency")
    end,
    Tooltip = '>_<'
})
getgenv().TrailSub:AddSlider('TrailLifetime', {
    Text = 'Lifetime',
    Default = getgenv().TrailSettings.lifetime,
    Min = 0.5,
    Max = 5,
    Rounding = 1,
    Callback = function(val)
        getgenv().TrailSettings.lifetime = val
        getgenv().updateTrail("lifetime")
    end,
    Tooltip = '>_<'
})
getgenv().TrailSub:SetupDependencies({{Toggles.Trail, true}})

-- === Snow Effect (Visuals tab) ===
local SnowGroup = Tabs.Visuals:AddLeftGroupbox('Snow Effect')

-- Инициализация настроек снега
getgenv().SnowSettings = {
    Enabled = false,
    Texture = "rbxassetid://9563725822",
    Color = Color3.fromRGB(255, 255, 255),
    
    MinSize = 0.4,
    MaxSize = 0.4,
    
    Height = 100,
    FallSpeed = 13, -- Фиксированная скорость падения
    WindStrength = 3,
    SwirlIntensity = 0,
    
    Density = 200,
    Lifetime = 15, -- Фиксированное время жизни
    Transparency = 0.2,
    LightEmission = 0.15,
    
    EmissionArea = Vector3.new(60, 0, 60), -- Фиксированная область эмиссии
    
    SnowEmitters = {},
    SnowConnections = {}
}

-- Функция создания снега
getgenv().CreateRealSnow = function(player)
    -- Очистка предыдущего снега
    getgenv().ClearAllSnow()
    
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local upperTorso = character:FindFirstChild("UpperTorso")
    
    if not humanoid or not upperTorso then
        print("Не удалось найти Humanoid или UpperTorso для эффекта снега")
        return
    end
    
    -- Очистка предыдущего снега
    for _, v in ipairs(upperTorso:GetChildren()) do
        if v.Name == "RealSnowEmitter" then
            v:Destroy()
        end
    end
    
    -- Создаем Attachment в верхней части туловища
    local emitterAttachment = Instance.new("Attachment")
    emitterAttachment.Name = "RealSnowEmitter"
    emitterAttachment.Position = Vector3.new(0, getgenv().SnowSettings.Height, 0)
    emitterAttachment.Parent = upperTorso

    -- Настройка эмиттера
    local emitter = Instance.new("ParticleEmitter")
    emitter.Name = "SnowEmitter"
    
    -- Основные настройки
    emitter.Texture = getgenv().SnowSettings.Texture
    emitter.LightEmission = getgenv().SnowSettings.LightEmission
    emitter.Color = ColorSequence.new(getgenv().SnowSettings.Color)
    emitter.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, getgenv().SnowSettings.Transparency),
        NumberSequenceKeypoint.new(1, 1)
    })
    
    -- Размер снежинок
    emitter.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, getgenv().SnowSettings.MinSize),
        NumberSequenceKeypoint.new(0.5, getgenv().SnowSettings.MaxSize * 0.8),
        NumberSequenceKeypoint.new(1, getgenv().SnowSettings.MaxSize)
    })
    
    -- Физика частиц
    emitter.Lifetime = NumberRange.new(getgenv().SnowSettings.Lifetime)
    emitter.Speed = NumberRange.new(getgenv().SnowSettings.FallSpeed * 0.8, getgenv().SnowSettings.FallSpeed)
    emitter.VelocitySpread = 180
    emitter.Rotation = NumberRange.new(0, 360)
    emitter.RotSpeed = NumberRange.new(-10, 10)
    
    -- Форма и распределение
    emitter.Shape = Enum.ParticleEmitterShape.Box
    emitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
    emitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
    emitter.EmissionDirection = Enum.NormalId.Bottom
    emitter.Rate = getgenv().SnowSettings.Density
    
    -- Устанавливаем область эмиссии через свойства, которые точно существуют
    local area = getgenv().SnowSettings.EmissionArea
    emitter.SpreadAngle = Vector2.new(area.X / 2, area.Z / 2)
    
    -- Размер снежинок уже установлен выше через emitter.Size
    
    -- Динамический ветер и завихрения
    local windDirection = Vector3.new(
        math.random() * getgenv().SnowSettings.WindStrength - getgenv().SnowSettings.WindStrength/2,
        0,
        math.random() * getgenv().SnowSettings.WindStrength - getgenv().SnowSettings.WindStrength/2
    )
    
    local swirlTime = 0
    local windConnection
    windConnection = S.RS.Heartbeat:Connect(function(dt)
        if not emitter or not emitter.Parent then
            windConnection:Disconnect()
            return
        end
        
        swirlTime = swirlTime + dt * 0.5
        local swirlX = math.sin(swirlTime) * getgenv().SnowSettings.SwirlIntensity
        local swirlZ = math.cos(swirlTime * 1.3) * getgenv().SnowSettings.SwirlIntensity
        
        emitter.VelocityInheritance = 0.1 + math.abs(math.sin(swirlTime * 0.7)) * 0.5
        emitter.Acceleration = Vector3.new(
            windDirection.X + swirlX,
            -getgenv().SnowSettings.FallSpeed * 0.2,
            windDirection.Z + swirlZ
        )
    end)
    
    table.insert(getgenv().SnowSettings.SnowConnections, windConnection)
    emitter.Parent = emitterAttachment
    table.insert(getgenv().SnowSettings.SnowEmitters, emitterAttachment)
    
    -- Автоматическая очистка
    local function Cleanup()
        if emitterAttachment and emitterAttachment.Parent then
            windConnection:Disconnect()
            emitterAttachment:Destroy()
            
            -- Удаление из таблицы
            for i, v in ipairs(getgenv().SnowSettings.SnowEmitters) do
                if v == emitterAttachment then
                    table.remove(getgenv().SnowSettings.SnowEmitters, i)
                    break
                end
            end
            
            for i, v in ipairs(getgenv().SnowSettings.SnowConnections) do
                if v == windConnection then
                    table.remove(getgenv().SnowSettings.SnowConnections, i)
                    break
                end
            end
        end
    end
    
    humanoid.Died:Connect(Cleanup)
    character.AncestryChanged:Connect(function(_, parent)
        if not parent then
            Cleanup()
        end
    end)
    
    player.CharacterRemoving:Connect(Cleanup)
end

-- Функция для очистки всех эмиттеров
getgenv().ClearAllSnow = function()
    for _, emitter in ipairs(getgenv().SnowSettings.SnowEmitters) do
        if emitter and emitter.Parent then
            emitter:Destroy()
        end
    end
    
    for _, connection in ipairs(getgenv().SnowSettings.SnowConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    
    getgenv().SnowSettings.SnowEmitters = {}
    getgenv().SnowSettings.SnowConnections = {}
end

-- Добавляем тогл для снега
addToggleWithNotify(SnowGroup, 'SnowEnabled', {
    Text = 'Snow Effect',
    Default = false,
    Callback = function(v)
        getgenv().SnowSettings.Enabled = v
        
        if v then
            local player = S.PS.LocalPlayer
            if player.Character then
                getgenv().CreateRealSnow(player)
            end
            
            -- Повторная инициализация при переспавне
            if getgenv().SnowRespawnConnection then
                getgenv().SnowRespawnConnection:Disconnect()
            end
            
            getgenv().SnowRespawnConnection = S.PS.LocalPlayer.CharacterAdded:Connect(function(character)
                task.wait(1) -- Даем время на появление UpperTorso
                if getgenv().SnowSettings.Enabled and character and character:FindFirstChild("UpperTorso") then
                    getgenv().CreateRealSnow(S.PS.LocalPlayer)
                end
            end)
            
            -- Подключаем обработчик для обновления при изменении персонажа
            if getgenv().SnowCharacterChangedConnection then
                getgenv().SnowCharacterChangedConnection:Disconnect()
            end
            
            getgenv().SnowCharacterChangedConnection = S.PS.LocalPlayer:GetPropertyChangedSignal("Character"):Connect(function()
                if S.PS.LocalPlayer.Character then
                    task.wait(1) -- Даем время на появление UpperTorso
                    if getgenv().SnowSettings.Enabled then
                        getgenv().CreateRealSnow(S.PS.LocalPlayer)
                    end
                end
            end)
        else
            getgenv().ClearAllSnow()
            if getgenv().SnowRespawnConnection then
                getgenv().SnowRespawnConnection:Disconnect()
                getgenv().SnowRespawnConnection = nil
            end
            
            if getgenv().SnowCharacterChangedConnection then
                getgenv().SnowCharacterChangedConnection:Disconnect()
                getgenv().SnowCharacterChangedConnection = nil
            end
        end
        
        Library:Notify(">_< Snow effect " .. (v and "enabled" or "disabled"), 3)
    end,
    Tooltip = 'Adds snow particle effect around your character'
}):AddColorPicker('SnowColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Snow Color',
    Transparency = 0,
    Callback = function(v)
        getgenv().SnowSettings.Color = v
        
        -- Обновляем цвет существующих эмиттеров
        for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
            if attachment and attachment.Parent then
                local emitter = attachment:FindFirstChild("SnowEmitter")
                if emitter then
                    emitter.Color = ColorSequence.new(v)
                end
            end
        end
    end
})

-- Добавляем DependencyBox для настроек снега (используем глобальную переменную)
getgenv().SnowSettingsDependency = SnowGroup:AddDependencyBox()

-- Слайдер для MinSize
getgenv().SnowSettingsDependency:AddSlider('SnowMinSize', {
    Text = 'Min Size',
    Default = getgenv().SnowSettings.MinSize,
    Min = 0.1,
    Max = 2.0,
    Rounding = 2,
    Callback = function(v)
        getgenv().SnowSettings.MinSize = v
        
        -- Обновляем размер существующих эмиттеров
        for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
            if attachment and attachment.Parent then
                local emitter = attachment:FindFirstChild("SnowEmitter")
                if emitter then
                    emitter.Size = NumberSequence.new({
                        NumberSequenceKeypoint.new(0, getgenv().SnowSettings.MinSize),
                        NumberSequenceKeypoint.new(0.5, getgenv().SnowSettings.MaxSize * 0.8),
                        NumberSequenceKeypoint.new(1, getgenv().SnowSettings.MaxSize)
                    })
                end
            end
        end
    end
})

-- Слайдер для MaxSize
getgenv().SnowSettingsDependency:AddSlider('SnowMaxSize', {
    Text = 'Max Size',
    Default = getgenv().SnowSettings.MaxSize,
    Min = 0.1,
    Max = 3.0,
    Rounding = 2,
    Callback = function(v)
        getgenv().SnowSettings.MaxSize = v
        
        -- Обновляем размер существующих эмиттеров
        for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
            if attachment and attachment.Parent then
                local emitter = attachment:FindFirstChild("SnowEmitter")
                if emitter then
                    emitter.Size = NumberSequence.new({
                        NumberSequenceKeypoint.new(0, getgenv().SnowSettings.MinSize),
                        NumberSequenceKeypoint.new(0.5, getgenv().SnowSettings.MaxSize * 0.8),
                        NumberSequenceKeypoint.new(1, getgenv().SnowSettings.MaxSize)
                    })
                end
            end
        end
    end
})

-- Слайдер для Transparency
getgenv().SnowSettingsDependency:AddSlider('SnowTransparency', {
    Text = 'Transparency',
    Default = getgenv().SnowSettings.Transparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(v)
        getgenv().SnowSettings.Transparency = v
        
        -- Обновляем прозрачность существующих эмиттеров
        for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
            if attachment and attachment.Parent then
                local emitter = attachment:FindFirstChild("SnowEmitter")
                if emitter then
                    emitter.Transparency = NumberSequence.new({
                        NumberSequenceKeypoint.new(0, getgenv().SnowSettings.Transparency),
                        NumberSequenceKeypoint.new(1, 1)
                    })
                end
            end
        end
    end
})

-- FallSpeed и Lifetime имеют фиксированные значения

-- Слайдер для LightEmission
getgenv().SnowSettingsDependency:AddSlider('SnowLightEmission', {
    Text = 'Light Emission',
    Default = getgenv().SnowSettings.LightEmission,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(v)
        getgenv().SnowSettings.LightEmission = v
        
        -- Обновляем светоизлучение существующих эмиттеров
        for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
            if attachment and attachment.Parent then
                local emitter = attachment:FindFirstChild("SnowEmitter")
                if emitter then
                    emitter.LightEmission = v
                end
            end
        end
    end
})

-- EmissionArea имеет фиксированное значение (100, 0, 100)

-- Добавляем выбор текстуры снежинок
getgenv().SnowSettingsDependency:AddDropdown('SnowTexture', {
    Text = 'Type',
    Values = {
        "V1", 
        "V2", 
        "V3", 
        "V4", 
        "V5",
        "V6"
    },
    Default = "V1",
    Callback = function(v)
        if not v or v == "" then v = "V1" end -- Защита от nil значения и установка значения по умолчанию
        
        local textures = {
            ["V1"] = "rbxassetid://9563725822",
            ["V2"] = "rbxassetid://14590122278",
            ["V3"] = "rbxassetid://12389944487",
            ["V4"] = "rbxassetid://12362734091",
            ["V5"] = "rbxassetid://242213983",
            ["V6"] = "rbxassetid://9563941378"
        }
        
        local texture = textures[v]
        if not texture then 
            texture = textures["V1"]
            print("Выбрана текстура по умолчанию (V1)")
        end
        
        getgenv().SnowSettings.Texture = texture
        
        -- Обновляем текстуру существующих эмиттеров
        for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
            if attachment and attachment.Parent then
                local emitter = attachment:FindFirstChild("SnowEmitter")
                if emitter then
                    emitter.Texture = getgenv().SnowSettings.Texture
                end
            end
        end
    end
})

-- Настраиваем зависимость от включения снега
getgenv().SnowSettingsDependency:SetupDependencies({{Toggles.SnowEnabled, true}})

-- Добавляем очистку при телепортации
game:GetService("Players").LocalPlayer.OnTeleport:Connect(function()
    if getgenv().ClearAllSnow then
        getgenv().ClearAllSnow()
    end
end)

-- Добавляем очистку при выгрузке скрипта
if getgenv().oldSnowCleanupConnection then
    getgenv().oldSnowCleanupConnection:Disconnect()
end

getgenv().oldSnowCleanupConnection = game:GetService("CoreGui").ChildRemoved:Connect(function(child)
    if child.Name == "ScreenGui" and getgenv().ClearAllSnow then
        getgenv().ClearAllSnow()
    end
end)

-- Конец скрипта
